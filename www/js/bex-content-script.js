/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "014b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__("e53d");
var has = __webpack_require__("07e3");
var DESCRIPTORS = __webpack_require__("8e60");
var $export = __webpack_require__("63b6");
var redefine = __webpack_require__("9138");
var META = __webpack_require__("ebfd").KEY;
var $fails = __webpack_require__("294c");
var shared = __webpack_require__("dbdb");
var setToStringTag = __webpack_require__("45f2");
var uid = __webpack_require__("62a0");
var wks = __webpack_require__("5168");
var wksExt = __webpack_require__("ccb9");
var wksDefine = __webpack_require__("6718");
var enumKeys = __webpack_require__("47ee");
var isArray = __webpack_require__("9003");
var anObject = __webpack_require__("e4ae");
var isObject = __webpack_require__("f772");
var toIObject = __webpack_require__("36c3");
var toPrimitive = __webpack_require__("1bc3");
var createDesc = __webpack_require__("aebd");
var _create = __webpack_require__("a159");
var gOPNExt = __webpack_require__("0395");
var $GOPD = __webpack_require__("bf0b");
var $DP = __webpack_require__("d9f6");
var $keys = __webpack_require__("c3a1");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("6abf").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("355d").f = $propertyIsEnumerable;
  __webpack_require__("9aa9").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("b8e3")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("35e8")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "01f9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("2d00");
var $export = __webpack_require__("5ca1");
var redefine = __webpack_require__("2aba");
var hide = __webpack_require__("32e9");
var Iterators = __webpack_require__("84f2");
var $iterCreate = __webpack_require__("41a0");
var setToStringTag = __webpack_require__("7f20");
var getPrototypeOf = __webpack_require__("38fd");
var ITERATOR = __webpack_require__("2b4c")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "0293":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__("241e");
var $getPrototypeOf = __webpack_require__("53e2");

__webpack_require__("ce7e")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),

/***/ "02f4":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("4588");
var defined = __webpack_require__("be13");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "0390":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var at = __webpack_require__("02f4")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "0395":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("36c3");
var gOPN = __webpack_require__("6abf").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "061b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("fa99");

/***/ }),

/***/ "06db":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__("23c6");
var test = {};
test[__webpack_require__("2b4c")('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__("2aba")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),

/***/ "07e3":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "09fa":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__("4588");
var toLength = __webpack_require__("9def");
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),

/***/ "0a49":
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__("9b43");
var IObject = __webpack_require__("626a");
var toObject = __webpack_require__("4bf8");
var toLength = __webpack_require__("9def");
var asc = __webpack_require__("cd1c");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "0bfb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__("cb7c");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "0d58":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("ce10");
var enumBugKeys = __webpack_require__("e11e");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "0d6d":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__("d3f4");
var meta = __webpack_require__("67ab").onFreeze;

__webpack_require__("5eda")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),

/***/ "0f88":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var hide = __webpack_require__("32e9");
var uid = __webpack_require__("ca5a");
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),

/***/ "0fc9":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("3a38");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("ecfa");


/***/ }),

/***/ "1169":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("2d95");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "11e9":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("52a7");
var createDesc = __webpack_require__("4630");
var toIObject = __webpack_require__("6821");
var toPrimitive = __webpack_require__("6a99");
var has = __webpack_require__("69a8");
var IE8_DOM_DEFINE = __webpack_require__("c69a");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__("9e1e") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "1495":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("86cc");
var anObject = __webpack_require__("cb7c");
var getKeys = __webpack_require__("0d58");

module.exports = __webpack_require__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "1654":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("71c1")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("30f1")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "1691":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "1991":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("9b43");
var invoke = __webpack_require__("31f4");
var html = __webpack_require__("fab2");
var cel = __webpack_require__("230e");
var global = __webpack_require__("7726");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__("2d95")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "1af6":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__("63b6");

$export($export.S, 'Array', { isArray: __webpack_require__("9003") });


/***/ }),

/***/ "1bc3":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("f772");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "1c4c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__("9b43");
var $export = __webpack_require__("5ca1");
var toObject = __webpack_require__("4bf8");
var call = __webpack_require__("1fa8");
var isArrayIter = __webpack_require__("33a4");
var toLength = __webpack_require__("9def");
var createProperty = __webpack_require__("f1ae");
var getIterFn = __webpack_require__("27ee");

$export($export.S + $export.F * !__webpack_require__("5cc5")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "1df8":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__("63b6");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__("ead6").set });


/***/ }),

/***/ "1e85":
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "1ec9":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("f772");
var document = __webpack_require__("e53d").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "1fa8":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("cb7c");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "20d6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__("5ca1");
var $find = __webpack_require__("0a49")(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__("9c6c")(KEY);


/***/ }),

/***/ "20fd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__("d9f6");
var createDesc = __webpack_require__("aebd");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "214f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__("b0c5");
var redefine = __webpack_require__("2aba");
var hide = __webpack_require__("32e9");
var fails = __webpack_require__("79e5");
var defined = __webpack_require__("be13");
var wks = __webpack_require__("2b4c");
var regexpExec = __webpack_require__("520a");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "230e":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
var document = __webpack_require__("7726").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "2397":
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__("5ca1");
var create = __webpack_require__("2aeb");
var aFunction = __webpack_require__("d8e8");
var anObject = __webpack_require__("cb7c");
var isObject = __webpack_require__("d3f4");
var fails = __webpack_require__("79e5");
var bind = __webpack_require__("f0c1");
var rConstruct = (__webpack_require__("7726").Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "23c6":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("2d95");
var TAG = __webpack_require__("2b4c")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "241e":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("25eb");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "25b0":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("1df8");
module.exports = __webpack_require__("584a").Object.setPrototypeOf;


/***/ }),

/***/ "25eb":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "2621":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "27ee":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("23c6");
var ITERATOR = __webpack_require__("2b4c")('iterator');
var Iterators = __webpack_require__("84f2");
module.exports = __webpack_require__("8378").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "28a5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__("aae3");
var anObject = __webpack_require__("cb7c");
var speciesConstructor = __webpack_require__("ebd6");
var advanceStringIndex = __webpack_require__("0390");
var toLength = __webpack_require__("9def");
var callRegExpExec = __webpack_require__("5f1b");
var regexpExec = __webpack_require__("520a");
var fails = __webpack_require__("79e5");
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__("214f")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),

/***/ "294c":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "2aba":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var hide = __webpack_require__("32e9");
var has = __webpack_require__("69a8");
var SRC = __webpack_require__("ca5a")('src');
var $toString = __webpack_require__("fa5b");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__("8378").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "2aeb":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("cb7c");
var dPs = __webpack_require__("1495");
var enumBugKeys = __webpack_require__("e11e");
var IE_PROTO = __webpack_require__("613b")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("230e")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("fab2").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "2b0e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.6.11
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (false) { var repeat, classify, classifyRE, hasConsole; }

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if (false) {}
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (false) {}
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (false
  ) {}
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     false && false;
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (false
  ) {}
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     false && false;
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (false) {}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       false && false;

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     false && false;
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (false) {}
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "production" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (false) {}
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (false) {}
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (false) {}
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (false) {}

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {}
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    false
  ) {}
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {}
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType);
  // check if we need to specify expected value
  if (expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

function isExplicable (value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (false) {}
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (false) { var getHandler, hasHandler, isBuiltInModifier, hasProxy, warnReservedPrefix, warnNonPresent, allowedGlobals; }

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

var mark;
var measure;

if (false) { var perf; }

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       false && false;
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (false) { var keyInLowerCase; }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (false) {} else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (false) {}
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    return res && (
      res.length === 0 ||
      (res.length === 1 && res[0].isComment) // #9658
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (false) {}
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       false && false;
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       false && false;
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (false) {}
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (false) {}
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (false) {}
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     false && false;
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (false
  ) {}
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (false) {}
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (false) {} else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (false) {} else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {}
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       false && false;
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 false
                  ? (undefined)
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (false) { var lowerCaseEvent; }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (false) {}
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {} else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (false) {}

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (false) {}
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (false) {}
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {}
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if (false) {}
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  false
    ? undefined
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       false && false;
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (false) { var hyphenatedKey; } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     false && false;
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (false) {}
    if (props && hasOwn(props, key)) {
       false && false;
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (false) {}

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (false) {}
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (false) {}
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (false) {}
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (false) {}
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {}

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (false) {} else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {}

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if (false
  ) {}
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (false) {}

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (false) {}
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */



function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (false) {}
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.11';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
       false && false;
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (false) {}

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {}
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (false) {}
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (false) {}

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (false) {}
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (false) {}
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (false
              ) {}
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (false
              ) {}
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (false) {}
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

/*  */

/*  */

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecesarry `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (false) {}

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (false) {}

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
     false && false;
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (false) {}

    var mode = this.mode;

    // warn invalid mode
    if (false
    ) {}

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (false) { var name, opts; }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        false
      ) {}
    }
    if (false
    ) {}
  }, 0);
}

/*  */

/* harmony default export */ __webpack_exports__["a"] = (Vue);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba"), __webpack_require__("5118").setImmediate))

/***/ }),

/***/ "2b4c":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("5537")('wks');
var uid = __webpack_require__("ca5a");
var Symbol = __webpack_require__("7726").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "2b8e":
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "2d00":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "2d95":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "2fdb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__("5ca1");
var context = __webpack_require__("d2c8");
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__("5147")(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "30f1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("b8e3");
var $export = __webpack_require__("63b6");
var redefine = __webpack_require__("9138");
var hide = __webpack_require__("35e8");
var Iterators = __webpack_require__("481b");
var $iterCreate = __webpack_require__("8f60");
var setToStringTag = __webpack_require__("45f2");
var getPrototypeOf = __webpack_require__("53e2");
var ITERATOR = __webpack_require__("5168")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "31f4":
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "32e9":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("86cc");
var createDesc = __webpack_require__("4630");
module.exports = __webpack_require__("9e1e") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "32fc":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("e53d").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "335c":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("6b4c");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "33a4":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("84f2");
var ITERATOR = __webpack_require__("2b4c")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "34ef":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("ec30")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "355d":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "35e8":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("d9f6");
var createDesc = __webpack_require__("aebd");
module.exports = __webpack_require__("8e60") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "36bd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__("4bf8");
var toAbsoluteIndex = __webpack_require__("77f1");
var toLength = __webpack_require__("9def");
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "36c3":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("335c");
var defined = __webpack_require__("25eb");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "3702":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("481b");
var ITERATOR = __webpack_require__("5168")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "37c8":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("2b4c");


/***/ }),

/***/ "37d9":
/***/ (function(module, exports, __webpack_require__) {

var _Object$create = __webpack_require__("4aa6");

var setPrototypeOf = __webpack_require__("be37");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "3846":
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__("9e1e") && /./g.flags != 'g') __webpack_require__("86cc").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__("0bfb")
});


/***/ }),

/***/ "386b":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("5ca1");
var fails = __webpack_require__("79e5");
var defined = __webpack_require__("be13");
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),

/***/ "38fd":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("69a8");
var toObject = __webpack_require__("4bf8");
var IE_PROTO = __webpack_require__("613b")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "3a38":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "3a72":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var core = __webpack_require__("8378");
var LIBRARY = __webpack_require__("2d00");
var wksExt = __webpack_require__("37c8");
var defineProperty = __webpack_require__("86cc").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "3b2b":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var inheritIfRequired = __webpack_require__("5dbc");
var dP = __webpack_require__("86cc").f;
var gOPN = __webpack_require__("9093").f;
var isRegExp = __webpack_require__("aae3");
var $flags = __webpack_require__("0bfb");
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__("9e1e") && (!CORRECT_NEW || __webpack_require__("79e5")(function () {
  re2[__webpack_require__("2b4c")('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__("2aba")(global, 'RegExp', $RegExp);
}

__webpack_require__("7a56")('RegExp');


/***/ }),

/***/ "3d02":
/***/ (function(module, exports, __webpack_require__) {

var _Array$from = __webpack_require__("774e");

var _isIterable = __webpack_require__("c8bb");

var _Symbol = __webpack_require__("67bb");

function _iterableToArray(iter) {
  if (typeof _Symbol !== "undefined" && _isIterable(Object(iter))) return _Array$from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "40c3":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("6b4c");
var TAG = __webpack_require__("5168")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "40df":
/***/ (function(module, exports, __webpack_require__) {

var _Array$from = __webpack_require__("774e");

var arrayLikeToArray = __webpack_require__("1e85");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return _Array$from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "41a0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("2aeb");
var descriptor = __webpack_require__("4630");
var setToStringTag = __webpack_require__("7f20");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("32e9")(IteratorPrototype, __webpack_require__("2b4c")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "454f":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("46a7");
var $Object = __webpack_require__("584a").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "456d":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__("4bf8");
var $keys = __webpack_require__("0d58");

__webpack_require__("5eda")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "4588":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "45f2":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("d9f6").f;
var has = __webpack_require__("07e3");
var TAG = __webpack_require__("5168")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "4630":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "46a7":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("63b6");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__("8e60"), 'Object', { defineProperty: __webpack_require__("d9f6").f });


/***/ }),

/***/ "47ee":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("c3a1");
var gOPS = __webpack_require__("9aa9");
var pIE = __webpack_require__("355d");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "481b":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "48c0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__("386b")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),

/***/ "4917":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__("cb7c");
var toLength = __webpack_require__("9def");
var advanceStringIndex = __webpack_require__("0390");
var regExpExec = __webpack_require__("5f1b");

// @@match logic
__webpack_require__("214f")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "4a59":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("9b43");
var call = __webpack_require__("1fa8");
var isArrayIter = __webpack_require__("33a4");
var anObject = __webpack_require__("cb7c");
var toLength = __webpack_require__("9def");
var getIterFn = __webpack_require__("27ee");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "4aa6":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("dc62");

/***/ }),

/***/ "4bf8":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("be13");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "4d16":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("25b0");

/***/ }),

/***/ "4db1":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__("7c64");

var iterableToArray = __webpack_require__("3d02");

var unsupportedIterableToArray = __webpack_require__("40df");

var nonIterableSpread = __webpack_require__("d8f0");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "4ee1":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("5168")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "4f7f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__("c26b");
var validate = __webpack_require__("b39a");
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__("e0b8")(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),

/***/ "50ed":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "5118":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("6017");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "5147":
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__("2b4c")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "5168":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("dbdb")('wks');
var uid = __webpack_require__("62a0");
var Symbol = __webpack_require__("e53d").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "520a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__("0bfb");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "52a7":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "53e2":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("07e3");
var toObject = __webpack_require__("241e");
var IE_PROTO = __webpack_require__("5559")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "549b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__("d864");
var $export = __webpack_require__("63b6");
var toObject = __webpack_require__("241e");
var call = __webpack_require__("b0dc");
var isArrayIter = __webpack_require__("3702");
var toLength = __webpack_require__("b447");
var createProperty = __webpack_require__("20fd");
var getIterFn = __webpack_require__("7cd6");

$export($export.S + $export.F * !__webpack_require__("4ee1")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "54a1":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("6c1c");
__webpack_require__("1654");
module.exports = __webpack_require__("95d5");


/***/ }),

/***/ "551c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("2d00");
var global = __webpack_require__("7726");
var ctx = __webpack_require__("9b43");
var classof = __webpack_require__("23c6");
var $export = __webpack_require__("5ca1");
var isObject = __webpack_require__("d3f4");
var aFunction = __webpack_require__("d8e8");
var anInstance = __webpack_require__("f605");
var forOf = __webpack_require__("4a59");
var speciesConstructor = __webpack_require__("ebd6");
var task = __webpack_require__("1991").set;
var microtask = __webpack_require__("8079")();
var newPromiseCapabilityModule = __webpack_require__("a5b8");
var perform = __webpack_require__("9c80");
var userAgent = __webpack_require__("a25f");
var promiseResolve = __webpack_require__("bcaa");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__("2b4c")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__("dcbc")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__("7f20")($Promise, PROMISE);
__webpack_require__("7a56")(PROMISE);
Wrapper = __webpack_require__("8378")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__("5cc5")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "5537":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("8378");
var global = __webpack_require__("7726");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("2d00") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "5559":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("dbdb")('keys');
var uid = __webpack_require__("62a0");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "584a":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "59a1":
/***/ (function(module, exports, __webpack_require__) {

var _Object$defineProperty = __webpack_require__("85f2");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;

    _Object$defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "5b4e":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("36c3");
var toLength = __webpack_require__("b447");
var toAbsoluteIndex = __webpack_require__("0fc9");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "5ca1":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var core = __webpack_require__("8378");
var hide = __webpack_require__("32e9");
var redefine = __webpack_require__("2aba");
var ctx = __webpack_require__("9b43");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "5cc5":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("2b4c")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "5d58":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("d8d6");

/***/ }),

/***/ "5dbc":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
var setPrototypeOf = __webpack_require__("8b97").set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "5df3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("02f4")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("01f9")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "5eda":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("5ca1");
var core = __webpack_require__("8378");
var fails = __webpack_require__("79e5");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "5f1b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__("23c6");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "6017":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba"), __webpack_require__("f28c")))

/***/ }),

/***/ "613b":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("5537")('keys');
var uid = __webpack_require__("ca5a");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "626a":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("2d95");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "62a0":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "63b6":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("e53d");
var core = __webpack_require__("584a");
var ctx = __webpack_require__("d864");
var hide = __webpack_require__("35e8");
var has = __webpack_require__("07e3");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "6430":
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__("8993");

var assertThisInitialized = __webpack_require__("2b8e");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "6718":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("e53d");
var core = __webpack_require__("584a");
var LIBRARY = __webpack_require__("b8e3");
var wksExt = __webpack_require__("ccb9");
var defineProperty = __webpack_require__("d9f6").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "6762":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__("5ca1");
var $includes = __webpack_require__("c366")(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__("9c6c")('includes');


/***/ }),

/***/ "67ab":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("ca5a")('meta');
var isObject = __webpack_require__("d3f4");
var has = __webpack_require__("69a8");
var setDesc = __webpack_require__("86cc").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("79e5")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "67bb":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("f921");

/***/ }),

/***/ "6821":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("626a");
var defined = __webpack_require__("be13");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "69a8":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "69d3":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("6718")('asyncIterator');


/***/ }),

/***/ "69e5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ bridge_Bridge; });

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("8e6e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("8a81");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__("6b54");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.reflect.construct.js
var es6_reflect_construct = __webpack_require__("2397");

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/defineProperty.js
var defineProperty = __webpack_require__("c47a");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__("4db1");
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.promise.js
var es6_promise = __webpack_require__("551c");

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/classCallCheck.js
var classCallCheck = __webpack_require__("fc74");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/createClass.js
var createClass = __webpack_require__("59a1");
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/inherits.js
var inherits = __webpack_require__("37d9");
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__("6430");
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("ffe3");
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/typeof.js
var helpers_typeof = __webpack_require__("8993");
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("ac6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("cadf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("06db");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("456d");

// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __webpack_require__("faa1");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.link.js
var es6_string_link = __webpack_require__("b54a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.bold.js
var es6_string_bold = __webpack_require__("48c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.from.js
var es6_array_from = __webpack_require__("1c4c");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.uint8-array.js
var es6_typed_uint8_array = __webpack_require__("34ef");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.fixed.js
var es6_string_fixed = __webpack_require__("d263");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.fill.js
var es6_array_fill = __webpack_require__("6c7b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.match.js
var es6_regexp_match = __webpack_require__("4917");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.flags.js
var es6_regexp_flags = __webpack_require__("3846");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.constructor.js
var es6_regexp_constructor = __webpack_require__("3b2b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.set.js
var es6_set = __webpack_require__("4f7f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.iterator.js
var es6_string_iterator = __webpack_require__("5df3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.map.js
var es6_map = __webpack_require__("f400");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.find.js
var es6_array_find = __webpack_require__("7514");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.anchor.js
var es6_string_anchor = __webpack_require__("8449");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.find-index.js
var es6_array_find_index = __webpack_require__("20d6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.ends-with.js
var es6_string_ends_with = __webpack_require__("aef6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.constructor.js
var es6_number_constructor = __webpack_require__("c5f6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js
var es6_string_starts_with = __webpack_require__("f559");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.freeze.js
var es6_object_freeze = __webpack_require__("0d6d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __webpack_require__("6762");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js
var es6_string_includes = __webpack_require__("2fdb");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__("28a5");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.replace.js
var es6_regexp_replace = __webpack_require__("a481");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __webpack_require__("7f7f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __webpack_require__("f751");

// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("2b0e");

// CONCATENATED MODULE: ./node_modules/quasar/dist/quasar.esm.js

































/*!
 * Quasar Framework v1.11.3
 * (c) 2015-present Razvan Stoenescu
 * Released under the MIT License.
 */

var iosCorrection,
    version = "1.11.3",
    isSSR = "undefined" == typeof window,
    fromSSR = !1,
    onSSR = isSSR,
    iosEmulated = !1;

function getMatch(t, e) {
  var i = /(edge|edga|edgios)\/([\w.]+)/.exec(t) || /(opr)[\/]([\w.]+)/.exec(t) || /(vivaldi)[\/]([\w.]+)/.exec(t) || /(chrome|crios)[\/]([\w.]+)/.exec(t) || /(iemobile)[\/]([\w.]+)/.exec(t) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(t) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(t) || /(firefox|fxios)[\/]([\w.]+)/.exec(t) || /(webkit)[\/]([\w.]+)/.exec(t) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(t) || /(msie) ([\w.]+)/.exec(t) || t.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(t) || t.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(t) || [];
  return {
    browser: i[5] || i[3] || i[1] || "",
    version: i[2] || i[4] || "0",
    versionNumber: i[4] || i[2] || "0",
    platform: e[0] || ""
  };
}

function getPlatformMatch(t) {
  return /(ipad)/.exec(t) || /(ipod)/.exec(t) || /(windows phone)/.exec(t) || /(iphone)/.exec(t) || /(kindle)/.exec(t) || /(silk)/.exec(t) || /(android)/.exec(t) || /(win)/.exec(t) || /(mac)/.exec(t) || /(linux)/.exec(t) || /(cros)/.exec(t) || /(playbook)/.exec(t) || /(bb)/.exec(t) || /(blackberry)/.exec(t) || [];
}

var hasTouch = !1 === isSSR && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);

function applyIosCorrection(t) {
  var e;
  iosCorrection = {
    is: Object.assign({}, t)
  }, delete t.mac, delete t.desktop;
  var i = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
  Object.assign(t, ((e = {
    mobile: !0,
    ios: !0,
    platform: i
  })[i] = !0, e));
}

function getPlatform(t) {
  var e = t.toLowerCase(),
      i = getMatch(e, getPlatformMatch(e)),
      s = {};
  i.browser && (s[i.browser] = !0, s.version = i.version, s.versionNumber = parseInt(i.versionNumber, 10)), i.platform && (s[i.platform] = !0);
  var n = s.android || s.ios || s.bb || s.blackberry || s.ipad || s.iphone || s.ipod || s.kindle || s.playbook || s.silk || s["windows phone"];
  return !0 === n || e.indexOf("mobile") > -1 ? (s.mobile = !0, s.edga || s.edgios ? (s.edge = !0, i.browser = "edge") : s.crios ? (s.chrome = !0, i.browser = "chrome") : s.fxios && (s.firefox = !0, i.browser = "firefox")) : s.desktop = !0, (s.ipod || s.ipad || s.iphone) && (s.ios = !0), s["windows phone"] && (s.winphone = !0, delete s["windows phone"]), (s.chrome || s.opr || s.safari || s.vivaldi || !0 === s.mobile && !0 !== s.ios && !0 !== n) && (s.webkit = !0), (s.rv || s.iemobile) && (i.browser = "ie", s.ie = !0), (s.safari && s.blackberry || s.bb) && (i.browser = "blackberry", s.blackberry = !0), s.safari && s.playbook && (i.browser = "playbook", s.playbook = !0), s.opr && (i.browser = "opera", s.opera = !0), s.safari && s.android && (i.browser = "android", s.android = !0), s.safari && s.kindle && (i.browser = "kindle", s.kindle = !0), s.safari && s.silk && (i.browser = "silk", s.silk = !0), s.vivaldi && (i.browser = "vivaldi", s.vivaldi = !0), s.name = i.browser, s.platform = i.platform, !1 === isSSR && (e.indexOf("electron") > -1 ? s.electron = !0 : document.location.href.indexOf("-extension://") > -1 ? s.bex = !0 : (void 0 !== window.Capacitor ? (s.capacitor = !0, s.nativeMobile = !0, s.nativeMobileWrapper = "capacitor") : void 0 === window._cordovaNative && void 0 === window.cordova || (s.cordova = !0, s.nativeMobile = !0, s.nativeMobileWrapper = "cordova"), !0 === hasTouch && !0 === s.mac && (!0 === s.desktop && !0 === s.safari || !0 === s.nativeMobile && !0 !== s.android && !0 !== s.ios && !0 !== s.ipad) && applyIosCorrection(s)), !0 === (fromSSR = void 0 === s.nativeMobile && void 0 === s.electron && null !== document.querySelector("[data-server-rendered]")) && (onSSR = !0)), s;
}

var userAgent = !0 !== isSSR ? navigator.userAgent || navigator.vendor || window.opera : "",
    ssrClient = {
  has: {
    touch: !1,
    webStorage: !1
  },
  within: {
    iframe: !1
  }
},
    client = !1 === isSSR ? {
  userAgent: userAgent,
  is: getPlatform(userAgent),
  has: {
    touch: hasTouch,
    webStorage: function () {
      try {
        if (window.localStorage) return !0;
      } catch (t) {}

      return !1;
    }()
  },
  within: {
    iframe: window.self !== window.top
  }
} : ssrClient,
    Platform = {
  install: function install(t, e) {
    var i = this;
    !0 === isSSR ? e.server.push(function (t, e) {
      t.platform = i.parseSSR(e.ssr);
    }) : !0 === fromSSR ? (Object.assign(this, client, iosCorrection, ssrClient), e.takeover.push(function (t) {
      onSSR = fromSSR = !1, Object.assign(t.platform, client), iosCorrection = void 0;
    }), vue_runtime_esm["a" /* default */].util.defineReactive(t, "platform", this)) : (Object.assign(this, client), t.platform = this);
  }
};
!0 === isSSR ? Platform.parseSSR = function (t) {
  var e = t.req.headers["user-agent"] || t.req.headers["User-Agent"] || "";
  return Object.assign({}, client, {
    userAgent: e,
    is: getPlatform(e)
  });
} : iosEmulated = !0 === client.is.ios && -1 === window.navigator.vendor.toLowerCase().indexOf("apple");
var listenOpts = {
  hasPassive: !1,
  passiveCapture: !0,
  notPassiveCapture: !0
};

try {
  var opts = Object.defineProperty({}, "passive", {
    get: function get() {
      Object.assign(listenOpts, {
        hasPassive: !0,
        passive: {
          passive: !0
        },
        notPassive: {
          passive: !1
        },
        passiveCapture: {
          passive: !0,
          capture: !0
        },
        notPassiveCapture: {
          passive: !1,
          capture: !0
        }
      });
    }
  });
  window.addEventListener("qtest", null, opts), window.removeEventListener("qtest", null, opts);
} catch (t) {}

function noop() {}

function leftClick(t) {
  return 0 === t.button;
}

function middleClick(t) {
  return 1 === t.button;
}

function rightClick(t) {
  return 2 === t.button;
}

function position(t) {
  return t.touches && t.touches[0] ? t = t.touches[0] : t.changedTouches && t.changedTouches[0] ? t = t.changedTouches[0] : t.targetTouches && t.targetTouches[0] && (t = t.targetTouches[0]), {
    top: t.clientY,
    left: t.clientX
  };
}

function getEventPath(t) {
  if (t.path) return t.path;
  if (t.composedPath) return t.composedPath();

  for (var e = [], i = t.target; i;) {
    if (e.push(i), "HTML" === i.tagName) return e.push(document), e.push(window), e;
    i = i.parentElement;
  }
}

var LINE_HEIGHT = 40,
    PAGE_HEIGHT = 800;

function getMouseWheelDistance(t) {
  var e,
      i = t.deltaX,
      s = t.deltaY;

  if ((i || s) && t.deltaMode) {
    var n = 1 === t.deltaMode ? LINE_HEIGHT : PAGE_HEIGHT;
    i *= n, s *= n;
  }

  return t.shiftKey && !i && (s = (e = [i, s])[0], i = e[1]), {
    x: i,
    y: s
  };
}

function stop(t) {
  t.stopPropagation();
}

function prevent(t) {
  !1 !== t.cancelable && t.preventDefault();
}

function stopAndPrevent(t) {
  !1 !== t.cancelable && t.preventDefault(), t.stopPropagation();
}

function preventDraggable(t, e) {
  if (void 0 !== t && (!0 !== e || !0 !== t.__dragPrevented)) {
    var i = !0 === e ? function (t) {
      t.__dragPrevented = !0, t.addEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
    } : function (t) {
      delete t.__dragPrevented, t.removeEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
    };
    t.querySelectorAll("a, img").forEach(i);
  }
}

function create(t, e) {
  void 0 === e && (e = {});
  var i = e.bubbles;
  void 0 === i && (i = !1);
  var s = e.cancelable;
  void 0 === s && (s = !1);

  try {
    return new Event(t, {
      bubbles: i,
      cancelable: s
    });
  } catch (e) {
    var n = document.createEvent("Event");
    return n.initEvent(t, i, s), n;
  }
}

var quasar_esm_event = {
  listenOpts: listenOpts,
  leftClick: leftClick,
  middleClick: middleClick,
  rightClick: rightClick,
  position: position,
  getEventPath: getEventPath,
  getMouseWheelDistance: getMouseWheelDistance,
  stop: stop,
  prevent: prevent,
  stopAndPrevent: stopAndPrevent,
  preventDraggable: preventDraggable,
  create: create
};

function debounce(t, e, i) {
  var s;

  function n() {
    var n = this,
        o = arguments;
    clearTimeout(s), !0 === i && void 0 === s && t.apply(this, o), s = setTimeout(function () {
      s = void 0, !0 !== i && t.apply(n, o);
    }, e);
  }

  return void 0 === e && (e = 250), n.cancel = function () {
    clearTimeout(s);
  }, n;
}

var SIZE_LIST = ["sm", "md", "lg", "xl"],
    passive = listenOpts.passive,
    Screen = {
  width: 0,
  height: 0,
  name: "xs",
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: !0,
    md: !0,
    lg: !0,
    xl: !0
  },
  gt: {
    xs: !1,
    sm: !1,
    md: !1,
    lg: !1
  },
  xs: !0,
  sm: !1,
  md: !1,
  lg: !1,
  xl: !1,
  setSizes: noop,
  setDebounce: noop,
  install: function install(t, e, i) {
    var s = this;

    if (!0 !== isSSR) {
      var n,
          o = void 0 !== i.screen && !0 === i.screen.bodyClasses,
          r = function r(t) {
        var e = window.innerWidth,
            i = window.innerHeight;
        if (i !== s.height && (s.height = i), e !== s.width) s.width = e;else if (!0 !== t) return;
        var n = s.sizes;
        s.gt.xs = e >= n.sm, s.gt.sm = e >= n.md, s.gt.md = e >= n.lg, s.gt.lg = e >= n.xl, s.lt.sm = e < n.sm, s.lt.md = e < n.md, s.lt.lg = e < n.lg, s.lt.xl = e < n.xl, s.xs = s.lt.sm, s.sm = !0 === s.gt.xs && !0 === s.lt.md, s.md = !0 === s.gt.sm && !0 === s.lt.lg, s.lg = !0 === s.gt.md && !0 === s.lt.xl, s.xl = s.gt.lg, (n = (!0 === s.xs ? "xs" : !0 === s.sm && "sm") || !0 === s.md && "md" || !0 === s.lg && "lg" || "xl") !== s.name && (!0 === o && (document.body.classList.remove("screen--" + s.name), document.body.classList.add("screen--" + n)), s.name = n);
      },
          a = {},
          l = 16;

      this.setSizes = function (t) {
        SIZE_LIST.forEach(function (e) {
          void 0 !== t[e] && (a[e] = t[e]);
        });
      }, this.setDebounce = function (t) {
        l = t;
      };

      var c = function c() {
        var t = getComputedStyle(document.body),
            e = void 0 !== window.visualViewport ? window.visualViewport : window;
        t.getPropertyValue("--q-size-sm") && SIZE_LIST.forEach(function (e) {
          s.sizes[e] = parseInt(t.getPropertyValue("--q-size-" + e), 10);
        }), s.setSizes = function (t) {
          SIZE_LIST.forEach(function (e) {
            t[e] && (s.sizes[e] = t[e]);
          }), r(!0);
        }, s.setDebounce = function (t) {
          void 0 !== n && e.removeEventListener("resize", n, passive), n = t > 0 ? debounce(r, t) : r, e.addEventListener("resize", n, passive);
        }, s.setDebounce(l), Object.keys(a).length > 0 ? (s.setSizes(a), a = void 0) : r(), !0 === o && "xs" === s.name && document.body.classList.add("screen--xs");
      };

      !0 === fromSSR ? e.takeover.push(c) : c(), vue_runtime_esm["a" /* default */].util.defineReactive(t, "screen", this);
    } else t.screen = this;
  }
},
    Dark = {
  isActive: !1,
  mode: !1,
  install: function install(t, e, i) {
    var s = this,
        n = i.dark;
    if (this.isActive = !0 === n, !0 === isSSR) return e.server.push(function (t, e) {
      t.dark = {
        isActive: !1,
        mode: !1,
        set: function set(i) {
          e.ssr.Q_BODY_CLASSES = e.ssr.Q_BODY_CLASSES.replace(" body--light", "").replace(" body--dark", "") + " body--" + (!0 === i ? "dark" : "light"), t.dark.isActive = !0 === i, t.dark.mode = i;
        },
        toggle: function toggle() {
          t.dark.set(!1 === t.dark.isActive);
        }
      }, t.dark.set(n);
    }), void (this.set = noop);
    var o = void 0 !== n && n;

    if (!0 === fromSSR) {
      var r = function r(t) {
        s.__fromSSR = t;
      },
          a = this.set;

      this.set = r, r(o), e.takeover.push(function () {
        s.set = a, s.set(s.__fromSSR);
      });
    } else this.set(o);

    vue_runtime_esm["a" /* default */].util.defineReactive(this, "isActive", this.isActive), vue_runtime_esm["a" /* default */].util.defineReactive(t, "dark", this);
  },
  set: function set(t) {
    var e = this;
    this.mode = t, "auto" === t ? (void 0 === this.__media && (this.__media = window.matchMedia("(prefers-color-scheme: dark)"), this.__updateMedia = function () {
      e.set("auto");
    }, this.__media.addListener(this.__updateMedia)), t = this.__media.matches) : void 0 !== this.__media && (this.__media.removeListener(this.__updateMedia), this.__media = void 0), this.isActive = !0 === t, document.body.classList.remove("body--" + (!0 === t ? "light" : "dark")), document.body.classList.add("body--" + (!0 === t ? "dark" : "light"));
  },
  toggle: function toggle() {
    Dark.set(!1 === Dark.isActive);
  },
  __media: void 0
},
    getTrue = function getTrue() {
  return !0;
},
    History = {
  __history: [],
  add: noop,
  remove: noop,
  install: function install(t) {
    var e = this;

    if (!0 !== isSSR) {
      var i = client.is,
          s = i.cordova,
          n = i.capacitor;

      if (!0 === s || !0 === n) {
        this.add = function (t) {
          void 0 === t.condition && (t.condition = getTrue), e.__history.push(t);
        }, this.remove = function (t) {
          var i = e.__history.indexOf(t);

          i >= 0 && e.__history.splice(i, 1);
        };

        var o = function o() {
          if (e.__history.length) {
            var t = e.__history[e.__history.length - 1];
            !0 === t.condition() && (e.__history.pop(), t.handler());
          } else a && "#/" === window.location.hash ? navigator.app.exitApp() : window.history.back();
        },
            r = !0 === s ? "cordova" : "capacitor",
            a = void 0 === t[r] || !1 !== t[r].backButtonExit;

        !0 === s ? document.addEventListener("deviceready", function () {
          document.addEventListener("backbutton", o, !1);
        }) : window.Capacitor.Plugins.App.addListener("backButton", o);
      }
    }
  }
},
    langEn = {
  isoName: "en-us",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    format24h: !1
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: function selectedRecords(t) {
      return 1 === t ? "1 record selected." : (0 === t ? "No" : t) + " records selected.";
    },
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: function pagination(t, e, i) {
      return t + "-" + e + " of " + i;
    },
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};

function getLocale() {
  if (!0 !== isSSR) {
    var t = navigator.language || navigator.languages[0] || navigator.browserLanguage || navigator.userLanguage || navigator.systemLanguage;
    return t ? t.toLowerCase() : void 0;
  }
}

var lang = {
  getLocale: getLocale,
  install: function install(t, e, i) {
    var s = this,
        n = i || langEn;
    this.set = function (e, i) {
      var n = Object.assign({}, e, {
        rtl: !0 === e.rtl,
        getLocale: getLocale
      });

      if (!0 === isSSR) {
        if (void 0 === i) return void console.error("SSR ERROR: second param required: Quasar.lang.set(lang, ssrContext)");
        var o = !0 === n.rtl ? "rtl" : "ltr",
            r = "lang=" + n.isoName + " dir=" + o;
        n.set = i.$q.lang.set, i.Q_HTML_ATTRS = void 0 !== i.Q_PREV_LANG ? i.Q_HTML_ATTRS.replace(i.Q_PREV_LANG, r) : r, i.Q_PREV_LANG = r, i.$q.lang = n;
      } else {
        if (!1 === fromSSR) {
          var a = document.documentElement;
          a.setAttribute("dir", !0 === n.rtl ? "rtl" : "ltr"), a.setAttribute("lang", n.isoName);
        }

        n.set = s.set, t.lang = s.props = n, s.isoName = n.isoName, s.nativeName = n.nativeName;
      }
    }, !0 === isSSR ? (e.server.push(function (t, e) {
      t.lang = {}, t.lang.set = function (t) {
        s.set(t, e.ssr);
      }, t.lang.set(n);
    }), this.isoName = n.isoName, this.nativeName = n.nativeName, this.props = n) : (vue_runtime_esm["a" /* default */].util.defineReactive(t, "lang", {}), this.set(n));
  }
},
    reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;

function rgbToHex(t) {
  var e = t.r,
      i = t.g,
      s = t.b,
      n = t.a,
      o = void 0 !== n;
  if (e = Math.round(e), i = Math.round(i), s = Math.round(s), e > 255 || i > 255 || s > 255 || o && n > 100) throw new TypeError("Expected 3 numbers below 256 (and optionally one below 100)");
  return n = o ? (256 | Math.round(255 * n / 100)).toString(16).slice(1) : "", "#" + (s | i << 8 | e << 16 | 1 << 24).toString(16).slice(1) + n;
}

function rgbToString(t) {
  var e = t.r,
      i = t.g,
      s = t.b,
      n = t.a;
  return "rgb" + (void 0 !== n ? "a" : "") + "(" + e + "," + i + "," + s + (void 0 !== n ? "," + n / 100 : "") + ")";
}

function hexToRgb(t) {
  if ("string" != typeof t) throw new TypeError("Expected a string");
  3 === (t = t.replace(/^#/, "")).length ? t = t[0] + t[0] + t[1] + t[1] + t[2] + t[2] : 4 === t.length && (t = t[0] + t[0] + t[1] + t[1] + t[2] + t[2] + t[3] + t[3]);
  var e = parseInt(t, 16);
  return t.length > 6 ? {
    r: e >> 24 & 255,
    g: e >> 16 & 255,
    b: e >> 8 & 255,
    a: Math.round((255 & e) / 2.55)
  } : {
    r: e >> 16,
    g: e >> 8 & 255,
    b: 255 & e
  };
}

function hsvToRgb(t) {
  var e,
      i,
      s,
      n,
      o,
      r,
      a,
      l,
      c = t.h,
      u = t.s,
      h = t.v,
      d = t.a;

  switch (r = (h /= 100) * (1 - (u /= 100)), a = h * (1 - (o = 6 * (c /= 360) - (n = Math.floor(6 * c))) * u), l = h * (1 - (1 - o) * u), n % 6) {
    case 0:
      e = h, i = l, s = r;
      break;

    case 1:
      e = a, i = h, s = r;
      break;

    case 2:
      e = r, i = h, s = l;
      break;

    case 3:
      e = r, i = a, s = h;
      break;

    case 4:
      e = l, i = r, s = h;
      break;

    case 5:
      e = h, i = r, s = a;
  }

  return {
    r: Math.round(255 * e),
    g: Math.round(255 * i),
    b: Math.round(255 * s),
    a: d
  };
}

function rgbToHsv(t) {
  var e,
      i = t.r,
      s = t.g,
      n = t.b,
      o = t.a,
      r = Math.max(i, s, n),
      a = Math.min(i, s, n),
      l = r - a,
      c = 0 === r ? 0 : l / r,
      u = r / 255;

  switch (r) {
    case a:
      e = 0;
      break;

    case i:
      e = s - n + l * (s < n ? 6 : 0), e /= 6 * l;
      break;

    case s:
      e = n - i + 2 * l, e /= 6 * l;
      break;

    case n:
      e = i - s + 4 * l, e /= 6 * l;
  }

  return {
    h: Math.round(360 * e),
    s: Math.round(100 * c),
    v: Math.round(100 * u),
    a: o
  };
}

function textToRgb(t) {
  if ("string" != typeof t) throw new TypeError("Expected a string");
  var e = t.replace(/ /g, ""),
      i = reRGBA.exec(e);
  if (null === i) return hexToRgb(e);
  var s = {
    r: Math.min(255, parseInt(i[2], 10)),
    g: Math.min(255, parseInt(i[3], 10)),
    b: Math.min(255, parseInt(i[4], 10))
  };

  if (i[1]) {
    var n = parseFloat(i[5]);
    s.a = 100 * Math.min(1, !0 === isNaN(n) ? 1 : n);
  }

  return s;
}

function lighten(t, e) {
  if ("string" != typeof t) throw new TypeError("Expected a string as color");
  if ("number" != typeof e) throw new TypeError("Expected a numeric percent");
  var i = textToRgb(t),
      s = e < 0 ? 0 : 255,
      n = Math.abs(e) / 100,
      o = i.r,
      r = i.g,
      a = i.b;
  return "#" + (16777216 + 65536 * (Math.round((s - o) * n) + o) + 256 * (Math.round((s - r) * n) + r) + (Math.round((s - a) * n) + a)).toString(16).slice(1);
}

function luminosity(t) {
  if ("string" != typeof t && (!t || void 0 === t.r)) throw new TypeError("Expected a string or a {r, g, b} object as color");
  var e = "string" == typeof t ? textToRgb(t) : t,
      i = e.r / 255,
      s = e.g / 255,
      n = e.b / 255;
  return .2126 * (i <= .03928 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)) + .7152 * (s <= .03928 ? s / 12.92 : Math.pow((s + .055) / 1.055, 2.4)) + .0722 * (n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4));
}

function brightness(t) {
  if ("string" != typeof t && (!t || void 0 === t.r)) throw new TypeError("Expected a string or a {r, g, b} object as color");
  var e = "string" == typeof t ? textToRgb(t) : t;
  return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3;
}

function blend(t, e) {
  if ("string" != typeof t && (!t || void 0 === t.r)) throw new TypeError("Expected a string or a {r, g, b[, a]} object as fgColor");
  if ("string" != typeof e && (!e || void 0 === e.r)) throw new TypeError("Expected a string or a {r, g, b[, a]} object as bgColor");
  var i = "string" == typeof t ? textToRgb(t) : t,
      s = i.r / 255,
      n = i.g / 255,
      o = i.b / 255,
      r = void 0 !== i.a ? i.a / 100 : 1,
      a = "string" == typeof e ? textToRgb(e) : e,
      l = a.r / 255,
      c = a.g / 255,
      u = a.b / 255,
      h = void 0 !== a.a ? a.a / 100 : 1,
      d = r + h * (1 - r),
      p = {
    r: Math.round((s * r + l * h * (1 - r)) / d * 255),
    g: Math.round((n * r + c * h * (1 - r)) / d * 255),
    b: Math.round((o * r + u * h * (1 - r)) / d * 255),
    a: Math.round(100 * d)
  };
  return "string" == typeof t ? rgbToHex(p) : p;
}

function changeAlpha(t, e) {
  if ("string" != typeof t) throw new TypeError("Expected a string as color");
  if (void 0 === e || e < -1 || e > 1) throw new TypeError("Expected offset to be between -1 and 1");
  var i = textToRgb(t),
      s = i.r,
      n = i.g,
      o = i.b,
      r = i.a,
      a = void 0 !== r ? r / 100 : 0;
  return rgbToHex({
    r: s,
    g: n,
    b: o,
    a: Math.round(100 * Math.min(1, Math.max(0, a + e)))
  });
}

function setBrand(t, e, i) {
  if (void 0 === i && (i = document.body), "string" != typeof t) throw new TypeError("Expected a string as color");
  if ("string" != typeof e) throw new TypeError("Expected a string as value");
  if (!(i instanceof Element)) throw new TypeError("Expected a DOM element");
  i.style.setProperty("--q-color-" + t, e);
}

function getBrand(t, e) {
  if (void 0 === e && (e = document.body), "string" != typeof t) throw new TypeError("Expected a string as color");
  if (!(e instanceof Element)) throw new TypeError("Expected a DOM element");
  return getComputedStyle(e).getPropertyValue("--q-color-" + t).trim() || null;
}

function getPaletteColor(t) {
  if ("string" != typeof t) throw new TypeError("Expected a string as color");
  var e = document.createElement("div");
  e.className = "text-" + t + " invisible fixed no-pointer-events", document.body.appendChild(e);
  var i = getComputedStyle(e).getPropertyValue("color");
  return e.remove(), rgbToHex(textToRgb(i));
}

var colors = {
  rgbToHex: rgbToHex,
  hexToRgb: hexToRgb,
  hsvToRgb: hsvToRgb,
  rgbToHsv: rgbToHsv,
  textToRgb: textToRgb,
  lighten: lighten,
  luminosity: luminosity,
  brightness: brightness,
  blend: blend,
  changeAlpha: changeAlpha,
  setBrand: setBrand,
  getBrand: getBrand,
  getPaletteColor: getPaletteColor
},
    lastKeyCompositionStatus = !1;

function onKeyDownComposition(t) {
  lastKeyCompositionStatus = !0 === t.isComposing;
}

function shouldIgnoreKey(t) {
  return !0 === lastKeyCompositionStatus || t !== Object(t) || !0 === t.isComposing || !0 === t.qKeyEvent;
}

function isKeyCode(t, e) {
  return !0 !== shouldIgnoreKey(t) && [].concat(e).includes(t.keyCode);
}

function getMobilePlatform(t) {
  return !0 === t.ios ? "ios" : !0 === t.android ? "android" : void 0;
}

function getBodyClasses(t, e) {
  var i = t.is,
      s = t.has,
      n = t.within,
      o = [!0 === i.desktop ? "desktop" : "mobile", (!1 === s.touch ? "no-" : "") + "touch"];

  if (!0 === i.mobile) {
    var r = getMobilePlatform(i);
    void 0 !== r && o.push("platform-" + r);
  }

  if (!0 === i.nativeMobile) {
    var a = i.nativeMobileWrapper;
    o.push(a), o.push("native-mobile"), !0 !== i.ios || void 0 !== e[a] && !1 === e[a].iosStatusBarPadding || o.push("q-ios-padding");
  } else !0 === i.electron ? o.push("electron") : !0 === i.bex && o.push("bex");

  return !0 === n.iframe && o.push("within-iframe"), o;
}

function clientUpdate() {
  var t = document.body.className,
      e = t;
  void 0 !== iosCorrection && (e = e.replace("desktop", "platform-ios mobile")), !0 === client.has.touch && (e = e.replace("no-touch", "touch")), !0 === client.within.iframe && (e += " within-iframe"), t !== e && (document.body.className = e);
}

function setColors(t) {
  for (var e in t) {
    setBrand(e, t[e]);
  }
}

var Body = {
  install: function install(t, e) {
    if (!0 !== isSSR) {
      if (!0 === fromSSR) clientUpdate();else {
        var i = getBodyClasses(client, e);
        !0 === client.is.ie && 11 === client.is.versionNumber ? i.forEach(function (t) {
          return document.body.classList.add(t);
        }) : document.body.classList.add.apply(document.body.classList, i);
      }
      void 0 !== e.brand && setColors(e.brand), !0 === client.is.ios && document.body.addEventListener("touchstart", noop), window.addEventListener("keydown", onKeyDownComposition, !0);
    } else t.server.push(function (t, i) {
      var s = getBodyClasses(t.platform, e),
          n = i.ssr.setBodyClasses;
      void 0 !== e.screen && !0 === e.screen.bodyClass && s.push("screen--xs"), "function" == typeof n ? n(s) : i.ssr.Q_BODY_CLASSES = s.join(" ");
    });
  }
},
    materialIcons = {
  name: "material-icons",
  type: {
    positive: "check_circle",
    negative: "warning",
    info: "info",
    warning: "priority_high"
  },
  arrow: {
    up: "arrow_upward",
    right: "arrow_forward",
    down: "arrow_downward",
    left: "arrow_back",
    dropdown: "arrow_drop_down"
  },
  chevron: {
    left: "chevron_left",
    right: "chevron_right"
  },
  colorPicker: {
    spectrum: "gradient",
    tune: "tune",
    palette: "style"
  },
  pullToRefresh: {
    icon: "refresh"
  },
  carousel: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down",
    navigationIcon: "lens"
  },
  chip: {
    remove: "cancel",
    selected: "check"
  },
  datetime: {
    arrowLeft: "chevron_left",
    arrowRight: "chevron_right",
    now: "access_time",
    today: "today"
  },
  editor: {
    bold: "format_bold",
    italic: "format_italic",
    strikethrough: "strikethrough_s",
    underline: "format_underlined",
    unorderedList: "format_list_bulleted",
    orderedList: "format_list_numbered",
    subscript: "vertical_align_bottom",
    superscript: "vertical_align_top",
    hyperlink: "link",
    toggleFullscreen: "fullscreen",
    quote: "format_quote",
    left: "format_align_left",
    center: "format_align_center",
    right: "format_align_right",
    justify: "format_align_justify",
    print: "print",
    outdent: "format_indent_decrease",
    indent: "format_indent_increase",
    removeFormat: "format_clear",
    formatting: "text_format",
    fontSize: "format_size",
    align: "format_align_left",
    hr: "remove",
    undo: "undo",
    redo: "redo",
    heading: "format_size",
    code: "code",
    size: "format_size",
    font: "font_download",
    viewSource: "code"
  },
  expansionItem: {
    icon: "keyboard_arrow_down",
    denseIcon: "arrow_drop_down"
  },
  fab: {
    icon: "add",
    activeIcon: "close"
  },
  field: {
    clear: "cancel",
    error: "error"
  },
  pagination: {
    first: "first_page",
    prev: "keyboard_arrow_left",
    next: "keyboard_arrow_right",
    last: "last_page"
  },
  rating: {
    icon: "grade"
  },
  stepper: {
    done: "check",
    active: "edit",
    error: "warning"
  },
  tabs: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down"
  },
  table: {
    arrowUp: "arrow_upward",
    warning: "warning",
    prevPage: "chevron_left",
    nextPage: "chevron_right"
  },
  tree: {
    icon: "play_arrow"
  },
  uploader: {
    done: "done",
    clear: "clear",
    add: "add_box",
    upload: "cloud_upload",
    removeQueue: "clear_all",
    removeUploaded: "done_all"
  }
},
    iconSet = {
  install: function install(t, e, i) {
    var s = this,
        n = i || materialIcons;
    this.set = function (e, i) {
      var n = Object.assign({}, e);

      if (!0 === isSSR) {
        if (void 0 === i) return void console.error("SSR ERROR: second param required: Quasar.iconSet.set(iconSet, ssrContext)");
        n.set = i.$q.iconSet.set, i.$q.iconSet = n;
      } else n.set = s.set, t.iconSet = n;
    }, !0 === isSSR ? e.server.push(function (t, e) {
      t.iconSet = {}, t.iconSet.set = function (t) {
        s.set(t, e.ssr);
      }, t.iconSet.set(n);
    }) : (vue_runtime_esm["a" /* default */].util.defineReactive(t, "iconMapFn", void 0), vue_runtime_esm["a" /* default */].util.defineReactive(t, "iconSet", {}), this.set(n));
  }
},
    autoInstalled = [Platform, Screen, Dark],
    queues = {
  server: [],
  takeover: []
},
    $q = {
  version: version,
  config: {}
};

function quasar_esm_install(t, e) {
  if (void 0 === e && (e = {}), !0 !== this.__qInstalled) {
    this.__qInstalled = !0;
    var i = $q.config = Object.freeze(e.config || {});

    if (Platform.install($q, queues), Body.install(queues, i), Dark.install($q, queues, i), Screen.install($q, queues, i), History.install(i), lang.install($q, queues, e.lang), iconSet.install($q, queues, e.iconSet), !0 === isSSR ? t.mixin({
      beforeCreate: function beforeCreate() {
        this.$q = this.$root.$options.$q;
      }
    }) : t.prototype.$q = $q, e.components && Object.keys(e.components).forEach(function (i) {
      var s = e.components[i];
      "function" == typeof s && t.component(s.options.name, s);
    }), e.directives && Object.keys(e.directives).forEach(function (i) {
      var s = e.directives[i];
      void 0 !== s.name && void 0 !== s.unbind && t.directive(s.name, s);
    }), e.plugins) {
      var s = {
        $q: $q,
        queues: queues,
        cfg: i
      };
      Object.keys(e.plugins).forEach(function (t) {
        var i = e.plugins[t];
        "function" == typeof i.install && !1 === autoInstalled.includes(i) && i.install(s);
      });
    }
  }
}

var mixin = {
  mounted: function mounted() {
    var t = this;
    queues.takeover.forEach(function (e) {
      e(t.$q);
    });
  }
};

function ssrUpdate(t) {
  if (t.ssr) {
    var e = Object.assign({}, $q, {
      ssrContext: t.ssr
    });
    Object.assign(t.ssr, {
      Q_HEAD_TAGS: "",
      Q_BODY_ATTRS: "",
      Q_BODY_TAGS: ""
    }), t.app.$q = t.ssr.$q = e, queues.server.forEach(function (i) {
      i(e, t);
    });
  } else {
    var i = t.app.mixins || [];
    !1 === i.includes(mixin) && (t.app.mixins = i.concat(mixin));
  }
}

var VuePlugin = {
  version: version,
  install: quasar_esm_install,
  lang: lang,
  iconSet: iconSet,
  ssrUpdate: ssrUpdate
},
    units = ["B", "KB", "MB", "GB", "TB", "PB"];

function humanStorageSize(t) {
  for (var e = 0; parseInt(t, 10) >= 1024 && e < units.length - 1;) {
    t /= 1024, ++e;
  }

  return "" + t.toFixed(1) + units[e];
}

function capitalize(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}

function between(t, e, i) {
  return i <= e ? e : Math.min(i, Math.max(e, t));
}

function normalizeToInterval(t, e, i) {
  if (i <= e) return e;
  var s = i - e + 1,
      n = e + (t - e) % s;
  return n < e && (n = s + n), 0 === n ? 0 : n;
}

function pad(t, e, i) {
  if (void 0 === e && (e = 2), void 0 === i && (i = "0"), void 0 === t || null === t) return t;
  var s = "" + t;
  return s.length >= e ? s : new Array(e - s.length + 1).join(i) + s;
}

var format = {
  humanStorageSize: humanStorageSize,
  capitalize: capitalize,
  between: between,
  normalizeToInterval: normalizeToInterval,
  pad: pad
},
    xhr = isSSR ? null : XMLHttpRequest,
    send = isSSR ? null : xhr.prototype.send,
    stackStart = [],
    stackStop = [],
    highjackCount = 0;

function translate(t) {
  var e = t.p,
      i = t.pos,
      s = t.active,
      n = t.horiz,
      o = t.reverse,
      r = t.dir,
      a = 1,
      l = 1;
  return n ? (o && (a = -1), "bottom" === i && (l = -1), {
    transform: "translate3d(" + a * (e - 100) + "%," + (s ? 0 : -200 * l) + "%,0)"
  }) : (o && (l = -1), "right" === i && (a = -1), {
    transform: "translate3d(" + (s ? 0 : r * a * -200) + "%," + l * (e - 100) + "%,0)"
  });
}

function inc(t, e) {
  return "number" != typeof e && (e = t < 25 ? 3 * Math.random() + 3 : t < 65 ? 3 * Math.random() : t < 85 ? 2 * Math.random() : t < 99 ? .6 : 0), between(t + e, 0, 100);
}

function highjackAjax(t, e) {
  function i() {
    stackStop.forEach(function (t) {
      t();
    });
  }

  stackStart.push(t), stackStop.push(e), ++highjackCount > 1 || (xhr.prototype.send = function () {
    stackStart.forEach(function (t) {
      t();
    }), this.addEventListener("loadend", i, !1), send.apply(this, arguments);
  });
}

function restoreAjax(t, e) {
  stackStart.splice(stackStart.indexOf(t), 1), stackStop.splice(stackStop.indexOf(e), 1), (highjackCount = Math.max(0, highjackCount - 1)) || (xhr.prototype.send = send);
}

var QAjaxBar = vue_runtime_esm["a" /* default */].extend({
  name: "QAjaxBar",
  props: {
    position: {
      type: String,
      default: "top",
      validator: function validator(t) {
        return ["top", "right", "bottom", "left"].includes(t);
      }
    },
    size: {
      type: String,
      default: "2px"
    },
    color: String,
    skipHijack: Boolean,
    reverse: Boolean
  },
  data: function data() {
    return {
      calls: 0,
      progress: 0,
      onScreen: !1,
      animate: !0
    };
  },
  computed: {
    classes: function classes() {
      return "q-loading-bar q-loading-bar--" + this.position + (void 0 !== this.color ? " bg-" + this.color : "") + (!0 === this.animate ? "" : " no-transition");
    },
    style: function style() {
      var t = this.onScreen,
          e = translate({
        p: this.progress,
        pos: this.position,
        active: t,
        horiz: this.horizontal,
        reverse: !0 === this.$q.lang.rtl && ["top", "bottom"].includes(this.position) ? !this.reverse : this.reverse,
        dir: !0 === this.$q.lang.rtl ? -1 : 1
      });
      return e[this.sizeProp] = this.size, e.opacity = t ? 1 : 0, e;
    },
    horizontal: function horizontal() {
      return "top" === this.position || "bottom" === this.position;
    },
    sizeProp: function sizeProp() {
      return this.horizontal ? "height" : "width";
    },
    attrs: function attrs() {
      return !0 === this.onScreen ? {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": this.progress
      } : {
        "aria-hidden": "true"
      };
    }
  },
  methods: {
    start: function start(t) {
      var e = this;
      void 0 === t && (t = 300);
      var i = this.speed;
      this.speed = Math.max(0, t) || 0, this.calls++, this.calls > 1 ? 0 === i && t > 0 ? this.__work() : i > 0 && t <= 0 && clearTimeout(this.timer) : (clearTimeout(this.timer), this.$emit("start"), this.progress = 0, !0 !== this.onScreen && (this.onScreen = !0, this.animate = !1, this.timer = setTimeout(function () {
        e.animate = !0, t > 0 && e.__work();
      }, 100)));
    },
    increment: function increment(t) {
      this.calls > 0 && (this.progress = inc(this.progress, t));
    },
    stop: function stop() {
      var t = this;

      if (this.calls = Math.max(0, this.calls - 1), !(this.calls > 0)) {
        clearTimeout(this.timer), this.$emit("stop");

        var e = function e() {
          t.animate = !0, t.progress = 100, t.timer = setTimeout(function () {
            t.onScreen = !1;
          }, 1e3);
        };

        0 === this.progress ? this.timer = setTimeout(e, 1) : e();
      }
    },
    __work: function __work() {
      var t = this;
      this.progress < 100 && (this.timer = setTimeout(function () {
        t.increment(), t.__work();
      }, this.speed));
    }
  },
  mounted: function mounted() {
    !0 !== this.skipHijack && (this.hijacked = !0, highjackAjax(this.start, this.stop));
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.timer), !0 === this.hijacked && restoreAjax(this.start, this.stop);
  },
  render: function render(t) {
    return t("div", {
      class: this.classes,
      style: this.style,
      attrs: this.attrs
    });
  }
}),
    sizes = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
};

function getSizeMixin(t) {
  return {
    props: {
      size: String
    },
    computed: {
      sizeStyle: function sizeStyle() {
        if (void 0 !== this.size) return {
          fontSize: this.size in t ? t[this.size] + "px" : this.size
        };
      }
    }
  };
}

var SizeMixin = getSizeMixin(sizes),
    TagMixin = {
  props: {
    tag: {
      type: String,
      default: "div"
    }
  }
};

function cache(t, e, i) {
  if (!0 === isSSR) return i;
  var s = "__qcache_" + e;
  return void 0 === t[s] ? t[s] = i : t[s];
}

function getPropCacheMixin(t, e) {
  var i;
  return {
    data: function data() {
      var t;
      return (t = {})[e] = {}, t;
    },
    watch: (i = {}, i[t] = {
      immediate: !0,
      handler: function handler(t, i) {
        var s = this[e];
        if (void 0 !== i) for (var n in i) {
          void 0 === t[n] && this.$delete(s, n);
        }

        for (var o in t) {
          s[o] !== t[o] && this.$set(s, o, t[o]);
        }
      }
    }, i)
  };
}

var ListenersMixin = getPropCacheMixin("$listeners", "qListeners");

function slot(t, e, i) {
  return void 0 !== t.$scopedSlots[e] ? t.$scopedSlots[e]() : i;
}

function uniqueSlot(t, e, i) {
  return void 0 !== t.$scopedSlots[e] ? t.$scopedSlots[e]().slice() : i;
}

function mergeSlot(t, e, i) {
  return void 0 !== e.$scopedSlots[i] ? t.concat(e.$scopedSlots[i]()) : t;
}

function mergeSlotSafely(t, e, i) {
  if (void 0 === e.$scopedSlots[i]) return t;
  var s = e.$scopedSlots[i]();
  return void 0 !== t ? t.concat(s) : s;
}

var QIcon = vue_runtime_esm["a" /* default */].extend({
  name: "QIcon",
  mixins: [ListenersMixin, SizeMixin, TagMixin],
  props: {
    tag: {
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-icon notranslate" + (!0 === this.left ? " on-left" : "") + (!0 === this.right ? " on-right" : "") + (void 0 !== this.color ? " text-" + this.color : "");
    },
    type: function type() {
      var t,
          e = this,
          i = this.name;
      if (!i) return {
        none: !0,
        cls: this.classes
      };

      if (void 0 !== this.$q.iconMapFn) {
        var s = this.$q.iconMapFn(i);

        if (void 0 !== s) {
          if (void 0 === s.icon) return {
            cls: s.cls + " " + this.classes,
            content: void 0 !== s.content ? s.content : " "
          };
          i = s.icon;
        }
      }

      if (!0 === i.startsWith("M")) {
        var n = i.split("|"),
            o = n[0],
            r = n[1];
        return {
          svg: !0,
          cls: this.classes,
          nodes: o.split("&&").map(function (t) {
            var i = t.split("@@"),
                s = i[0],
                n = i[1],
                o = i[2];
            return e.$createElement("path", {
              attrs: {
                d: s,
                transform: o
              },
              style: n
            });
          }),
          viewBox: void 0 !== r ? r : "0 0 24 24"
        };
      }

      if (!0 === i.startsWith("img:")) return {
        img: !0,
        cls: this.classes,
        src: i.substring(4)
      };
      var a = " ";
      return /^[l|f]a[s|r|l|b|d]{0,1} /.test(i) || !0 === i.startsWith("icon-") ? t = i : !0 === i.startsWith("bt-") ? t = "bt " + i : !0 === i.startsWith("eva-") ? t = "eva " + i : !0 === /^ion-(md|ios|logo)/.test(i) ? t = "ionicons " + i : !0 === i.startsWith("ion-") ? t = "ionicons ion-" + (!0 === this.$q.platform.is.ios ? "ios" : "md") + i.substr(3) : !0 === i.startsWith("mdi-") ? t = "mdi " + i : !0 === i.startsWith("iconfont ") ? t = "" + i : !0 === i.startsWith("ti-") ? t = "themify-icon " + i : (t = "material-icons", !0 === i.startsWith("o_") ? (i = i.substring(2), t += "-outlined") : !0 === i.startsWith("r_") ? (i = i.substring(2), t += "-round") : !0 === i.startsWith("s_") && (i = i.substring(2), t += "-sharp"), a = i), {
        cls: t + " " + this.classes,
        content: a
      };
    }
  },
  render: function render(t) {
    var e = {
      class: this.type.cls,
      style: this.sizeStyle,
      on: Object.assign({}, this.qListeners),
      attrs: {
        "aria-hidden": "true",
        role: "presentation"
      }
    };
    return !0 === this.type.none ? t(this.tag, e, slot(this, "default")) : !0 === this.type.img ? (e.attrs.src = this.type.src, t("img", e)) : !0 === this.type.svg ? (e.attrs.focusable = "false", e.attrs.viewBox = this.type.viewBox, t("svg", e, mergeSlot(this.type.nodes, this, "default"))) : t(this.tag, e, mergeSlot([this.type.content], this, "default"));
  }
}),
    QAvatar = vue_runtime_esm["a" /* default */].extend({
  name: "QAvatar",
  mixins: [ListenersMixin, SizeMixin],
  props: {
    fontSize: String,
    color: String,
    textColor: String,
    icon: String,
    square: Boolean,
    rounded: Boolean
  },
  computed: {
    contentClass: function contentClass() {
      var t;
      return (t = {})["bg-" + this.color] = this.color, t["text-" + this.textColor + " q-chip--colored"] = this.textColor, t["q-avatar__content--square"] = this.square, t["rounded-borders"] = this.rounded, t;
    },
    contentStyle: function contentStyle() {
      if (this.fontSize) return {
        fontSize: this.fontSize
      };
    }
  },
  render: function render(t) {
    var e = void 0 !== this.icon ? [t(QIcon, {
      props: {
        name: this.icon
      }
    })] : void 0;
    return t("div", {
      staticClass: "q-avatar",
      style: this.sizeStyle,
      on: Object.assign({}, this.qListeners)
    }, [t("div", {
      staticClass: "q-avatar__content row flex-center overflow-hidden",
      class: this.contentClass,
      style: this.contentStyle
    }, mergeSlotSafely(e, this, "default"))]);
  }
}),
    QBadge = vue_runtime_esm["a" /* default */].extend({
  name: "QBadge",
  mixins: [ListenersMixin],
  props: {
    color: String,
    textColor: String,
    floating: Boolean,
    transparent: Boolean,
    multiLine: Boolean,
    outline: Boolean,
    label: [Number, String],
    align: {
      type: String,
      validator: function validator(t) {
        return ["top", "middle", "bottom"].includes(t);
      }
    }
  },
  computed: {
    style: function style() {
      if (void 0 !== this.align) return {
        verticalAlign: this.align
      };
    },
    classes: function classes() {
      var t = !0 === this.outline && this.color || this.textColor;
      return "q-badge flex inline items-center no-wrap q-badge--" + (!0 === this.multiLine ? "multi" : "single") + "-line" + (!0 === this.outline ? " q-badge--outline" : void 0 !== this.color ? " bg-" + this.color : "") + (void 0 !== t ? " text-" + t : "") + (!0 === this.floating ? " q-badge--floating" : "") + (!0 === this.transparent ? " q-badge--transparent" : "");
    },
    attrs: function attrs() {
      return {
        role: "alert",
        "aria-label": this.label
      };
    }
  },
  render: function render(t) {
    return t("div", {
      style: this.style,
      class: this.classes,
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    }, void 0 !== this.label ? [this.label] : slot(this, "default"));
  }
}),
    DarkMixin = {
  props: {
    dark: {
      type: Boolean,
      default: null
    }
  },
  computed: {
    isDark: function isDark() {
      return null === this.dark ? this.$q.dark.isActive : this.dark;
    }
  }
},
    attrs = {
  role: "alert"
},
    QBanner = vue_runtime_esm["a" /* default */].extend({
  name: "QBanner",
  mixins: [ListenersMixin, DarkMixin],
  props: {
    inlineActions: Boolean,
    dense: Boolean,
    rounded: Boolean
  },
  render: function render(t) {
    var e = slot(this, "action"),
        i = [t("div", {
      staticClass: "q-banner__avatar col-auto row items-center self-start"
    }, slot(this, "avatar")), t("div", {
      staticClass: "q-banner__content col text-body2"
    }, slot(this, "default"))];
    return void 0 !== e && i.push(t("div", {
      staticClass: "q-banner__actions row items-center justify-end",
      class: "col-" + (!0 === this.inlineActions ? "auto" : "all")
    }, e)), t("div", {
      staticClass: "q-banner row items-center",
      class: {
        "q-banner--top-padding": void 0 !== e && !this.inlineActions,
        "q-banner--dense": this.dense,
        "q-banner--dark q-dark": this.isDark,
        "rounded-borders": this.rounded
      },
      attrs: attrs,
      on: Object.assign({}, this.qListeners)
    }, i);
  }
}),
    attrs$1 = {
  role: "toolbar"
},
    QBar = vue_runtime_esm["a" /* default */].extend({
  name: "QBar",
  mixins: [ListenersMixin, DarkMixin],
  props: {
    dense: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-bar--" + (!0 === this.dense ? "dense" : "standard") + " q-bar--" + (!0 === this.isDark ? "dark" : "light");
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-bar row no-wrap items-center",
      class: this.classes,
      attrs: attrs$1,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    alignMap = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
},
    alignValues = Object.keys(alignMap),
    AlignMixin = {
  props: {
    align: {
      type: String,
      validator: function validator(t) {
        return alignValues.includes(t);
      }
    }
  },
  computed: {
    alignClass: function alignClass() {
      var t = void 0 === this.align ? !0 === this.vertical ? "stretch" : "left" : this.align;
      return (!0 === this.vertical ? "items" : "justify") + "-" + alignMap[t];
    }
  }
},
    QBreadcrumbs = vue_runtime_esm["a" /* default */].extend({
  name: "QBreadcrumbs",
  mixins: [ListenersMixin, AlignMixin],
  props: {
    separator: {
      type: String,
      default: "/"
    },
    separatorColor: String,
    activeColor: {
      type: String,
      default: "primary"
    },
    gutter: {
      type: String,
      validator: function validator(t) {
        return ["none", "xs", "sm", "md", "lg", "xl"].includes(t);
      },
      default: "sm"
    }
  },
  computed: {
    classes: function classes() {
      return this.alignClass + ("none" === this.gutter ? "" : " q-gutter-" + this.gutter);
    },
    sepClass: function sepClass() {
      if (this.separatorColor) return "text-" + this.separatorColor;
    },
    activeClass: function activeClass() {
      return "text-" + this.activeColor;
    }
  },
  render: function render(t) {
    var e = this,
        i = slot(this, "default");

    if (void 0 !== i) {
      var s = 1,
          n = [],
          o = i.filter(function (t) {
        return void 0 !== t.tag && t.tag.endsWith("-QBreadcrumbsEl");
      }).length,
          r = void 0 !== this.$scopedSlots.separator ? this.$scopedSlots.separator : function () {
        return e.separator;
      };
      return i.forEach(function (i) {
        if (void 0 !== i.tag && i.tag.endsWith("-QBreadcrumbsEl")) {
          var a = s < o;
          s++, n.push(t("div", {
            staticClass: "flex items-center",
            class: a ? e.activeClass : "q-breadcrumbs--last"
          }, [i])), a && n.push(t("div", {
            staticClass: "q-breadcrumbs__separator",
            class: e.sepClass
          }, r()));
        } else n.push(i);
      }), t("div", {
        staticClass: "q-breadcrumbs",
        on: Object.assign({}, this.qListeners)
      }, [t("div", {
        staticClass: "flex items-center",
        class: this.classes
      }, n)]);
    }
  }
}),
    routerLinkProps = {
  to: [String, Object],
  exact: Boolean,
  append: Boolean,
  replace: Boolean,
  activeClass: String,
  exactActiveClass: String,
  disable: Boolean
},
    RouterLinkMixin = {
  props: routerLinkProps,
  computed: {
    hasRouterLink: function hasRouterLink() {
      return !0 !== this.disable && void 0 !== this.to && null !== this.to && "" !== this.to;
    },
    routerLinkProps: function routerLinkProps() {
      return {
        to: this.to,
        exact: this.exact,
        append: this.append,
        replace: this.replace,
        activeClass: this.activeClass || "q-router-link--active",
        exactActiveClass: this.exactActiveClass || "q-router-link--exact-active",
        event: !0 === this.disable ? "" : void 0
      };
    }
  }
},
    QBreadcrumbsEl = vue_runtime_esm["a" /* default */].extend({
  name: "QBreadcrumbsEl",
  mixins: [ListenersMixin, RouterLinkMixin],
  props: {
    label: String,
    icon: String
  },
  render: function render(t) {
    var e,
        i = [];
    return void 0 !== this.icon && i.push(t(QIcon, {
      staticClass: "q-breadcrumbs__el-icon",
      class: void 0 !== this.label ? "q-breadcrumbs__el-icon--with-label" : null,
      props: {
        name: this.icon
      }
    })), this.label && i.push(this.label), t(!0 === this.hasRouterLink ? "router-link" : "span", ((e = {
      staticClass: "q-breadcrumbs__el q-link flex inline items-center relative-position",
      props: !0 === this.hasRouterLink ? this.routerLinkProps : null
    })[!0 === this.hasRouterLink ? "nativeOn" : "on"] = Object.assign({}, this.qListeners), e), mergeSlot(i, this, "default"));
  }
}),
    mixin$1 = {
  mixins: [ListenersMixin],
  props: {
    color: String,
    size: {
      type: [Number, String],
      default: "1em"
    }
  },
  computed: {
    cSize: function cSize() {
      return this.size in sizes ? sizes[this.size] + "px" : this.size;
    },
    classes: function classes() {
      if (this.color) return "text-" + this.color;
    }
  }
},
    QSpinner = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinner",
  mixins: [mixin$1],
  props: {
    thickness: {
      type: Number,
      default: 5
    }
  },
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner q-spinner-mat",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        viewBox: "25 25 50 50"
      }
    }, [t("circle", {
      staticClass: "path",
      attrs: {
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": this.thickness,
        "stroke-miterlimit": "10"
      }
    })]);
  }
});

function offset(t) {
  if (t === window) return {
    top: 0,
    left: 0
  };
  var e = t.getBoundingClientRect();
  return {
    top: e.top,
    left: e.left
  };
}

function style(t, e) {
  return window.getComputedStyle(t).getPropertyValue(e);
}

function height(t) {
  return t === window ? window.innerHeight : t.getBoundingClientRect().height;
}

function width(t) {
  return t === window ? window.innerWidth : t.getBoundingClientRect().width;
}

function css(t, e) {
  var i = t.style;
  Object.keys(e).forEach(function (t) {
    i[t] = e[t];
  });
}

function cssBatch(t, e) {
  t.forEach(function (t) {
    return css(t, e);
  });
}

function ready(t) {
  if ("function" == typeof t) return "loading" !== document.readyState ? t() : void document.addEventListener("DOMContentLoaded", t, !1);
}

function childHasFocus(t, e) {
  if (void 0 === t || !0 === t.contains(e)) return !0;

  for (var i = t.nextElementSibling; null !== i; i = i.nextElementSibling) {
    if (i.contains(e)) return !0;
  }

  return !1;
}

var dom = {
  offset: offset,
  style: style,
  height: height,
  width: width,
  css: css,
  cssBatch: cssBatch,
  ready: ready
},
    directions = ["left", "right", "up", "down", "horizontal", "vertical"],
    modifiersAll = {
  left: !0,
  right: !0,
  up: !0,
  down: !0,
  horizontal: !0,
  vertical: !0,
  all: !0
};

function getModifierDirections(t) {
  var e = {};
  return directions.forEach(function (i) {
    t[i] && (e[i] = !0);
  }), 0 === Object.keys(e).length ? modifiersAll : (!0 === e.horizontal && (e.left = e.right = !0), !0 === e.vertical && (e.up = e.down = !0), !0 === e.left && !0 === e.right && (e.horizontal = !0), !0 === e.up && !0 === e.down && (e.vertical = !0), !0 === e.horizontal && !0 === e.vertical && (e.all = !0), e);
}

function updateModifiers(t, e) {
  var i = e.oldValue,
      s = e.value,
      n = e.modifiers;
  i !== s && ("function" != typeof s && t.end(), t.handler = s), (t.modifiers.mouseAllDir !== n.mouseAllDir || directions.some(function (e) {
    return n[e] !== t.modifiers[e];
  })) && (t.modifiers = n, t.direction = getModifierDirections(n));
}

function addEvt(t, e, i) {
  t[e += "Evt"] = void 0 !== t[e] ? t[e].concat(i) : i, i.forEach(function (e) {
    e[0].addEventListener(e[1], t[e[2]], listenOpts[e[3]]);
  });
}

function cleanEvt(t, e) {
  void 0 !== t[e += "Evt"] && (t[e].forEach(function (e) {
    e[0].removeEventListener(e[1], t[e[2]], listenOpts[e[3]]);
  }), t[e] = void 0);
}

var getTouchTarget = !1 === isSSR && !0 !== iosEmulated && (!0 === client.is.ios || window.navigator.vendor.toLowerCase().indexOf("apple") > -1) ? function () {
  return document;
} : function (t) {
  return t;
};

function shouldStart(t, e) {
  return void 0 === e.event && void 0 !== t.target && !0 !== t.target.draggable && "function" == typeof e.handler && "INPUT" !== t.target.nodeName.toUpperCase() && (void 0 === t.qClonedBy || -1 === t.qClonedBy.indexOf(e.uid));
}

function throttle(t, e) {
  void 0 === e && (e = 250);
  var i,
      s = !1;
  return function () {
    return !1 === s && (s = !0, setTimeout(function () {
      s = !1;
    }, e), i = t.apply(this, arguments)), i;
  };
}

function showRipple(t, e, i, s) {
  !0 === i.modifiers.stop && stop(t);
  var n = i.modifiers,
      o = n.center,
      r = n.color;
  o = !0 === o || !0 === s;

  var a = document.createElement("span"),
      l = document.createElement("span"),
      c = position(t),
      u = e.getBoundingClientRect(),
      h = u.left,
      d = u.top,
      p = u.width,
      f = u.height,
      m = Math.sqrt(p * p + f * f),
      v = m / 2,
      g = (p - m) / 2 + "px",
      _ = o ? g : c.left - h - v + "px",
      b = (f - m) / 2 + "px",
      y = o ? b : c.top - d - v + "px";

  l.className = "q-ripple__inner", css(l, {
    height: m + "px",
    width: m + "px",
    transform: "translate3d(" + _ + "," + y + ",0) scale3d(.2,.2,1)",
    opacity: 0
  }), a.className = "q-ripple" + (r ? " text-" + r : ""), a.setAttribute("dir", "ltr"), a.appendChild(l), e.appendChild(a);

  var S = function S() {
    a.remove(), clearTimeout(x);
  };

  i.abort.push(S);
  var x = setTimeout(function () {
    l.classList.add("q-ripple__inner--enter"), l.style.transform = "translate3d(" + g + "," + b + ",0) scale3d(1,1,1)", l.style.opacity = .2, x = setTimeout(function () {
      l.classList.remove("q-ripple__inner--enter"), l.classList.add("q-ripple__inner--leave"), l.style.opacity = 0, x = setTimeout(function () {
        a.remove(), i.abort.splice(i.abort.indexOf(S), 1);
      }, 275);
    }, 250);
  }, 50);
}

function updateCtx(t, e) {
  var i = e.value,
      s = e.modifiers,
      n = e.arg;

  if (t.enabled = !1 !== i, !0 === t.enabled) {
    var o = Object.assign({}, $q.config.ripple, s, i);
    t.modifiers = {
      early: !0 === o.early,
      stop: !0 === o.stop,
      center: !0 === o.center,
      color: o.color || n,
      keyCodes: [].concat(o.keyCodes || 13)
    };
  }
}

var Ripple = {
  name: "ripple",
  inserted: function inserted(t, e) {
    var i = {
      modifiers: {},
      abort: [],
      start: function start(e) {
        !0 === i.enabled && !0 !== e.qSkipRipple && (!0 !== client.is.ie || e.clientX >= 0) && (!0 === i.modifiers.early ? !0 === ["mousedown", "touchstart"].includes(e.type) : "click" === e.type) && showRipple(e, t, i, !0 === e.qKeyEvent);
      },
      keystart: throttle(function (e) {
        !0 === i.enabled && !0 !== e.qSkipRipple && !0 === isKeyCode(e, i.modifiers.keyCodes) && e.type === "key" + (!0 === i.modifiers.early ? "down" : "up") && showRipple(e, t, i, !0);
      }, 300)
    };
    updateCtx(i, e), t.__qripple && (t.__qripple_old = t.__qripple), t.__qripple = i, addEvt(i, "main", [[t, "mousedown", "start", "passive"], [t, "touchstart", "start", "passive"], [t, "click", "start", "passive"], [t, "keydown", "keystart", "passive"], [t, "keyup", "keystart", "passive"]]);
  },
  update: function update(t, e) {
    void 0 !== t.__qripple && updateCtx(t.__qripple, e);
  },
  unbind: function unbind(t) {
    var e = t.__qripple_old || t.__qripple;
    void 0 !== e && (e.abort.forEach(function (t) {
      t();
    }), cleanEvt(e, "main"), delete t[t.__qripple_old ? "__qripple_old" : "__qripple"]);
  }
},
    RippleMixin = {
  directives: {
    Ripple: Ripple
  },
  props: {
    ripple: {
      type: [Boolean, Object],
      default: !0
    }
  }
},
    padding = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
},
    BtnMixin = {
  mixins: [ListenersMixin, RippleMixin, AlignMixin, getSizeMixin({
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  })],
  props: {
    type: String,
    to: [Object, String],
    replace: Boolean,
    label: [Number, String],
    icon: String,
    iconRight: String,
    round: Boolean,
    outline: Boolean,
    flat: Boolean,
    unelevated: Boolean,
    rounded: Boolean,
    push: Boolean,
    glossy: Boolean,
    size: String,
    fab: Boolean,
    fabMini: Boolean,
    padding: String,
    color: String,
    textColor: String,
    noCaps: Boolean,
    noWrap: Boolean,
    dense: Boolean,
    tabindex: [Number, String],
    align: {
      default: "center"
    },
    stack: Boolean,
    stretch: Boolean,
    loading: {
      type: Boolean,
      default: null
    },
    disable: Boolean
  },
  computed: {
    style: function style() {
      if (!1 === this.fab && !1 === this.fabMini) return this.sizeStyle;
    },
    isRounded: function isRounded() {
      return !0 === this.rounded || !0 === this.fab || !0 === this.fabMini;
    },
    isActionable: function isActionable() {
      return !0 !== this.disable && !0 !== this.loading;
    },
    computedTabIndex: function computedTabIndex() {
      return !0 === this.isActionable ? this.tabindex || 0 : -1;
    },
    hasRouterLink: function hasRouterLink() {
      return !0 !== this.disable && void 0 !== this.to && null !== this.to && "" !== this.to;
    },
    isLink: function isLink() {
      return "a" === this.type || !0 === this.hasRouterLink;
    },
    design: function design() {
      return !0 === this.flat ? "flat" : !0 === this.outline ? "outline" : !0 === this.push ? "push" : !0 === this.unelevated ? "unelevated" : "standard";
    },
    attrs: function attrs() {
      var t = {
        tabindex: this.computedTabIndex
      };
      return "a" !== this.type && (t.type = this.type || "button"), !0 === this.hasRouterLink ? (t.href = this.$router.resolve(this.to).href, t.role = "link") : t.role = "a" === this.type ? "link" : "button", !0 === this.loading && void 0 !== this.percentage && (t.role = "progressbar", t["aria-valuemin"] = 0, t["aria-valuemax"] = 100, t["aria-valuenow"] = this.percentage), !0 === this.disable && (t.disabled = "", t["aria-disabled"] = ""), t;
    },
    classes: function classes() {
      var t;
      return void 0 !== this.color ? t = !0 === this.flat || !0 === this.outline ? "text-" + (this.textColor || this.color) : "bg-" + this.color + " text-" + (this.textColor || "white") : this.textColor && (t = "text-" + this.textColor), "q-btn--" + this.design + " q-btn--" + (!0 === this.round ? "round" : "rectangle" + (!0 === this.isRounded ? " q-btn--rounded" : "")) + (void 0 !== t ? " " + t : "") + (!0 === this.isActionable ? " q-btn--actionable q-focusable q-hoverable" : !0 === this.disable ? " disabled" : "") + (!0 === this.fab ? " q-btn--fab" : !0 === this.fabMini ? " q-btn--fab-mini" : "") + (!0 === this.noCaps ? " q-btn--no-uppercase" : "") + (!0 === this.noWrap ? "" : " q-btn--wrap") + (!0 === this.dense ? " q-btn--dense" : "") + (!0 === this.stretch ? " no-border-radius self-stretch" : "") + (!0 === this.glossy ? " glossy" : "");
    },
    innerClasses: function innerClasses() {
      return this.alignClass + (!0 === this.stack ? " column" : " row") + (!0 === this.noWrap ? " no-wrap text-no-wrap" : "") + (!0 === this.loading ? " q-btn__content--hidden" : "");
    },
    wrapperStyle: function wrapperStyle() {
      if (void 0 !== this.padding) return {
        padding: this.padding.split(/\s+/).map(function (t) {
          return t in padding ? padding[t] + "px" : t;
        }).join(" "),
        minWidth: "0",
        minHeight: "0"
      };
    }
  }
},
    passiveCapture = listenOpts.passiveCapture,
    touchTarget = void 0,
    keyboardTarget = void 0,
    mouseTarget = void 0,
    iconAttrs = {
  role: "img",
  "aria-hidden": "true"
},
    QBtn = vue_runtime_esm["a" /* default */].extend({
  name: "QBtn",
  mixins: [BtnMixin],
  props: {
    percentage: Number,
    darkPercentage: Boolean
  },
  computed: {
    hasLabel: function hasLabel() {
      return void 0 !== this.label && null !== this.label && "" !== this.label;
    },
    computedRipple: function computedRipple() {
      return !1 !== this.ripple && Object.assign({
        keyCodes: !0 === this.isLink ? [13, 32] : [13]
      }, !0 === this.ripple ? {} : this.ripple);
    },
    percentageStyle: function percentageStyle() {
      var t = Math.max(0, Math.min(100, this.percentage));
      if (t > 0) return {
        transition: "transform 0.6s",
        transform: "translateX(" + (t - 100) + "%)"
      };
    },
    onEvents: function onEvents() {
      if (!0 === this.loading) return {
        mousedown: this.__onLoadingEvt,
        touchstart: this.__onLoadingEvt,
        click: this.__onLoadingEvt,
        keydown: this.__onLoadingEvt,
        keyup: this.__onLoadingEvt
      };

      if (!0 === this.isActionable) {
        var t = Object.assign({}, this.qListeners, {
          click: this.click,
          keydown: this.__onKeydown,
          mousedown: this.__onMousedown
        });
        return !0 === this.$q.platform.has.touch && (t.touchstart = this.__onTouchstart), t;
      }

      return {};
    },
    directives: function directives() {
      if (!0 !== this.disable && !1 !== this.ripple) return [{
        name: "ripple",
        value: this.computedRipple,
        modifiers: {
          center: this.round
        }
      }];
    }
  },
  methods: {
    click: function click(t) {
      var e = this;

      if (void 0 !== t) {
        if (!0 === t.defaultPrevented) return;
        var i = document.activeElement;

        if ("submit" === this.type && (!0 === this.$q.platform.is.ie && (t.clientX < 0 || t.clientY < 0) || i !== document.body && !1 === this.$el.contains(i) && !1 === i.contains(this.$el))) {
          this.$el.focus();

          var s = function s() {
            document.removeEventListener("keydown", stopAndPrevent, !0), document.removeEventListener("keyup", s, passiveCapture), void 0 !== e.$el && e.$el.removeEventListener("blur", s, passiveCapture);
          };

          document.addEventListener("keydown", stopAndPrevent, !0), document.addEventListener("keyup", s, passiveCapture), this.$el.addEventListener("blur", s, passiveCapture);
        }

        if (!0 === this.hasRouterLink) {
          if (!0 === t.ctrlKey || !0 === t.shiftKey || !0 === t.altKey || !0 === t.metaKey) return;
          stopAndPrevent(t);
        }
      }

      var n = function n() {
        var t = e.$router[!0 === e.replace ? "replace" : "push"](e.to);
        void 0 !== t && "function" == typeof t.catch && t.catch(noop);
      };

      this.$emit("click", t, n), !0 === this.hasRouterLink && !1 !== t.navigate && n();
    },
    __onKeydown: function __onKeydown(t) {
      !0 === isKeyCode(t, [13, 32]) && (stopAndPrevent(t), keyboardTarget !== this.$el && (void 0 !== keyboardTarget && this.__cleanup(), this.$el.focus(), keyboardTarget = this.$el, this.$el.classList.add("q-btn--active"), document.addEventListener("keyup", this.__onPressEnd, !0), this.$el.addEventListener("blur", this.__onPressEnd, passiveCapture))), this.$emit("keydown", t);
    },
    __onTouchstart: function __onTouchstart(t) {
      var e = this;

      if (touchTarget !== this.$el) {
        void 0 !== touchTarget && this.__cleanup(), touchTarget = this.$el;
        var i = this.touchTargetEl = getTouchTarget(t.target);
        i.addEventListener("touchcancel", this.__onPressEnd, passiveCapture), i.addEventListener("touchend", this.__onPressEnd, passiveCapture);
      }

      this.avoidMouseRipple = !0, clearTimeout(this.mouseTimer), this.mouseTimer = setTimeout(function () {
        e.avoidMouseRipple = !1;
      }, 200), this.$emit("touchstart", t);
    },
    __onMousedown: function __onMousedown(t) {
      mouseTarget !== this.$el && (void 0 !== mouseTarget && this.__cleanup(), mouseTarget = this.$el, this.$el.classList.add("q-btn--active"), document.addEventListener("mouseup", this.__onPressEnd, passiveCapture)), t.qSkipRipple = !0 === this.avoidMouseRipple, this.$emit("mousedown", t);
    },
    __onPressEnd: function __onPressEnd(t) {
      if (void 0 === t || "blur" !== t.type || document.activeElement !== this.$el) {
        if (void 0 !== t && "keyup" === t.type) {
          if (keyboardTarget === this.$el && !0 === isKeyCode(t, [13, 32])) {
            var e = new MouseEvent("click", t);
            e.qKeyEvent = !0, !0 === t.defaultPrevented && prevent(e), !0 === t.cancelBubble && stop(e), this.$el.dispatchEvent(e), stopAndPrevent(t), t.qKeyEvent = !0;
          }

          this.$emit("keyup", t);
        }

        this.__cleanup();
      }
    },
    __cleanup: function __cleanup(t) {
      var e = this.$refs.blurTarget;

      if (!0 === t || touchTarget !== this.$el && mouseTarget !== this.$el || void 0 === e || e === document.activeElement || (e.setAttribute("tabindex", -1), e.focus()), touchTarget === this.$el) {
        var i = this.touchTargetEl;
        i.removeEventListener("touchcancel", this.__onPressEnd, passiveCapture), i.removeEventListener("touchend", this.__onPressEnd, passiveCapture), touchTarget = this.touchTargetEl = void 0;
      }

      mouseTarget === this.$el && (document.removeEventListener("mouseup", this.__onPressEnd, passiveCapture), mouseTarget = void 0), keyboardTarget === this.$el && (document.removeEventListener("keyup", this.__onPressEnd, !0), void 0 !== this.$el && this.$el.removeEventListener("blur", this.__onPressEnd, passiveCapture), keyboardTarget = void 0), void 0 !== this.$el && this.$el.classList.remove("q-btn--active");
    },
    __onLoadingEvt: function __onLoadingEvt(t) {
      stopAndPrevent(t), t.qSkipRipple = !0;
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.__cleanup(!0);
  },
  render: function render(t) {
    var e = [];
    void 0 !== this.icon && e.push(t(QIcon, {
      attrs: iconAttrs,
      props: {
        name: this.icon,
        left: !1 === this.stack && !0 === this.hasLabel
      }
    })), !0 === this.hasLabel && e.push(t("span", {
      staticClass: "block"
    }, [this.label])), e = mergeSlot(e, this, "default"), void 0 !== this.iconRight && !1 === this.round && e.push(t(QIcon, {
      attrs: iconAttrs,
      props: {
        name: this.iconRight,
        right: !1 === this.stack && !0 === this.hasLabel
      }
    }));
    var i = [t("span", {
      staticClass: "q-focus-helper",
      ref: "blurTarget"
    })];
    return !0 === this.loading && void 0 !== this.percentage && i.push(t("span", {
      staticClass: "q-btn__progress absolute-full overflow-hidden"
    }, [t("span", {
      staticClass: "q-btn__progress-indicator fit block",
      class: !0 === this.darkPercentage ? "q-btn__progress--dark" : "",
      style: this.percentageStyle
    })])), i.push(t("span", {
      staticClass: "q-btn__wrapper col row q-anchor--skip",
      style: this.wrapperStyle
    }, [t("span", {
      staticClass: "q-btn__content text-center col items-center q-anchor--skip",
      class: this.innerClasses
    }, e)])), null !== this.loading && i.push(t("transition", {
      props: {
        name: "q-transition--fade"
      }
    }, !0 === this.loading ? [t("span", {
      key: "loading",
      staticClass: "absolute-full flex flex-center"
    }, void 0 !== this.$scopedSlots.loading ? this.$scopedSlots.loading() : [t(QSpinner)])] : void 0)), t(!0 === this.isLink ? "a" : "button", {
      staticClass: "q-btn q-btn-item non-selectable no-outline",
      class: this.classes,
      style: this.style,
      attrs: this.attrs,
      on: this.onEvents,
      directives: this.directives
    }, i);
  }
}),
    QBtnGroup = vue_runtime_esm["a" /* default */].extend({
  name: "QBtnGroup",
  mixin: [ListenersMixin],
  props: {
    unelevated: Boolean,
    outline: Boolean,
    flat: Boolean,
    rounded: Boolean,
    push: Boolean,
    stretch: Boolean,
    glossy: Boolean,
    spread: Boolean
  },
  computed: {
    classes: function classes() {
      var t = this;
      return ["unelevated", "outline", "flat", "rounded", "push", "stretch", "glossy"].filter(function (e) {
        return !0 === t[e];
      }).map(function (t) {
        return "q-btn-group--" + t;
      }).join(" ");
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-btn-group row no-wrap " + (!0 === this.spread ? "q-btn-group--spread" : "inline"),
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
});

function clearSelection() {
  if (void 0 !== window.getSelection) {
    var t = window.getSelection();
    void 0 !== t.empty ? t.empty() : void 0 !== t.removeAllRanges && (t.removeAllRanges(), !0 !== Platform.is.mobile && t.addRange(document.createRange()));
  } else void 0 !== document.selection && document.selection.empty();
}

var AnchorMixin = {
  props: {
    target: {
      default: !0
    },
    noParentEvent: Boolean,
    contextMenu: Boolean
  },
  watch: {
    contextMenu: function contextMenu(t) {
      void 0 !== this.anchorEl && (this.__unconfigureAnchorEl(), this.__configureAnchorEl(t));
    },
    target: function target() {
      void 0 !== this.anchorEl && this.__unconfigureAnchorEl(), this.__pickAnchorEl();
    },
    noParentEvent: function noParentEvent(t) {
      void 0 !== this.anchorEl && (!0 === t ? this.__unconfigureAnchorEl() : this.__configureAnchorEl());
    }
  },
  methods: {
    __showCondition: function __showCondition(t) {
      return void 0 !== this.anchorEl && (void 0 === t || void 0 === t.touches || t.touches.length <= 1);
    },
    __contextClick: function __contextClick(t) {
      var e = this;
      this.hide(t), this.$nextTick(function () {
        e.show(t);
      }), prevent(t);
    },
    __toggleKey: function __toggleKey(t) {
      !0 === isKeyCode(t, 13) && this.toggle(t);
    },
    __mobileCleanup: function __mobileCleanup(t) {
      this.anchorEl.classList.remove("non-selectable"), clearTimeout(this.touchTimer), !0 === this.showing && void 0 !== t && clearSelection();
    },
    __mobilePrevent: prevent,
    __mobileTouch: function __mobileTouch(t) {
      var e = this;

      if (this.__mobileCleanup(t), !0 === this.__showCondition(t)) {
        this.hide(t), this.anchorEl.classList.add("non-selectable");
        var i = getTouchTarget(t.target);
        addEvt(this, "anchor", [[i, "touchmove", "__mobileCleanup", "passive"], [i, "touchend", "__mobileCleanup", "passive"], [i, "touchcancel", "__mobileCleanup", "passive"], [this.anchorEl, "contextmenu", "__mobilePrevent", "notPassive"]]), this.touchTimer = setTimeout(function () {
          e.show(t);
        }, 300);
      }
    },
    __unconfigureAnchorEl: function __unconfigureAnchorEl() {
      cleanEvt(this, "anchor");
    },
    __configureAnchorEl: function __configureAnchorEl(t) {
      (void 0 === t && (t = this.contextMenu), !0 !== this.noParentEvent && void 0 !== this.anchorEl) && addEvt(this, "anchor", !0 === t ? !0 === this.$q.platform.is.mobile ? [[this.anchorEl, "touchstart", "__mobileTouch", "passive"]] : [[this.anchorEl, "click", "hide", "passive"], [this.anchorEl, "contextmenu", "__contextClick", "notPassive"]] : [[this.anchorEl, "click", "toggle", "passive"], [this.anchorEl, "keyup", "__toggleKey", "passive"]]);
    },
    __setAnchorEl: function __setAnchorEl(t) {
      for (this.anchorEl = t; this.anchorEl.classList.contains("q-anchor--skip");) {
        this.anchorEl = this.anchorEl.parentNode;
      }

      this.__configureAnchorEl();
    },
    __pickAnchorEl: function __pickAnchorEl() {
      if (!1 === this.target || "" === this.target) this.anchorEl = void 0;else if (!0 === this.target) this.__setAnchorEl(this.parentEl);else {
        var t = this.target;
        if ("string" == typeof this.target) try {
          t = document.querySelector(this.target);
        } catch (e) {
          t = void 0;
        }
        void 0 !== t && null !== t ? (this.anchorEl = !0 === t._isVue && void 0 !== t.$el ? t.$el : t, this.__configureAnchorEl()) : (this.anchorEl = void 0, console.error('Anchor: target "' + this.target + '" not found', this));
      }
    },
    __changeScrollEvent: function __changeScrollEvent(t, e) {
      var i = (void 0 !== e ? "add" : "remove") + "EventListener",
          s = void 0 !== e ? e : this.__scrollFn;
      t !== window && t[i]("scroll", s, listenOpts.passive), window[i]("scroll", s, listenOpts.passive), this.__scrollFn = e;
    }
  },
  created: function created() {
    var t = this;
    "function" == typeof this.__configureScrollTarget && "function" == typeof this.__unconfigureScrollTarget && (this.noParentEventWatcher = this.$watch("noParentEvent", function () {
      void 0 !== t.__scrollTarget && (t.__unconfigureScrollTarget(), t.__configureScrollTarget());
    }));
  },
  mounted: function mounted() {
    this.parentEl = this.$el.parentNode, this.__pickAnchorEl(), !0 === this.value && void 0 === this.anchorEl && this.$emit("input", !1);
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.touchTimer), void 0 !== this.noParentEventWatcher && this.noParentEventWatcher(), void 0 !== this.__anchorCleanup && this.__anchorCleanup(), this.__unconfigureAnchorEl();
  }
},
    TimeoutMixin = {
  methods: {
    __nextTick: function __nextTick(t) {
      this.__tickFn = t;
    },
    __prepareTick: function __prepareTick() {
      var t = this;

      if (void 0 !== this.__tickFn) {
        var e = this.__tickFn;
        this.$nextTick(function () {
          t.__tickFn === e && (t.__tickFn(), t.__tickFn = void 0);
        });
      }
    },
    __clearTick: function __clearTick() {
      this.__tickFn = void 0;
    },
    __setTimeout: function __setTimeout(t, e) {
      clearTimeout(this.__timer), this.__timer = setTimeout(t, e);
    },
    __clearTimeout: function __clearTimeout() {
      clearTimeout(this.__timer);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.__tickFn = void 0, clearTimeout(this.__timer);
  }
},
    ModelToggleMixin = {
  mixins: [TimeoutMixin, ListenersMixin],
  props: {
    value: {
      type: Boolean,
      default: void 0
    }
  },
  data: function data() {
    return {
      showing: !1
    };
  },
  watch: {
    value: function value(t) {
      this.__processModelChange(t);
    },
    $route: function $route() {
      !0 === this.hideOnRouteChange && !0 === this.showing && this.hide();
    }
  },
  methods: {
    toggle: function toggle(t) {
      this[!0 === this.showing ? "hide" : "show"](t);
    },
    show: function show(t) {
      var e = this;
      !0 === this.disable || void 0 !== this.__showCondition && !0 !== this.__showCondition(t) || (void 0 !== this.qListeners.input && !1 === isSSR && (this.$emit("input", !0), this.payload = t, this.$nextTick(function () {
        e.payload === t && (e.payload = void 0);
      })), void 0 !== this.value && void 0 !== this.qListeners.input && !0 !== isSSR || this.__processShow(t));
    },
    __processShow: function __processShow(t) {
      !0 !== this.showing && (void 0 !== this.__preparePortal && this.__preparePortal(), this.showing = !0, this.$emit("before-show", t), void 0 !== this.__show ? (this.__clearTick(), this.__show(t), this.__prepareTick()) : this.$emit("show", t));
    },
    hide: function hide(t) {
      var e = this;
      !0 !== this.disable && (void 0 !== this.qListeners.input && !1 === isSSR && (this.$emit("input", !1), this.payload = t, this.$nextTick(function () {
        e.payload === t && (e.payload = void 0);
      })), void 0 !== this.value && void 0 !== this.qListeners.input && !0 !== isSSR || this.__processHide(t));
    },
    __processHide: function __processHide(t) {
      !1 !== this.showing && (this.showing = !1, this.$emit("before-hide", t), void 0 !== this.__hide ? (this.__clearTick(), this.__hide(t), this.__prepareTick()) : this.$emit("hide", t));
    },
    __processModelChange: function __processModelChange(t) {
      !0 === this.disable && !0 === t ? void 0 !== this.qListeners.input && this.$emit("input", !1) : !0 === t !== this.showing && this["__process" + (!0 === t ? "Show" : "Hide")](this.payload);
    }
  }
};

function closePortalMenus(t, e) {
  do {
    if ("QMenu" === t.$options.name) {
      if (t.hide(e), !0 === t.separateClosePopup) return t.$parent;
    } else if (void 0 !== t.__renderPortal) return void 0 !== t.$parent && "QPopupProxy" === t.$parent.$options.name ? (t.hide(e), t.$parent) : t;

    t = t.$parent;
  } while (void 0 !== t);
}

function closePortals(t, e, i) {
  for (; 0 !== i && void 0 !== t;) {
    if (void 0 !== t.__renderPortal) {
      if (i--, "QMenu" === t.$options.name) {
        t = closePortalMenus(t, e);
        continue;
      }

      t.hide(e);
    }

    t = t.$parent;
  }
}

var timer,
    PortalMixin = {
  inheritAttrs: !1,
  props: {
    contentClass: [Array, String, Object],
    contentStyle: [Array, String, Object]
  },
  methods: {
    __showPortal: function __showPortal() {
      var t = this;

      if (void 0 !== this.$q.fullscreen && !0 === this.$q.fullscreen.isCapable) {
        var e = function e(_e) {
          if (void 0 !== t.__portal) {
            var i = document.body;
            !0 === _e && (i = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.body), t.__portal.$el.parentElement !== i && !0 === i.contains(t.$el) && i.appendChild(t.__portal.$el);
          }
        };

        this.unwatchFullscreen = this.$watch("$q.fullscreen.isActive", e), e(this.$q.fullscreen.isActive);
      } else void 0 !== this.__portal && document.body.appendChild(this.__portal.$el);
    },
    __hidePortal: function __hidePortal() {
      void 0 !== this.__portal && (void 0 !== this.unwatchFullscreen && (this.unwatchFullscreen(), this.unwatchFullscreen = void 0), this.__portal.$destroy(), this.__portal.$el.remove(), this.__portal = void 0);
    },
    __preparePortal: function __preparePortal() {
      var t = this;
      void 0 === this.__portal && (this.__portal = new vue_runtime_esm["a" /* default */]({
        name: "QPortal",
        parent: this,
        inheritAttrs: !1,
        render: function render(e) {
          return t.__renderPortal(e);
        },
        components: this.$options.components,
        directives: this.$options.directives
      }).$mount());
    }
  },
  render: function render() {
    void 0 !== this.__portal && this.__portal.$forceUpdate();
  },
  beforeDestroy: function beforeDestroy() {
    this.__hidePortal();
  }
},
    TransitionMixin = {
  props: {
    transitionShow: {
      type: String,
      default: "fade"
    },
    transitionHide: {
      type: String,
      default: "fade"
    }
  },
  data: function data() {
    return {
      transitionState: this.showing
    };
  },
  watch: {
    showing: function showing(t) {
      var e = this;
      this.transitionShow !== this.transitionHide && this.$nextTick(function () {
        e.transitionState = t;
      });
    }
  },
  computed: {
    transition: function transition() {
      return "q-transition--" + (!0 === this.transitionState ? this.transitionHide : this.transitionShow);
    }
  }
},
    AttrsMixin = getPropCacheMixin("$attrs", "qAttrs");

function getVmOfNode(t) {
  for (var e = t; null !== e; e = e.parentNode) {
    if (null === e.__vue__) return;
    if (void 0 !== e.__vue__) return e.__vue__;
  }
}

function isVmChildOf(t, e) {
  for (var i = t; void 0 !== i; i = i.$parent) {
    if (i === e) return !0;
  }

  return !1;
}

var notPassiveCapture = listenOpts.notPassiveCapture,
    passiveCapture$1 = listenOpts.passiveCapture,
    handlers = {
  click: [],
  focus: []
};

function execHandlers(t, e) {
  for (var i = t.length - 1; i >= 0; i--) {
    if (void 0 === t[i](e)) return;
  }
}

function globalHandler(t) {
  clearTimeout(timer), "focusin" === t.type && !0 === t.target.hasAttribute("tabindex") ? timer = setTimeout(function () {
    execHandlers(handlers.focus, t);
  }, 200) : execHandlers(handlers.click, t);
}

var size,
    ClickOutside = {
  name: "click-outside",
  bind: function bind(t, e, i) {
    var s = e.value,
        n = e.arg,
        o = i.componentInstance || i.context,
        r = {
      trigger: s,
      toggleEl: n,
      handler: function handler(t) {
        var e = t.target;
        if (!(void 0 === e || 8 === e.nodeType || e === document.documentElement || !1 !== e.classList.contains("no-pointer-events") || void 0 !== r.toggleEl && !1 !== r.toggleEl.contains(e) || e !== document.body && !1 !== isVmChildOf(getVmOfNode(e), o))) return t.qClickOutside = !0, r.trigger(t);
      }
    };
    t.__qclickoutside && (t.__qclickoutside_old = t.__qclickoutside), t.__qclickoutside = r, 0 === handlers.click.length && (document.addEventListener("mousedown", globalHandler, notPassiveCapture), document.addEventListener("touchstart", globalHandler, notPassiveCapture), document.addEventListener("focusin", globalHandler, passiveCapture$1)), handlers.click.push(r.handler), r.timerFocusin = setTimeout(function () {
      handlers.focus.push(r.handler);
    }, 500);
  },
  update: function update(t, e) {
    var i = e.value,
        s = e.oldValue,
        n = e.arg,
        o = t.__qclickoutside;
    i !== s && (o.trigger = i), n !== o.arg && (o.toggleEl = n);
  },
  unbind: function unbind(t) {
    var e = t.__qclickoutside_old || t.__qclickoutside;

    if (void 0 !== e) {
      clearTimeout(e.timerFocusin);
      var i = handlers.click.findIndex(function (t) {
        return t === e.handler;
      }),
          s = handlers.focus.findIndex(function (t) {
        return t === e.handler;
      });
      i > -1 && handlers.click.splice(i, 1), s > -1 && handlers.focus.splice(s, 1), 0 === handlers.click.length && (clearTimeout(timer), document.removeEventListener("mousedown", globalHandler, notPassiveCapture), document.removeEventListener("touchstart", globalHandler, notPassiveCapture), document.removeEventListener("focusin", globalHandler, passiveCapture$1)), delete t[t.__qclickoutside_old ? "__qclickoutside_old" : "__qclickoutside"];
    }
  }
},
    scrollTargets = !1 === isSSR ? [null, document, document.body, document.scrollingElement, document.documentElement] : [];

function getScrollTarget(t, e) {
  if ("string" == typeof e) try {
    e = document.querySelector(e);
  } catch (t) {
    e = void 0;
  }
  return void 0 === e || null === e ? e = t.closest(".scroll,.scroll-y,.overflow-auto") : !0 === e._isVue && void 0 !== e.$el && (e = e.$el), scrollTargets.includes(e) ? window : e;
}

function getScrollHeight(t) {
  return (t === window ? document.body : t).scrollHeight;
}

function getScrollWidth(t) {
  return (t === window ? document.body : t).scrollWidth;
}

function getScrollPosition(t) {
  return t === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : t.scrollTop;
}

function getHorizontalScrollPosition(t) {
  return t === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : t.scrollLeft;
}

function animScrollTo(t, e, i) {
  void 0 === i && (i = 0);
  var s = getScrollPosition(t);
  i <= 0 ? s !== e && setScroll(t, e) : requestAnimationFrame(function () {
    var n = s + (e - s) / Math.max(16, i) * 16;
    setScroll(t, n), n !== e && animScrollTo(t, e, i - 16);
  });
}

function animHorizontalScrollTo(t, e, i) {
  void 0 === i && (i = 0);
  var s = getHorizontalScrollPosition(t);
  i <= 0 ? s !== e && setHorizontalScroll(t, e) : requestAnimationFrame(function () {
    var n = s + (e - s) / Math.max(16, i) * 16;
    setHorizontalScroll(t, n), n !== e && animHorizontalScrollTo(t, e, i - 16);
  });
}

function setScroll(t, e) {
  t !== window ? t.scrollTop = e : window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, e);
}

function setHorizontalScroll(t, e) {
  t !== window ? t.scrollLeft = e : window.scrollTo(e, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
}

function _setScrollPosition(t, e, i) {
  i ? animScrollTo(t, e, i) : setScroll(t, e);
}

function setHorizontalScrollPosition(t, e, i) {
  i ? animHorizontalScrollTo(t, e, i) : setHorizontalScroll(t, e);
}

function getScrollbarWidth() {
  if (void 0 !== size) return size;
  var t = document.createElement("p"),
      e = document.createElement("div");
  css(t, {
    width: "100%",
    height: "200px"
  }), css(e, {
    position: "absolute",
    top: "0px",
    left: "0px",
    visibility: "hidden",
    width: "200px",
    height: "150px",
    overflow: "hidden"
  }), e.appendChild(t), document.body.appendChild(e);
  var i = t.offsetWidth;
  e.style.overflow = "scroll";
  var s = t.offsetWidth;
  return i === s && (s = e.clientWidth), e.remove(), size = i - s;
}

function hasScrollbar(t, e) {
  return void 0 === e && (e = !0), !(!t || t.nodeType !== Node.ELEMENT_NODE) && (e ? t.scrollHeight > t.clientHeight && (t.classList.contains("scroll") || t.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(t)["overflow-y"])) : t.scrollWidth > t.clientWidth && (t.classList.contains("scroll") || t.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(t)["overflow-x"])));
}

var vpLeft,
    vpTop,
    quasar_esm_scroll = {
  getScrollTarget: getScrollTarget,
  getScrollHeight: getScrollHeight,
  getScrollWidth: getScrollWidth,
  getScrollPosition: getScrollPosition,
  getHorizontalScrollPosition: getHorizontalScrollPosition,
  animScrollTo: animScrollTo,
  animHorizontalScrollTo: animHorizontalScrollTo,
  setScrollPosition: _setScrollPosition,
  setHorizontalScrollPosition: setHorizontalScrollPosition,
  getScrollbarWidth: getScrollbarWidth,
  hasScrollbar: hasScrollbar
},
    handlers$1 = [],
    EscapeKey = {
  __install: function __install() {
    this.__installed = !0, window.addEventListener("keyup", function (t) {
      0 !== handlers$1.length && !0 === isKeyCode(t, 27) && handlers$1[handlers$1.length - 1].fn(t);
    });
  },
  register: function register(t, e) {
    !0 === t.$q.platform.is.desktop && (!0 !== this.__installed && this.__install(), handlers$1.push({
      comp: t,
      fn: e
    }));
  },
  pop: function pop(t) {
    if (!0 === t.$q.platform.is.desktop) {
      var e = handlers$1.findIndex(function (e) {
        return e.comp === t;
      });
      e > -1 && handlers$1.splice(e, 1);
    }
  }
};

function validatePosition(t) {
  var e = t.split(" ");
  return 2 === e.length && (["top", "center", "bottom"].includes(e[0]) ? !!["left", "middle", "right"].includes(e[1]) || (console.error("Anchor/Self position must end with one of left/middle/right"), !1) : (console.error("Anchor/Self position must start with one of top/center/bottom"), !1));
}

function validateOffset(t) {
  return !t || 2 === t.length && "number" == typeof t[0] && "number" == typeof t[1];
}

function parsePosition(t) {
  var e = t.split(" ");
  return {
    vertical: e[0],
    horizontal: e[1]
  };
}

function getAnchorProps(t, e) {
  var i = t.getBoundingClientRect(),
      s = i.top,
      n = i.left,
      o = i.right,
      r = i.bottom,
      a = i.width,
      l = i.height;
  return void 0 !== e && (s -= e[1], n -= e[0], r += e[1], o += e[0], a += e[0], l += e[1]), {
    top: s,
    left: n,
    right: o,
    bottom: r,
    width: a,
    height: l,
    middle: n + (o - n) / 2,
    center: s + (r - s) / 2
  };
}

function getTargetProps(t) {
  return {
    top: 0,
    center: t.offsetHeight / 2,
    bottom: t.offsetHeight,
    left: 0,
    middle: t.offsetWidth / 2,
    right: t.offsetWidth
  };
}

function setPosition(t) {
  if (!0 === client.is.ios && void 0 !== window.visualViewport) {
    var e = document.body.style,
        i = window.visualViewport,
        s = i.offsetLeft,
        n = i.offsetTop;
    s !== vpLeft && (e.setProperty("--q-pe-left", s + "px"), vpLeft = s), n !== vpTop && (e.setProperty("--q-pe-top", n + "px"), vpTop = n);
  }

  var o,
      r = t.el,
      a = r.scrollLeft,
      l = r.scrollTop;
  if (void 0 === t.absoluteOffset) o = getAnchorProps(t.anchorEl, !0 === t.cover ? [0, 0] : t.offset);else {
    var c = t.anchorEl.getBoundingClientRect(),
        u = c.top,
        h = c.left,
        d = u + t.absoluteOffset.top,
        p = h + t.absoluteOffset.left;
    o = {
      top: d,
      left: p,
      width: 1,
      height: 1,
      right: p + 1,
      center: d,
      middle: p,
      bottom: d + 1
    };
  }
  var f = {
    maxHeight: t.maxHeight,
    maxWidth: t.maxWidth,
    visibility: "visible"
  };
  !0 !== t.fit && !0 !== t.cover || (f.minWidth = o.width + "px", !0 === t.cover && (f.minHeight = o.height + "px")), Object.assign(t.el.style, f);
  var m = getTargetProps(t.el),
      v = {
    top: o[t.anchorOrigin.vertical] - m[t.selfOrigin.vertical],
    left: o[t.anchorOrigin.horizontal] - m[t.selfOrigin.horizontal]
  };
  applyBoundaries(v, o, m, t.anchorOrigin, t.selfOrigin), f = {
    top: Math.floor(v.top) + "px",
    left: Math.floor(v.left) + "px"
  }, void 0 !== v.maxHeight && (f.maxHeight = Math.floor(v.maxHeight) + "px", o.height > v.maxHeight && (f.minHeight = f.maxHeight)), void 0 !== v.maxWidth && (f.maxWidth = Math.floor(v.maxWidth) + "px", o.width > v.maxWidth && (f.minWidth = f.maxWidth)), Object.assign(t.el.style, f), t.el.scrollTop !== l && (t.el.scrollTop = l), t.el.scrollLeft !== a && (t.el.scrollLeft = a);
}

function applyBoundaries(t, e, i, s, n) {
  var o = i.bottom,
      r = i.right,
      a = getScrollbarWidth(),
      l = window.innerHeight - a,
      c = document.body.clientWidth;
  if (t.top < 0 || t.top + o > l) if ("center" === n.vertical) t.top = e[s.vertical] > l / 2 ? Math.max(0, l - o) : 0, t.maxHeight = Math.min(o, l);else if (e[s.vertical] > l / 2) {
    var u = Math.min(l, "center" === s.vertical ? e.center : s.vertical === n.vertical ? e.bottom : e.top);
    t.maxHeight = Math.min(o, u), t.top = Math.max(0, u - o);
  } else t.top = Math.max(0, "center" === s.vertical ? e.center : s.vertical === n.vertical ? e.top : e.bottom), t.maxHeight = Math.min(o, l - t.top);
  if (t.left < 0 || t.left + r > c) if (t.maxWidth = Math.min(r, c), "middle" === n.horizontal) t.left = e[s.horizontal] > c / 2 ? Math.max(0, c - r) : 0;else if (e[s.horizontal] > c / 2) {
    var h = Math.min(c, "middle" === s.horizontal ? e.middle : s.horizontal === n.horizontal ? e.right : e.left);
    t.maxWidth = Math.min(r, h), t.left = Math.max(0, h - t.maxWidth);
  } else t.left = Math.max(0, "middle" === s.horizontal ? e.middle : s.horizontal === n.horizontal ? e.left : e.right), t.maxWidth = Math.min(r, c - t.left);
}

var QMenu = vue_runtime_esm["a" /* default */].extend({
  name: "QMenu",
  mixins: [AttrsMixin, DarkMixin, AnchorMixin, ModelToggleMixin, PortalMixin, TransitionMixin],
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    persistent: Boolean,
    autoClose: Boolean,
    separateClosePopup: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    fit: Boolean,
    cover: Boolean,
    square: Boolean,
    anchor: {
      type: String,
      validator: validatePosition
    },
    self: {
      type: String,
      validator: validatePosition
    },
    offset: {
      type: Array,
      validator: validateOffset
    },
    scrollTarget: {
      default: void 0
    },
    touchPosition: Boolean,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    }
  },
  computed: {
    horizSide: function horizSide() {
      return !0 === this.$q.lang.rtl ? "right" : "left";
    },
    anchorOrigin: function anchorOrigin() {
      return parsePosition(this.anchor || (!0 === this.cover ? "center middle" : "bottom " + this.horizSide));
    },
    selfOrigin: function selfOrigin() {
      return !0 === this.cover ? this.anchorOrigin : parsePosition(this.self || "top " + this.horizSide);
    },
    menuClass: function menuClass() {
      return (!0 === this.square ? " q-menu--square" : "") + (!0 === this.isDark ? " q-menu--dark q-dark" : "");
    },
    hideOnRouteChange: function hideOnRouteChange() {
      return !0 !== this.persistent;
    },
    onEvents: function onEvents() {
      var t = Object.assign({}, this.qListeners, {
        input: stop,
        "popup-show": stop,
        "popup-hide": stop
      });
      return !0 === this.autoClose && (t.click = this.__onAutoClose), t;
    },
    attrs: function attrs() {
      return Object.assign({}, {
        tabindex: -1
      }, this.qAttrs);
    }
  },
  methods: {
    focus: function focus() {
      var t = void 0 !== this.__portal && void 0 !== this.__portal.$refs ? this.__portal.$refs.inner : void 0;
      void 0 !== t && !0 !== t.contains(document.activeElement) && (t = t.querySelector("[autofocus], [data-autofocus]") || t).focus();
    },
    __show: function __show(t) {
      var e = this;

      if (this.__refocusTarget = !1 === this.noRefocus && null !== document.activeElement ? document.activeElement : void 0, EscapeKey.register(this, function () {
        !0 !== e.persistent && (e.$emit("escape-key"), e.hide());
      }), this.__showPortal(), this.__configureScrollTarget(), this.absoluteOffset = void 0, void 0 !== t && (this.touchPosition || this.contextMenu)) {
        var i = position(t);

        if (void 0 !== i.left) {
          var s = this.anchorEl.getBoundingClientRect(),
              n = s.top,
              o = s.left;
          this.absoluteOffset = {
            left: i.left - o,
            top: i.top - n
          };
        }
      }

      void 0 === this.unwatch && (this.unwatch = this.$watch(function () {
        return e.$q.screen.width + "|" + e.$q.screen.height;
      }, this.updatePosition)), this.$el.dispatchEvent(create("popup-show", {
        bubbles: !0
      })), !0 !== this.noFocus && null !== document.activeElement && document.activeElement.blur(), this.__nextTick(function () {
        e.updatePosition(), !0 !== e.noFocus && e.focus();
      }), this.__setTimeout(function () {
        !0 === e.$q.platform.is.ios && (e.__avoidAutoClose = e.autoClose, e.__portal.$el.click()), e.updatePosition(), e.$emit("show", t);
      }, 300);
    },
    __hide: function __hide(t) {
      var e = this;
      this.__anchorCleanup(!0), void 0 === this.__refocusTarget || null === this.__refocusTarget || void 0 !== t && !0 === t.qClickOutside || this.__refocusTarget.focus(), this.$el.dispatchEvent(create("popup-hide", {
        bubbles: !0
      })), this.__setTimeout(function () {
        e.__hidePortal(), e.$emit("hide", t);
      }, 300);
    },
    __anchorCleanup: function __anchorCleanup(t) {
      this.absoluteOffset = void 0, void 0 !== this.unwatch && (this.unwatch(), this.unwatch = void 0), !0 !== t && !0 !== this.showing || (EscapeKey.pop(this), this.__unconfigureScrollTarget());
    },
    __unconfigureScrollTarget: function __unconfigureScrollTarget() {
      void 0 !== this.__scrollTarget && (this.__changeScrollEvent(this.__scrollTarget), this.__scrollTarget = void 0);
    },
    __configureScrollTarget: function __configureScrollTarget() {
      void 0 === this.anchorEl && void 0 === this.scrollTarget || (this.__scrollTarget = getScrollTarget(this.anchorEl, this.scrollTarget), this.__changeScrollEvent(this.__scrollTarget, this.updatePosition));
    },
    __onAutoClose: function __onAutoClose(t) {
      !0 !== this.__avoidAutoClose ? (closePortalMenus(this, t), void 0 !== this.qListeners.click && this.$emit("click", t)) : this.__avoidAutoClose = !1;
    },
    updatePosition: function updatePosition() {
      if (void 0 !== this.anchorEl && void 0 !== this.__portal) {
        var t = this.__portal.$el;
        8 !== t.nodeType ? setPosition({
          el: t,
          offset: this.offset,
          anchorEl: this.anchorEl,
          anchorOrigin: this.anchorOrigin,
          selfOrigin: this.selfOrigin,
          absoluteOffset: this.absoluteOffset,
          fit: this.fit,
          cover: this.cover,
          maxHeight: this.maxHeight,
          maxWidth: this.maxWidth
        }) : setTimeout(this.updatePosition, 25);
      }
    },
    __onClickOutside: function __onClickOutside(t) {
      if (!0 !== this.persistent && !0 === this.showing) {
        var e = t.target.classList;
        return this.hide(t), ("touchstart" === t.type || e.contains("q-dialog__backdrop")) && stopAndPrevent(t), !0;
      }
    },
    __renderPortal: function __renderPortal(t) {
      return t("transition", {
        props: {
          name: this.transition
        }
      }, [!0 === this.showing ? t("div", {
        ref: "inner",
        staticClass: "q-menu q-position-engine scroll" + this.menuClass,
        class: this.contentClass,
        style: this.contentStyle,
        attrs: this.attrs,
        on: this.onEvents,
        directives: [{
          name: "click-outside",
          value: this.__onClickOutside,
          arg: this.anchorEl
        }]
      }, slot(this, "default")) : null]);
    }
  },
  mounted: function mounted() {
    this.__processModelChange(this.value);
  },
  beforeDestroy: function beforeDestroy() {
    !0 === this.showing && void 0 !== this.anchorEl && this.anchorEl.dispatchEvent(create("popup-hide", {
      bubbles: !0
    }));
  }
}),
    QBtnDropdown = vue_runtime_esm["a" /* default */].extend({
  name: "QBtnDropdown",
  mixins: [BtnMixin],
  props: {
    value: Boolean,
    split: Boolean,
    dropdownIcon: String,
    contentClass: [Array, String, Object],
    contentStyle: [Array, String, Object],
    cover: Boolean,
    persistent: Boolean,
    autoClose: Boolean,
    menuAnchor: {
      type: String,
      default: "bottom right"
    },
    menuSelf: {
      type: String,
      default: "top right"
    },
    menuOffset: Array,
    disableMainBtn: Boolean,
    disableDropdown: Boolean
  },
  data: function data() {
    return {
      showing: this.value
    };
  },
  watch: {
    value: function value(t) {
      void 0 !== this.$refs.menu && this.$refs.menu[t ? "show" : "hide"]();
    }
  },
  render: function render(t) {
    var e = this,
        i = slot(this, "label", []),
        s = {
      "aria-expanded": !0 === this.showing ? "true" : "false",
      "aria-haspopup": !0
    };
    (!0 === this.disable || !1 === this.split && !0 === this.disableMainBtn || !0 === this.disableDropdown) && (s["aria-disabled"] = "");
    var n = [t(QIcon, {
      props: {
        name: this.dropdownIcon || this.$q.iconSet.arrow.dropdown
      },
      staticClass: "q-btn-dropdown__arrow",
      class: {
        "rotate-180": this.showing,
        "q-btn-dropdown__arrow-container": !1 === this.split
      }
    })];
    if (!0 !== this.disableDropdown && n.push(t(QMenu, {
      ref: "menu",
      props: {
        cover: this.cover,
        fit: !0,
        persistent: this.persistent,
        autoClose: this.autoClose,
        anchor: this.menuAnchor,
        self: this.menuSelf,
        offset: this.menuOffset,
        contentClass: this.contentClass,
        contentStyle: this.contentStyle,
        separateClosePopup: !0
      },
      on: cache(this, "menu", {
        "before-show": function beforeShow(t) {
          e.showing = !0, e.$emit("before-show", t);
        },
        show: function show(t) {
          e.$emit("show", t), e.$emit("input", !0);
        },
        "before-hide": function beforeHide(t) {
          e.showing = !1, e.$emit("before-hide", t);
        },
        hide: function hide(t) {
          e.$emit("hide", t), e.$emit("input", !1);
        }
      })
    }, slot(this, "default"))), !1 === this.split) return t(QBtn, {
      class: "q-btn-dropdown q-btn-dropdown--simple",
      props: Object.assign({}, this.$props, {
        disable: !0 === this.disable || !0 === this.disableMainBtn,
        noWrap: !0,
        round: !1
      }),
      attrs: s,
      on: cache(this, "nonSpl", {
        click: function click(t) {
          e.$emit("click", t);
        }
      })
    }, i.concat(n));
    var o = t(QBtn, {
      class: "q-btn-dropdown--current",
      props: Object.assign({}, this.$props, {
        disable: !0 === this.disable || !0 === this.disableMainBtn,
        noWrap: !0,
        iconRight: this.iconRight,
        round: !1
      }),
      on: cache(this, "spl", {
        click: function click(t) {
          e.hide(), e.$emit("click", t);
        }
      })
    }, i);
    return t(QBtnGroup, {
      props: {
        outline: this.outline,
        flat: this.flat,
        rounded: this.rounded,
        push: this.push,
        unelevated: this.unelevated,
        glossy: this.glossy,
        stretch: this.stretch
      },
      staticClass: "q-btn-dropdown q-btn-dropdown--split no-wrap q-btn-item"
    }, [o, t(QBtn, {
      staticClass: "q-btn-dropdown__arrow-container",
      attrs: s,
      props: {
        disable: !0 === this.disable || !0 === this.disableDropdown,
        outline: this.outline,
        flat: this.flat,
        rounded: this.rounded,
        push: this.push,
        size: this.size,
        color: this.color,
        textColor: this.textColor,
        dense: this.dense,
        ripple: this.ripple
      }
    }, n)]);
  },
  methods: {
    toggle: function toggle(t) {
      this.$refs.menu && this.$refs.menu.toggle(t);
    },
    show: function show(t) {
      this.$refs.menu && this.$refs.menu.show(t);
    },
    hide: function hide(t) {
      this.$refs.menu && this.$refs.menu.hide(t);
    }
  },
  mounted: function mounted() {
    !0 === this.value && this.show();
  }
}),
    FormMixin = {
  props: {
    name: String
  },
  computed: {
    formAttrs: function formAttrs() {
      return {
        type: "hidden",
        name: this.name,
        value: this.value
      };
    }
  },
  methods: {
    __injectFormInput: function __injectFormInput(t, e, i) {
      t[e](this.$createElement("input", {
        staticClass: "hidden",
        class: i,
        attrs: this.formAttrs,
        domProps: this.formDomProps
      }));
    }
  }
},
    FormFieldMixin = {
  props: {
    name: String
  },
  computed: {
    nameProp: function nameProp() {
      return this.name || this.for;
    }
  }
},
    QBtnToggle = vue_runtime_esm["a" /* default */].extend({
  name: "QBtnToggle",
  mixins: [ListenersMixin, RippleMixin, FormMixin],
  props: {
    value: {
      required: !0
    },
    options: {
      type: Array,
      required: !0,
      validator: function validator(t) {
        return t.every(function (t) {
          return ("label" in t || "icon" in t || "slot" in t) && "value" in t;
        });
      }
    },
    color: String,
    textColor: String,
    toggleColor: {
      type: String,
      default: "primary"
    },
    toggleTextColor: String,
    outline: Boolean,
    flat: Boolean,
    unelevated: Boolean,
    rounded: Boolean,
    push: Boolean,
    glossy: Boolean,
    size: String,
    noCaps: Boolean,
    noWrap: Boolean,
    dense: Boolean,
    readonly: Boolean,
    disable: Boolean,
    stack: Boolean,
    stretch: Boolean,
    spread: Boolean,
    clearable: Boolean
  },
  computed: {
    hasActiveValue: function hasActiveValue() {
      var t = this;
      return void 0 !== this.options.find(function (e) {
        return e.value === t.value;
      });
    },
    formAttrs: function formAttrs() {
      return {
        type: "hidden",
        name: this.name,
        value: this.value
      };
    }
  },
  methods: {
    __set: function __set(t, e) {
      !0 !== this.readonly && (this.value === t ? !0 === this.clearable && (this.$emit("input", null, null), this.$emit("clear")) : this.$emit("input", t, e));
    }
  },
  render: function render(t) {
    var e = this,
        i = this.options.map(function (i, s) {
      return t(QBtn, {
        key: s,
        on: {
          click: function click() {
            return e.__set(i.value, i);
          }
        },
        props: {
          disable: e.disable || i.disable,
          label: i.label,
          color: i.value === e.value ? i.toggleColor || e.toggleColor : i.color || e.color,
          textColor: i.value === e.value ? i.toggleTextColor || e.toggleTextColor : i.textColor || e.textColor,
          icon: i.icon,
          iconRight: i.iconRight,
          noCaps: !0 === e.noCaps || !0 === i.noCaps,
          noWrap: !0 === e.noWrap || !0 === i.noWrap,
          outline: e.outline,
          flat: e.flat,
          rounded: e.rounded,
          push: e.push,
          unelevated: e.unelevated,
          size: e.size,
          dense: e.dense,
          ripple: void 0 !== e.ripple ? e.ripple : i.ripple,
          stack: !0 === e.stack || !0 === i.stack,
          tabindex: i.tabindex,
          stretch: e.stretch
        }
      }, void 0 !== i.slot ? slot(e, i.slot) : void 0);
    });
    return void 0 !== this.name && !0 !== this.disable && !0 === this.hasActiveValue && this.__injectFormInput(i, "push"), t(QBtnGroup, {
      staticClass: "q-btn-toggle",
      props: {
        outline: this.outline,
        flat: this.flat,
        rounded: this.rounded,
        push: this.push,
        stretch: this.stretch,
        unelevated: this.unelevated,
        glossy: this.glossy,
        spread: this.spread
      },
      on: Object.assign({}, this.qListeners)
    }, i);
  }
}),
    QCard = vue_runtime_esm["a" /* default */].extend({
  name: "QCard",
  mixins: [ListenersMixin, DarkMixin, TagMixin],
  props: {
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-card" + (!0 === this.isDark ? " q-card--dark q-dark" : "") + (!0 === this.bordered ? " q-card--bordered" : "") + (!0 === this.square ? " q-card--square no-border-radius" : "") + (!0 === this.flat ? " q-card--flat no-shadow" : "");
    }
  },
  render: function render(t) {
    return t(this.tag, {
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QCardSection = vue_runtime_esm["a" /* default */].extend({
  name: "QCardSection",
  mixins: [ListenersMixin, TagMixin],
  props: {
    horizontal: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-card__section q-card__section--" + (!0 === this.horizontal ? "horiz row no-wrap" : "vert");
    }
  },
  render: function render(t) {
    return t(this.tag, {
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QCardActions = vue_runtime_esm["a" /* default */].extend({
  name: "QCardActions",
  mixins: [ListenersMixin, AlignMixin],
  props: {
    vertical: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-card__actions--" + (!0 === this.vertical ? "vert column" : "horiz row") + " " + this.alignClass;
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-card__actions",
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
});

function parseArg(t) {
  var e = [.06, 6, 50];
  return "string" == typeof t && t.length && t.split(":").forEach(function (t, i) {
    var s = parseFloat(t);
    s && (e[i] = s);
  }), e;
}

var TouchSwipe = {
  name: "touch-swipe",
  bind: function bind(t, e) {
    var i = e.value,
        s = e.arg,
        n = e.modifiers;

    if (!0 === n.mouse || !0 === client.has.touch) {
      var o = !0 === n.mouseCapture ? "Capture" : "",
          r = {
        handler: i,
        sensitivity: parseArg(s),
        modifiers: n,
        direction: getModifierDirections(n),
        noop: noop,
        mouseStart: function mouseStart(t) {
          shouldStart(t, r) && leftClick(t) && (addEvt(r, "temp", [[document, "mousemove", "move", "notPassive" + o], [document, "mouseup", "end", "notPassiveCapture"]]), r.start(t, !0));
        },
        touchStart: function touchStart(t) {
          if (shouldStart(t, r)) {
            var e = getTouchTarget(t.target);
            addEvt(r, "temp", [[e, "touchmove", "move", "notPassiveCapture"], [e, "touchcancel", "end", "notPassiveCapture"], [e, "touchend", "end", "notPassiveCapture"]]), r.start(t);
          }
        },
        start: function start(e, i) {
          !0 === client.is.firefox && preventDraggable(t, !0);
          var s = position(e);
          r.event = {
            x: s.left,
            y: s.top,
            time: Date.now(),
            mouse: !0 === i,
            dir: !1
          };
        },
        move: function move(t) {
          if (void 0 !== r.event) if (!1 === r.event.dir) {
            var e = Date.now() - r.event.time;

            if (0 !== e) {
              var i = position(t),
                  s = i.left - r.event.x,
                  n = Math.abs(s),
                  o = i.top - r.event.y,
                  a = Math.abs(o);

              if (!0 !== r.event.mouse) {
                if (n < r.sensitivity[1] && a < r.sensitivity[1]) return void r.end(t);
              } else if (n < r.sensitivity[2] && a < r.sensitivity[2]) return;

              var l = n / e,
                  c = a / e;
              !0 === r.direction.vertical && n < a && n < 100 && c > r.sensitivity[0] && (r.event.dir = o < 0 ? "up" : "down"), !0 === r.direction.horizontal && n > a && a < 100 && l > r.sensitivity[0] && (r.event.dir = s < 0 ? "left" : "right"), !0 === r.direction.up && n < a && o < 0 && n < 100 && c > r.sensitivity[0] && (r.event.dir = "up"), !0 === r.direction.down && n < a && o > 0 && n < 100 && c > r.sensitivity[0] && (r.event.dir = "down"), !0 === r.direction.left && n > a && s < 0 && a < 100 && l > r.sensitivity[0] && (r.event.dir = "left"), !0 === r.direction.right && n > a && s > 0 && a < 100 && l > r.sensitivity[0] && (r.event.dir = "right"), !1 !== r.event.dir ? (stopAndPrevent(t), !0 === r.event.mouse && (document.body.classList.add("no-pointer-events--children"), document.body.classList.add("non-selectable"), clearSelection(), r.styleCleanup = function (t) {
                r.styleCleanup = void 0, document.body.classList.remove("non-selectable");

                var e = function e() {
                  document.body.classList.remove("no-pointer-events--children");
                };

                !0 === t ? setTimeout(e, 50) : e();
              }), r.handler({
                evt: t,
                touch: !0 !== r.event.mouse,
                mouse: r.event.mouse,
                direction: r.event.dir,
                duration: e,
                distance: {
                  x: n,
                  y: a
                }
              })) : r.end(t);
            }
          } else stopAndPrevent(t);
        },
        end: function end(e) {
          void 0 !== r.event && (cleanEvt(r, "temp"), !0 === client.is.firefox && preventDraggable(t, !1), void 0 !== r.styleCleanup && r.styleCleanup(!0), void 0 !== e && !1 !== r.event.dir && stopAndPrevent(e), r.event = void 0);
        }
      };
      t.__qtouchswipe && (t.__qtouchswipe_old = t.__qtouchswipe), t.__qtouchswipe = r, !0 === n.mouse && addEvt(r, "main", [[t, "mousedown", "mouseStart", "passive" + o]]), !0 === client.has.touch && addEvt(r, "main", [[t, "touchstart", "touchStart", "passive" + (!0 === n.capture ? "Capture" : "")], [t, "touchmove", "noop", "notPassiveCapture"]]);
    }
  },
  update: function update(t, e) {
    void 0 !== t.__qtouchswipe && updateModifiers(t.__qtouchswipe, e);
  },
  unbind: function unbind(t) {
    var e = t.__qtouchswipe_old || t.__qtouchswipe;
    void 0 !== e && (cleanEvt(e, "main"), cleanEvt(e, "temp"), !0 === client.is.firefox && preventDraggable(t, !1), void 0 !== e.styleCleanup && e.styleCleanup(), delete t[t.__qtouchswipe_old ? "__qtouchswipe_old" : "__qtouchswipe"]);
  }
},
    PanelWrapper = vue_runtime_esm["a" /* default */].extend({
  name: "QTabPanelWrapper",
  render: function render(t) {
    return t("div", {
      staticClass: "q-panel scroll",
      attrs: {
        role: "tabpanel"
      },
      on: cache(this, "stop", {
        input: stop
      })
    }, slot(this, "default"));
  }
}),
    PanelParentMixin = {
  mixins: [ListenersMixin],
  directives: {
    TouchSwipe: TouchSwipe
  },
  props: {
    value: {
      required: !0
    },
    animated: Boolean,
    infinite: Boolean,
    swipeable: Boolean,
    vertical: Boolean,
    transitionPrev: String,
    transitionNext: String,
    keepAlive: Boolean
  },
  data: function data() {
    return {
      panelIndex: null,
      panelTransition: null
    };
  },
  computed: {
    panelDirectives: function panelDirectives() {
      if (!0 === this.swipeable) return [{
        name: "touch-swipe",
        value: this.__swipe,
        modifiers: {
          horizontal: !0 !== this.vertical,
          vertical: this.vertical,
          mouse: !0
        }
      }];
    },
    contentKey: function contentKey() {
      return "string" == typeof this.value || "number" == typeof this.value ? this.value : String(this.value);
    },
    transitionPrevComputed: function transitionPrevComputed() {
      return this.transitionPrev || "slide-" + (!0 === this.vertical ? "down" : "right");
    },
    transitionNextComputed: function transitionNextComputed() {
      return this.transitionNext || "slide-" + (!0 === this.vertical ? "up" : "left");
    }
  },
  watch: {
    value: function value(t, e) {
      var i = this,
          s = !0 === this.__isValidPanelName(t) ? this.__getPanelIndex(t) : -1;
      !0 !== this.__forcedPanelTransition && this.__updatePanelTransition(-1 === s ? 0 : s < this.__getPanelIndex(e) ? -1 : 1), this.panelIndex !== s && (this.panelIndex = s, this.$emit("before-transition", t, e), this.$nextTick(function () {
        i.$emit("transition", t, e);
      }));
    }
  },
  methods: {
    next: function next() {
      this.__go(1);
    },
    previous: function previous() {
      this.__go(-1);
    },
    goTo: function goTo(t) {
      this.$emit("input", t);
    },
    __isValidPanelName: function __isValidPanelName(t) {
      return void 0 !== t && null !== t && "" !== t;
    },
    __getPanelIndex: function __getPanelIndex(t) {
      return this.panels.findIndex(function (e) {
        var i = e.componentOptions;
        return i && i.propsData.name === t && "" !== i.propsData.disable && !0 !== i.propsData.disable;
      });
    },
    __getAllPanels: function __getAllPanels() {
      var t = this;
      return this.panels.filter(function (e) {
        return void 0 !== e.componentOptions && t.__isValidPanelName(e.componentOptions.propsData.name);
      });
    },
    __getAvailablePanels: function __getAvailablePanels() {
      return this.panels.filter(function (t) {
        var e = t.componentOptions;
        return e && void 0 !== e.propsData.name && "" !== e.propsData.disable && !0 !== e.propsData.disable;
      });
    },
    __updatePanelTransition: function __updatePanelTransition(t) {
      var e = 0 !== t && !0 === this.animated && -1 !== this.panelIndex ? "q-transition--" + (-1 === t ? this.transitionPrevComputed : this.transitionNextComputed) : null;
      this.panelTransition !== e && (this.panelTransition = e);
    },
    __go: function __go(t, e) {
      var i = this;
      void 0 === e && (e = this.panelIndex);

      for (var s = e + t, n = this.panels; s > -1 && s < n.length;) {
        var o = n[s].componentOptions;
        if (void 0 !== o && "" !== o.propsData.disable && !0 !== o.propsData.disable) return this.__updatePanelTransition(t), this.__forcedPanelTransition = !0, this.$emit("input", n[s].componentOptions.propsData.name), void setTimeout(function () {
          i.__forcedPanelTransition = !1;
        });
        s += t;
      }

      !0 === this.infinite && n.length > 0 && -1 !== e && e !== n.length && this.__go(t, -1 === t ? n.length : -1);
    },
    __swipe: function __swipe(t) {
      var e = !0 === this.vertical ? "up" : "left";

      this.__go((!0 === this.$q.lang.rtl ? -1 : 1) * (t.direction === e ? 1 : -1));
    },
    __updatePanelIndex: function __updatePanelIndex() {
      var t = this.__getPanelIndex(this.value);

      return this.panelIndex !== t && (this.panelIndex = t), !0;
    },
    __getPanelContent: function __getPanelContent(t) {
      if (0 !== this.panels.length) {
        var e = this.__isValidPanelName(this.value) && this.__updatePanelIndex() && this.panels[this.panelIndex],
            i = !0 === this.keepAlive ? [t("keep-alive", [t(PanelWrapper, {
          key: this.contentKey
        }, [e])])] : [t("div", {
          staticClass: "q-panel scroll",
          key: this.contentKey,
          attrs: {
            role: "tabpanel"
          },
          on: cache(this, "stop", {
            input: stop
          })
        }, [e])];
        return !0 === this.animated ? [t("transition", {
          props: {
            name: this.panelTransition
          }
        }, i)] : i;
      }
    }
  },
  render: function render(t) {
    return this.panels = slot(this, "default", []), this.__renderPanels(t);
  }
},
    PanelChildMixin = {
  mixins: [ListenersMixin],
  props: {
    name: {
      required: !0
    },
    disable: Boolean
  }
},
    FullscreenMixin = {
  props: {
    fullscreen: Boolean,
    noRouteFullscreenExit: Boolean
  },
  data: function data() {
    return {
      inFullscreen: !1
    };
  },
  watch: {
    $route: function $route() {
      !0 !== this.noRouteFullscreenExit && this.exitFullscreen();
    },
    fullscreen: function fullscreen(t) {
      this.inFullscreen !== t && this.toggleFullscreen();
    },
    inFullscreen: function inFullscreen(t) {
      this.$emit("update:fullscreen", t), this.$emit("fullscreen", t);
    }
  },
  methods: {
    toggleFullscreen: function toggleFullscreen() {
      !0 === this.inFullscreen ? this.exitFullscreen() : this.setFullscreen();
    },
    setFullscreen: function setFullscreen() {
      !0 !== this.inFullscreen && (this.inFullscreen = !0, this.container = this.$el.parentNode, this.container.replaceChild(this.fullscreenFillerNode, this.$el), document.body.appendChild(this.$el), document.body.classList.add("q-body--fullscreen-mixin"), this.__historyFullscreen = {
        handler: this.exitFullscreen
      }, History.add(this.__historyFullscreen));
    },
    exitFullscreen: function exitFullscreen() {
      var t = this;
      !0 === this.inFullscreen && (void 0 !== this.__historyFullscreen && (History.remove(this.__historyFullscreen), this.__historyFullscreen = void 0), this.container.replaceChild(this.$el, this.fullscreenFillerNode), document.body.classList.remove("q-body--fullscreen-mixin"), this.inFullscreen = !1, void 0 !== this.$el.scrollIntoView && setTimeout(function () {
        t.$el.scrollIntoView();
      }));
    }
  },
  beforeMount: function beforeMount() {
    this.fullscreenFillerNode = document.createElement("span");
  },
  mounted: function mounted() {
    !0 === this.fullscreen && this.setFullscreen();
  },
  beforeDestroy: function beforeDestroy() {
    this.exitFullscreen();
  }
},
    hasMap = "function" == typeof Map,
    hasSet = "function" == typeof Set,
    hasArrayBuffer = "function" == typeof ArrayBuffer;

function isDeepEqual(t, e) {
  if (t === e) return !0;

  if (null !== t && null !== e && "object" == typeof_default()(t) && "object" == typeof_default()(e)) {
    if (t.constructor !== e.constructor) return !1;
    var i, s, n;

    if (t.constructor === Array) {
      if ((i = t.length) !== e.length) return !1;

      for (s = i; 0 != s--;) {
        if (!0 !== isDeepEqual(t[s], e[s])) return !1;
      }

      return !0;
    }

    if (!0 === hasMap && t.constructor === Map) {
      if (t.size !== e.size) return !1;

      for (s = t.entries().next(); !0 !== s.done;) {
        if (!0 !== e.has(s.value[0])) return !1;
        s = s.next();
      }

      for (s = t.entries().next(); !0 !== s.done;) {
        if (!0 !== isDeepEqual(s.value[1], e.get(s.value[0]))) return !1;
        s = s.next();
      }

      return !0;
    }

    if (!0 === hasSet && t.constructor === Set) {
      if (t.size !== e.size) return !1;

      for (s = t.entries().next(); !0 !== s.done;) {
        if (!0 !== e.has(s.value[0])) return !1;
        s = s.next();
      }

      return !0;
    }

    if (!0 === hasArrayBuffer && null != t.buffer && t.buffer.constructor === ArrayBuffer) {
      if ((i = t.length) !== e.length) return !1;

      for (s = i; 0 != s--;) {
        if (t[s] !== e[s]) return !1;
      }

      return !0;
    }

    if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === e.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === e.toString();
    if ((i = (n = Object.keys(t)).length) !== Object.keys(e).length) return !1;

    for (s = i; 0 != s--;) {
      var o = n[s];
      if (!0 !== isDeepEqual(t[o], e[o])) return !1;
    }

    return !0;
  }

  return t != t && e != e;
}

function isDate(t) {
  return "[object Date]" === Object.prototype.toString.call(t);
}

function isNumber(t) {
  return "number" == typeof t && isFinite(t);
}

var QCarousel = vue_runtime_esm["a" /* default */].extend({
  name: "QCarousel",
  mixins: [DarkMixin, PanelParentMixin, FullscreenMixin],
  props: {
    height: String,
    padding: Boolean,
    controlType: {
      type: String,
      validator: function validator(t) {
        return ["regular", "flat", "outline", "push", "unelevated"].includes(t);
      },
      default: "flat"
    },
    controlColor: String,
    controlTextColor: String,
    autoplay: [Number, Boolean],
    arrows: Boolean,
    prevIcon: String,
    nextIcon: String,
    navigation: Boolean,
    navigationPosition: {
      type: String,
      validator: function validator(t) {
        return ["top", "right", "bottom", "left"].includes(t);
      }
    },
    navigationIcon: String,
    thumbnails: Boolean
  },
  computed: {
    style: function style() {
      if (!0 !== this.inFullscreen && void 0 !== this.height) return {
        height: this.height
      };
    },
    direction: function direction() {
      return !0 === this.vertical ? "vertical" : "horizontal";
    },
    classes: function classes() {
      return "q-carousel q-panel-parent q-carousel--with" + (!0 === this.padding ? "" : "out") + "-padding" + (!0 === this.inFullscreen ? " fullscreen" : "") + (!0 === this.isDark ? " q-carousel--dark q-dark" : "") + (!0 === this.arrows ? " q-carousel--arrows-" + this.direction : "") + (!0 === this.navigation ? " q-carousel--navigation-" + this.navigationPositionComputed : "");
    },
    arrowIcons: function arrowIcons() {
      var t = [this.prevIcon || this.$q.iconSet.carousel[!0 === this.vertical ? "up" : "left"], this.nextIcon || this.$q.iconSet.carousel[!0 === this.vertical ? "down" : "right"]];
      return !1 === this.vertical && !0 === this.$q.lang.rtl ? t.reverse() : t;
    },
    navIcon: function navIcon() {
      return this.navigationIcon || this.$q.iconSet.carousel.navigationIcon;
    },
    navigationPositionComputed: function navigationPositionComputed() {
      return this.navigationPosition || (!0 === this.vertical ? "right" : "bottom");
    },
    controlProps: function controlProps() {
      var t;
      return (t = {
        color: this.controlColor,
        textColor: this.controlTextColor,
        round: !0
      })[this.controlType] = !0, t.dense = !0, t;
    },
    transitionPrevComputed: function transitionPrevComputed() {
      return this.transitionPrev || "fade";
    },
    transitionNextComputed: function transitionNextComputed() {
      return this.transitionNext || "fade";
    }
  },
  watch: {
    value: function value() {
      this.autoplay && (clearInterval(this.timer), this.__startTimer());
    },
    autoplay: function autoplay(t) {
      t ? this.__startTimer() : clearInterval(this.timer);
    }
  },
  methods: {
    __startTimer: function __startTimer() {
      this.timer = setTimeout(this.next, isNumber(this.autoplay) ? this.autoplay : 5e3);
    },
    __getNavigationContainer: function __getNavigationContainer(t, e, i) {
      return t("div", {
        class: "q-carousel__control q-carousel__navigation no-wrap absolute flex q-carousel__navigation--" + e + " q-carousel__navigation--" + this.navigationPositionComputed + (void 0 !== this.controlColor ? " text-" + this.controlColor : "")
      }, [t("div", {
        staticClass: "q-carousel__navigation-inner flex no-wrap justify-center"
      }, this.__getAvailablePanels().map(i))]);
    },
    __getContent: function __getContent(t) {
      var e = this,
          i = [];
      if (!0 === this.navigation) i.push(this.__getNavigationContainer(t, "buttons", function (i) {
        var s = i.componentOptions.propsData.name;
        return t(QBtn, {
          key: s,
          class: "q-carousel__navigation-icon q-carousel__navigation-icon--" + (s === e.value ? "" : "in") + "active",
          props: Object.assign({
            icon: e.navIcon,
            size: "sm"
          }, e.controlProps),
          on: cache(e, "nav#" + s, {
            click: function click() {
              e.goTo(s);
            }
          })
        });
      }));else if (!0 === this.thumbnails) {
        var s = void 0 !== this.controlColor ? " text-" + this.controlColor : "";
        i.push(this.__getNavigationContainer(t, "thumbnails", function (i) {
          var n = i.componentOptions.propsData;
          return t("img", {
            class: "q-carousel__thumbnail q-carousel__thumbnail--" + (n.name === e.value ? "" : "in") + "active" + s,
            attrs: {
              src: n.imgSrc
            },
            key: "tmb#" + n.name,
            on: cache(e, "tmb#" + n.name, {
              click: function click() {
                e.goTo(n.name);
              }
            })
          });
        }));
      }
      return !0 === this.arrows && i.push(t("div", {
        staticClass: "q-carousel__control q-carousel__arrow q-carousel__prev-arrow q-carousel__prev-arrow--" + this.direction + " absolute flex flex-center"
      }, [t(QBtn, {
        props: Object.assign({}, {
          icon: this.arrowIcons[0]
        }, this.controlProps),
        on: cache(this, "prev", {
          click: this.previous
        })
      })]), t("div", {
        staticClass: "q-carousel__control q-carousel__arrow q-carousel__next-arrow q-carousel__next-arrow--" + this.direction + " absolute flex flex-center"
      }, [t(QBtn, {
        props: Object.assign({}, {
          icon: this.arrowIcons[1]
        }, this.controlProps),
        on: cache(this, "next", {
          click: this.next
        })
      })])), mergeSlot(i, this, "control");
    },
    __renderPanels: function __renderPanels(t) {
      return t("div", {
        style: this.style,
        class: this.classes,
        on: Object.assign({}, this.qListeners)
      }, [t("div", {
        staticClass: "q-carousel__slides-container",
        directives: this.panelDirectives
      }, this.__getPanelContent(t))].concat(this.__getContent(t)));
    }
  },
  mounted: function mounted() {
    this.autoplay && this.__startTimer();
  },
  beforeDestroy: function beforeDestroy() {
    clearInterval(this.timer);
  }
}),
    QCarouselSlide = vue_runtime_esm["a" /* default */].extend({
  name: "QCarouselSlide",
  mixins: [PanelChildMixin],
  props: {
    imgSrc: String
  },
  computed: {
    style: function style() {
      if (this.imgSrc) return {
        backgroundImage: 'url("' + this.imgSrc + '")'
      };
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-carousel__slide",
      style: this.style,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QCarouselControl = vue_runtime_esm["a" /* default */].extend({
  name: "QCarouselControl",
  mixins: [ListenersMixin],
  props: {
    position: {
      type: String,
      default: "bottom-right",
      validator: function validator(t) {
        return ["top-right", "top-left", "bottom-right", "bottom-left", "top", "right", "bottom", "left"].includes(t);
      }
    },
    offset: {
      type: Array,
      default: function _default() {
        return [18, 18];
      },
      validator: function validator(t) {
        return 2 === t.length;
      }
    }
  },
  computed: {
    classes: function classes() {
      return "absolute-" + this.position;
    },
    style: function style() {
      return {
        margin: this.offset[1] + "px " + this.offset[0] + "px"
      };
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-carousel__control absolute",
      style: this.style,
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QChatMessage = vue_runtime_esm["a" /* default */].extend({
  name: "QChatMessage",
  mixins: [ListenersMixin],
  props: {
    sent: Boolean,
    label: String,
    bgColor: String,
    textColor: String,
    name: String,
    avatar: String,
    text: Array,
    stamp: String,
    size: String,
    labelSanitize: Boolean,
    nameSanitize: Boolean,
    textSanitize: Boolean,
    stampSanitize: Boolean
  },
  computed: {
    textClass: function textClass() {
      return "q-message-text-content q-message-text-content--" + this.op + (void 0 !== this.textColor ? " text-" + this.textColor : "");
    },
    messageClass: function messageClass() {
      return "q-message-text q-message-text--" + this.op + (void 0 !== this.bgColor ? " text-" + this.bgColor : "");
    },
    containerClass: function containerClass() {
      return "q-message-container row items-end no-wrap" + (!0 === this.sent ? " reverse" : "");
    },
    sizeClass: function sizeClass() {
      if (void 0 !== this.size) return "col-" + this.size;
    },
    op: function op() {
      return !0 === this.sent ? "sent" : "received";
    }
  },
  methods: {
    __getText: function __getText(t) {
      var e = this,
          i = !0 === this.textSanitize ? "textContent" : "innerHTML",
          s = !0 === this.stampSanitize ? "textContent" : "innerHTML";
      return this.text.map(function (n, o) {
        var r, a;
        return t("div", {
          key: o,
          class: e.messageClass
        }, [t("div", {
          class: e.textClass
        }, [t("div", {
          domProps: (r = {}, r[i] = n, r)
        }), e.stamp ? t("div", {
          staticClass: "q-message-stamp",
          domProps: (a = {}, a[s] = e.stamp, a)
        }) : null])]);
      });
    },
    __getMessage: function __getMessage(t) {
      var e,
          i = uniqueSlot(this, "default", []);
      return void 0 !== this.stamp && i.push(t("div", {
        staticClass: "q-message-stamp",
        domProps: (e = {}, e[!0 === this.stampSanitize ? "textContent" : "innerHTML"] = this.stamp, e)
      })), t("div", {
        class: this.messageClass
      }, [t("div", {
        staticClass: "q-message-text-content",
        class: this.textClass
      }, i)]);
    }
  },
  render: function render(t) {
    var e,
        i,
        s = [];
    void 0 !== this.$scopedSlots.avatar ? s.push(this.$scopedSlots.avatar()) : void 0 !== this.avatar && s.push(t("img", {
      class: "q-message-avatar q-message-avatar--" + this.op,
      attrs: {
        src: this.avatar,
        "aria-hidden": "true"
      }
    }));
    var n = [];
    void 0 !== this.name && n.push(t("div", {
      class: "q-message-name q-message-name--" + this.op,
      domProps: (e = {}, e[!0 === this.nameSanitize ? "textContent" : "innerHTML"] = this.name, e)
    })), void 0 !== this.text && n.push(this.__getText(t)), void 0 !== this.$scopedSlots.default && n.push(this.__getMessage(t)), s.push(t("div", {
      class: this.sizeClass
    }, n));
    var o = [];
    return this.label && o.push(t("div", {
      staticClass: "q-message-label text-center",
      domProps: (i = {}, i[!0 === this.labelSanitize ? "textContent" : "innerHTML"] = this.label, i)
    })), o.push(t("div", {
      class: this.containerClass
    }, s)), t("div", {
      class: "q-message q-message-" + this.op,
      on: Object.assign({}, this.qListeners)
    }, o);
  }
}),
    OptionSizeMixin = getSizeMixin({
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
}),
    RefocusTargetMixin = {
  computed: {
    __refocusTargetEl: function __refocusTargetEl() {
      if (!0 !== this.disable) return this.$createElement("span", {
        ref: "refocusTarget",
        staticClass: "no-outline",
        attrs: {
          tabindex: -1
        }
      });
    }
  },
  methods: {
    __refocusTarget: function __refocusTarget(t) {
      void 0 !== t && 0 === t.type.indexOf("key") ? document.activeElement !== this.$el && !0 === this.$el.contains(document.activeElement) && this.$el.focus() : void 0 !== t && !0 !== this.$el.contains(t.target) || void 0 === this.$refs.refocusTarget || this.$refs.refocusTarget.focus();
    }
  }
},
    CheckboxMixin = {
  mixins: [DarkMixin, OptionSizeMixin, FormMixin, RefocusTargetMixin],
  props: {
    value: {
      required: !0,
      default: null
    },
    val: {},
    trueValue: {
      default: !0
    },
    falseValue: {
      default: !1
    },
    toggleIndeterminate: Boolean,
    indeterminateValue: {
      default: null
    },
    label: String,
    leftLabel: Boolean,
    fontSize: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  computed: {
    isTrue: function isTrue() {
      return !0 === this.modelIsArray ? this.index > -1 : this.value === this.trueValue;
    },
    isFalse: function isFalse() {
      return !0 === this.modelIsArray ? -1 === this.index : this.value === this.falseValue;
    },
    isIndeterminate: function isIndeterminate() {
      return this.value === this.indeterminateValue && this.value !== this.falseValue;
    },
    index: function index() {
      if (!0 === this.modelIsArray) return this.value.indexOf(this.val);
    },
    modelIsArray: function modelIsArray() {
      return void 0 !== this.val && Array.isArray(this.value);
    },
    computedTabindex: function computedTabindex() {
      return !0 === this.disable ? -1 : this.tabindex || 0;
    },
    labelStyle: function labelStyle() {
      if (void 0 !== this.fontSize) return {
        fontSize: this.fontSize
      };
    },
    classes: function classes() {
      return "q-" + this.type + " cursor-pointer no-outline row inline no-wrap items-center" + (!0 === this.disable ? " disabled" : "") + (!0 === this.isDark ? " q-" + this.type + "--dark" : "") + (!0 === this.dense ? " q-" + this.type + "--dense" : "") + (!0 === this.leftLabel ? " reverse" : "");
    },
    innerClass: function innerClass() {
      var t = !0 === this.isTrue ? "truthy" : !0 === this.isFalse ? "falsy" : "indet",
          e = void 0 === this.color || !0 !== this.keepColor && ("toggle" === this.type ? !0 !== this.isTrue : !0 === this.isFalse) ? "" : " text-" + this.color;
      return "q-" + this.type + "__inner--" + t + e;
    },
    formAttrs: function formAttrs() {
      var t = {
        type: "checkbox"
      };
      return void 0 !== this.name && Object.assign(t, {
        checked: this.isTrue,
        name: this.name,
        value: !0 === this.modelIsArray ? this.val : this.trueValue
      }), t;
    },
    attrs: function attrs() {
      var t = {
        tabindex: this.computedTabindex,
        role: "checkbox",
        "aria-label": this.label,
        "aria-checked": !0 === this.isIndeterminate ? "mixed" : !0 === this.isTrue ? "true" : "false"
      };
      return !0 === this.disable && (t["aria-disabled"] = ""), t;
    }
  },
  methods: {
    toggle: function toggle(t) {
      var e;
      (void 0 !== t && (stopAndPrevent(t), this.__refocusTarget(t)), !0 !== this.disable) && (!0 === this.modelIsArray ? !0 === this.isTrue ? (e = this.value.slice()).splice(this.index, 1) : e = this.value.concat([this.val]) : e = !0 === this.isTrue ? !0 === this.toggleIndeterminate ? this.indeterminateValue : this.falseValue : !0 === this.isFalse ? this.trueValue : this.falseValue, this.$emit("input", e, t));
    },
    __onKeydown: function __onKeydown(t) {
      13 !== t.keyCode && 32 !== t.keyCode || stopAndPrevent(t);
    },
    __onKeyup: function __onKeyup(t) {
      13 !== t.keyCode && 32 !== t.keyCode || this.toggle(t);
    }
  },
  render: function render(t) {
    var e = this.__getInner(t);

    !0 !== this.disable && this.__injectFormInput(e, "unshift", "q-" + this.type + "__native absolute q-ma-none q-pa-none invisible");
    var i = [t("div", {
      staticClass: "q-" + this.type + "__inner relative-position no-pointer-events",
      class: this.innerClass,
      style: this.sizeStyle
    }, e)];
    void 0 !== this.__refocusTargetEl && i.push(this.__refocusTargetEl);
    var s = void 0 !== this.label ? mergeSlot([this.label], this, "default") : slot(this, "default");
    return void 0 !== s && i.push(t("div", {
      staticClass: "q-" + this.type + "__label q-anchor--skip"
    }, s)), t("div", {
      class: this.classes,
      attrs: this.attrs,
      on: cache(this, "inpExt", {
        click: this.toggle,
        keydown: this.__onKeydown,
        keyup: this.__onKeyup
      })
    }, i);
  }
},
    QCheckbox = vue_runtime_esm["a" /* default */].extend({
  name: "QCheckbox",
  mixins: [CheckboxMixin],
  methods: {
    __getInner: function __getInner(t) {
      return [t("div", {
        staticClass: "q-checkbox__bg absolute"
      }, [t("svg", {
        staticClass: "q-checkbox__svg fit absolute-full",
        attrs: {
          focusable: "false",
          viewBox: "0 0 24 24"
        }
      }, [t("path", {
        staticClass: "q-checkbox__truthy",
        attrs: {
          fill: "none",
          d: "M1.73,12.91 8.1,19.28 22.79,4.59"
        }
      }), t("path", {
        staticClass: "q-checkbox__indet",
        attrs: {
          d: "M4,14H20V10H4"
        }
      })])])];
    }
  },
  created: function created() {
    this.type = "checkbox";
  }
}),
    QChip = vue_runtime_esm["a" /* default */].extend({
  name: "QChip",
  mixins: [RippleMixin, DarkMixin, getSizeMixin({
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  })],
  model: {
    event: "remove"
  },
  props: {
    dense: Boolean,
    icon: String,
    iconRight: String,
    iconRemove: String,
    label: [String, Number],
    color: String,
    textColor: String,
    value: {
      type: Boolean,
      default: !0
    },
    selected: {
      type: Boolean,
      default: null
    },
    square: Boolean,
    outline: Boolean,
    clickable: Boolean,
    removable: Boolean,
    tabindex: [String, Number],
    disable: Boolean
  },
  computed: {
    classes: function classes() {
      var t,
          e = !0 === this.outline && this.color || this.textColor;
      return (t = {})["bg-" + this.color] = !1 === this.outline && void 0 !== this.color, t["text-" + e + " q-chip--colored"] = e, t.disabled = this.disable, t["q-chip--dense"] = this.dense, t["q-chip--outline"] = this.outline, t["q-chip--selected"] = this.selected, t["q-chip--clickable cursor-pointer non-selectable q-hoverable"] = this.isClickable, t["q-chip--square"] = this.square, t["q-chip--dark q-dark"] = this.isDark, t;
    },
    hasLeftIcon: function hasLeftIcon() {
      return !0 === this.selected || void 0 !== this.icon;
    },
    isClickable: function isClickable() {
      return !1 === this.disable && (!0 === this.clickable || null !== this.selected);
    },
    attrs: function attrs() {
      return !0 === this.disable ? {
        tabindex: -1,
        "aria-disabled": ""
      } : {
        tabindex: this.tabindex || 0
      };
    }
  },
  methods: {
    __onKeyup: function __onKeyup(t) {
      13 === t.keyCode && this.__onClick(t);
    },
    __onClick: function __onClick(t) {
      this.disable || (this.$emit("update:selected", !this.selected), this.$emit("click", t));
    },
    __onRemove: function __onRemove(t) {
      void 0 !== t.keyCode && 13 !== t.keyCode || (stopAndPrevent(t), !this.disable && this.$emit("remove", !1));
    },
    __getContent: function __getContent(t) {
      var e = [];
      !0 === this.isClickable && e.push(t("div", {
        staticClass: "q-focus-helper"
      })), !0 === this.hasLeftIcon && e.push(t(QIcon, {
        staticClass: "q-chip__icon q-chip__icon--left",
        props: {
          name: !0 === this.selected ? this.$q.iconSet.chip.selected : this.icon
        }
      }));
      var i = void 0 !== this.label ? [t("div", {
        staticClass: "ellipsis"
      }, [this.label])] : void 0;
      return e.push(t("div", {
        staticClass: "q-chip__content col row no-wrap items-center q-anchor--skip"
      }, mergeSlotSafely(i, this, "default"))), this.iconRight && e.push(t(QIcon, {
        staticClass: "q-chip__icon q-chip__icon--right",
        props: {
          name: this.iconRight
        }
      })), !0 === this.removable && e.push(t(QIcon, {
        staticClass: "q-chip__icon q-chip__icon--remove cursor-pointer",
        props: {
          name: this.iconRemove || this.$q.iconSet.chip.remove
        },
        attrs: this.attrs,
        on: cache(this, "non", {
          click: this.__onRemove,
          keyup: this.__onRemove
        })
      })), e;
    }
  },
  render: function render(t) {
    if (!1 !== this.value) {
      var e = {
        staticClass: "q-chip row inline no-wrap items-center",
        class: this.classes,
        style: this.sizeStyle
      };
      return !0 === this.isClickable && Object.assign(e, {
        attrs: this.attrs,
        on: cache(this, "click", {
          click: this.__onClick,
          keyup: this.__onKeyup
        }),
        directives: cache(this, "dir#" + this.ripple, [{
          name: "ripple",
          value: this.ripple
        }])
      }), t("div", e, this.__getContent(t));
    }
  }
}),
    radius = 50,
    diameter = 2 * radius,
    circumference = diameter * Math.PI,
    strokeDashArray = Math.round(1e3 * circumference) / 1e3,
    QCircularProgress = vue_runtime_esm["a" /* default */].extend({
  name: "QCircularProgress",
  mixins: [ListenersMixin, SizeMixin],
  props: {
    value: {
      type: Number,
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    color: String,
    centerColor: String,
    trackColor: String,
    fontSize: String,
    thickness: {
      type: Number,
      default: .2,
      validator: function validator(t) {
        return t >= 0 && t <= 1;
      }
    },
    angle: {
      type: Number,
      default: 0
    },
    indeterminate: Boolean,
    showValue: Boolean,
    reverse: Boolean,
    instantFeedback: Boolean
  },
  computed: {
    normalizedValue: function normalizedValue() {
      return between(this.value, this.min, this.max);
    },
    svgStyle: function svgStyle() {
      return {
        transform: "rotate3d(0, 0, 1, " + (this.angle - 90) + "deg)"
      };
    },
    circleStyle: function circleStyle() {
      if (!0 !== this.instantFeedback && !0 !== this.indeterminate) return {
        transition: "stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease"
      };
    },
    dir: function dir() {
      return (!0 === this.$q.lang.rtl ? -1 : 1) * (this.reverse ? -1 : 1);
    },
    viewBox: function viewBox() {
      return diameter / (1 - this.thickness / 2);
    },
    viewBoxAttr: function viewBoxAttr() {
      return this.viewBox / 2 + " " + this.viewBox / 2 + " " + this.viewBox + " " + this.viewBox;
    },
    strokeDashOffset: function strokeDashOffset() {
      var t = 1 - (this.normalizedValue - this.min) / (this.max - this.min);
      return this.dir * t * circumference;
    },
    strokeWidth: function strokeWidth() {
      return this.thickness / 2 * this.viewBox;
    },
    attrs: function attrs() {
      return {
        role: "progressbar",
        "aria-valuemin": this.min,
        "aria-valuemax": this.max,
        "aria-valuenow": !0 === this.indeterminate ? void 0 : this.normalizedValue
      };
    }
  },
  methods: {
    __getCircle: function __getCircle(t, e) {
      var i = e.thickness,
          s = e.offset,
          n = e.color;
      return t("circle", {
        staticClass: "q-circular-progress__" + e.cls,
        class: void 0 !== n ? "text-" + n : null,
        style: this.circleStyle,
        attrs: {
          fill: "transparent",
          stroke: "currentColor",
          "stroke-width": i,
          "stroke-dasharray": strokeDashArray,
          "stroke-dashoffset": s,
          cx: this.viewBox,
          cy: this.viewBox,
          r: radius
        }
      });
    }
  },
  render: function render(t) {
    var e = [];
    void 0 !== this.centerColor && "transparent" !== this.centerColor && e.push(t("circle", {
      staticClass: "q-circular-progress__center",
      class: "text-" + this.centerColor,
      attrs: {
        fill: "currentColor",
        r: radius - this.strokeWidth / 2,
        cx: this.viewBox,
        cy: this.viewBox
      }
    })), void 0 !== this.trackColor && "transparent" !== this.trackColor && e.push(this.__getCircle(t, {
      cls: "track",
      thickness: this.strokeWidth,
      offset: 0,
      color: this.trackColor
    })), e.push(this.__getCircle(t, {
      cls: "circle",
      thickness: this.strokeWidth,
      offset: this.strokeDashOffset,
      color: this.color
    }));
    var i = [t("svg", {
      staticClass: "q-circular-progress__svg",
      style: this.svgStyle,
      attrs: {
        focusable: "false",
        viewBox: this.viewBoxAttr
      }
    }, e)];
    return !0 === this.showValue && i.push(t("div", {
      staticClass: "q-circular-progress__text absolute-full row flex-center content-center",
      style: {
        fontSize: this.fontSize
      }
    }, void 0 !== this.$scopedSlots.default ? this.$scopedSlots.default() : [t("div", [this.normalizedValue])])), t("div", {
      staticClass: "q-circular-progress",
      class: "q-circular-progress--" + (!0 === this.indeterminate ? "in" : "") + "determinate",
      style: this.sizeStyle,
      on: Object.assign({}, this.qListeners),
      attrs: this.attrs
    }, mergeSlotSafely(i, this, "internal"));
  }
}),
    hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/,
    hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/,
    hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/,
    rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/,
    rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/,
    testPattern = {
  date: function date(t) {
    return /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(t);
  },
  time: function time(t) {
    return /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(t);
  },
  fulltime: function fulltime(t) {
    return /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(t);
  },
  timeOrFulltime: function timeOrFulltime(t) {
    return /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(t);
  },
  hexColor: function hexColor(t) {
    return hex.test(t);
  },
  hexaColor: function hexaColor(t) {
    return hexa.test(t);
  },
  hexOrHexaColor: function hexOrHexaColor(t) {
    return hexOrHexa.test(t);
  },
  rgbColor: function rgbColor(t) {
    return rgb.test(t);
  },
  rgbaColor: function rgbaColor(t) {
    return rgba.test(t);
  },
  rgbOrRgbaColor: function rgbOrRgbaColor(t) {
    return rgb.test(t) || rgba.test(t);
  },
  hexOrRgbColor: function hexOrRgbColor(t) {
    return hex.test(t) || rgb.test(t);
  },
  hexaOrRgbaColor: function hexaOrRgbaColor(t) {
    return hexa.test(t) || rgba.test(t);
  },
  anyColor: function anyColor(t) {
    return hexOrHexa.test(t) || rgb.test(t) || rgba.test(t);
  }
},
    patterns = {
  testPattern: testPattern
};

function getChanges(t, e, i) {
  var s,
      n = position(t),
      o = n.left - e.event.x,
      r = n.top - e.event.y,
      a = Math.abs(o),
      l = Math.abs(r),
      c = e.direction;
  !0 === c.horizontal && !0 !== c.vertical ? s = o < 0 ? "left" : "right" : !0 !== c.horizontal && !0 === c.vertical ? s = r < 0 ? "up" : "down" : !0 === c.up && r < 0 ? (s = "up", a > l && (!0 === c.left && o < 0 ? s = "left" : !0 === c.right && o > 0 && (s = "right"))) : !0 === c.down && r > 0 ? (s = "down", a > l && (!0 === c.left && o < 0 ? s = "left" : !0 === c.right && o > 0 && (s = "right"))) : !0 === c.left && o < 0 ? (s = "left", a < l && (!0 === c.up && r < 0 ? s = "up" : !0 === c.down && r > 0 && (s = "down"))) : !0 === c.right && o > 0 && (s = "right", a < l && (!0 === c.up && r < 0 ? s = "up" : !0 === c.down && r > 0 && (s = "down")));
  var u = !1;

  if (void 0 === s && !1 === i) {
    if (!0 === e.event.isFirst || void 0 === e.event.lastDir) return {};
    u = !0, "left" === (s = e.event.lastDir) || "right" === s ? (n.left -= o, a = 0, o = 0) : (n.top -= r, l = 0, r = 0);
  }

  return {
    synthetic: u,
    payload: {
      evt: t,
      touch: !0 !== e.event.mouse,
      mouse: !0 === e.event.mouse,
      position: n,
      direction: s,
      isFirst: e.event.isFirst,
      isFinal: !0 === i,
      duration: Date.now() - e.event.time,
      distance: {
        x: a,
        y: l
      },
      offset: {
        x: o,
        y: r
      },
      delta: {
        x: n.left - e.event.lastX,
        y: n.top - e.event.lastY
      }
    }
  };
}

var uid = 0,
    TouchPan = {
  name: "touch-pan",
  bind: function bind(t, e) {
    var i = e.value,
        s = e.modifiers;

    if (!0 === s.mouse || !0 === client.has.touch) {
      var n = {
        uid: "qvtp_" + uid++,
        handler: i,
        modifiers: s,
        direction: getModifierDirections(s),
        noop: noop,
        mouseStart: function mouseStart(t) {
          shouldStart(t, n) && leftClick(t) && (addEvt(n, "temp", [[document, "mousemove", "move", "notPassiveCapture"], [document, "mouseup", "end", "passiveCapture"]]), n.start(t, !0));
        },
        touchStart: function touchStart(t) {
          if (shouldStart(t, n)) {
            var e = getTouchTarget(t.target);
            addEvt(n, "temp", [[e, "touchmove", "move", "notPassiveCapture"], [e, "touchcancel", "end", "passiveCapture"], [e, "touchend", "end", "passiveCapture"]]), n.start(t);
          }
        },
        start: function start(e, i) {
          !0 === client.is.firefox && preventDraggable(t, !0), n.lastEvt = e;
          var o = position(e);

          if (!0 === i || !0 === s.stop) {
            if (!0 !== n.direction.all && (!0 !== i || !0 !== n.direction.mouseAllDir)) {
              var r = e.type.indexOf("mouse") > -1 ? new MouseEvent(e.type, e) : new TouchEvent(e.type, e);
              !0 === e.defaultPrevented && prevent(r), !0 === e.cancelBubble && stop(r), r.qClonedBy = void 0 === e.qClonedBy ? [n.uid] : e.qClonedBy.concat(n.uid), r.qKeyEvent = e.qKeyEvent, r.qClickOutside = e.qClickOutside, n.initialEvent = {
                target: e.target,
                event: r
              };
            }

            stop(e);
          }

          n.event = {
            x: o.left,
            y: o.top,
            time: Date.now(),
            mouse: !0 === i,
            detected: !1,
            isFirst: !0,
            isFinal: !1,
            lastX: o.left,
            lastY: o.top
          };
        },
        move: function move(t) {
          if (void 0 !== n.event) {
            n.lastEvt = t;

            var e = !0 === n.event.mouse,
                i = function i() {
              o(t, e), document.documentElement.style.cursor = "grabbing", !0 === e && document.body.classList.add("no-pointer-events--children"), document.body.classList.add("non-selectable"), clearSelection(), n.styleCleanup = function (t) {
                if (n.styleCleanup = void 0, document.documentElement.style.cursor = "", document.body.classList.remove("non-selectable"), !0 === e) {
                  var i = function i() {
                    document.body.classList.remove("no-pointer-events--children");
                  };

                  void 0 !== t ? setTimeout(function () {
                    i(), t();
                  }, 50) : i();
                } else void 0 !== t && t();
              };
            };

            if (!0 !== n.event.detected) {
              if (!0 === n.direction.all || !0 === e && !0 === n.modifiers.mouseAllDir) return i(), n.event.detected = !0, void n.move(t);
              var s = position(t),
                  r = s.left - n.event.x,
                  a = s.top - n.event.y,
                  l = Math.abs(r),
                  c = Math.abs(a);
              l !== c && (!0 === n.direction.horizontal && l > c || !0 === n.direction.vertical && l < c || !0 === n.direction.up && l < c && a < 0 || !0 === n.direction.down && l < c && a > 0 || !0 === n.direction.left && l > c && r < 0 || !0 === n.direction.right && l > c && r > 0 ? (n.event.detected = !0, n.move(t)) : n.end(t, !0));
            } else {
              !0 !== n.event.isFirst && o(t, n.event.mouse);
              var u = getChanges(t, n, !1),
                  h = u.payload,
                  d = u.synthetic;
              void 0 !== h && (!1 === n.handler(h) ? n.end(t) : (void 0 === n.styleCleanup && !0 === n.event.isFirst && i(), n.event.lastX = h.position.left, n.event.lastY = h.position.top, n.event.lastDir = !0 === d ? void 0 : h.direction, n.event.isFirst = !1));
            }
          }
        },
        end: function end(e, i) {
          if (void 0 !== n.event) {
            if (cleanEvt(n, "temp"), !0 === client.is.firefox && preventDraggable(t, !1), !0 === i) void 0 !== n.styleCleanup && n.styleCleanup(), !0 !== n.event.detected && void 0 !== n.initialEvent && n.initialEvent.target.dispatchEvent(n.initialEvent.event);else if (!0 === n.event.detected) {
              !0 === n.event.isFirst && n.handler(getChanges(void 0 === e ? n.lastEvt : e, n).payload);

              var s = getChanges(void 0 === e ? n.lastEvt : e, n, !0).payload,
                  o = function o() {
                n.handler(s);
              };

              void 0 !== n.styleCleanup ? n.styleCleanup(o) : o();
            }
            n.event = void 0, n.initialEvent = void 0, n.lastEvt = void 0;
          }
        }
      };
      t.__qtouchpan && (t.__qtouchpan_old = t.__qtouchpan), t.__qtouchpan = n, !0 === s.mouse && addEvt(n, "main", [[t, "mousedown", "mouseStart", "passive" + (!0 === s.mouseCapture ? "Capture" : "")]]), !0 === client.has.touch && addEvt(n, "main", [[t, "touchstart", "touchStart", "passive" + (!0 === s.capture ? "Capture" : "")], [t, "touchmove", "noop", "notPassiveCapture"]]);
    }

    function o(t, e) {
      !0 === s.mouse && !0 === e ? stopAndPrevent(t) : (!0 === s.stop && stop(t), !0 === s.prevent && prevent(t));
    }
  },
  update: function update(t, e) {
    void 0 !== t.__qtouchpan && updateModifiers(t.__qtouchpan, e);
  },
  unbind: function unbind(t) {
    var e = t.__qtouchpan_old || t.__qtouchpan;
    void 0 !== e && (cleanEvt(e, "main"), cleanEvt(e, "temp"), !0 === client.is.firefox && preventDraggable(t, !1), void 0 !== e.styleCleanup && e.styleCleanup(), delete t[t.__qtouchpan_old ? "__qtouchpan_old" : "__qtouchpan"]);
  }
},
    keyCodes = [34, 37, 40, 33, 39, 38];

function getRatio(t, e, i, s) {
  var n = position(t),
      o = between(!0 === s ? (n.top - e.top) / e.height : (n.left - e.left) / e.width, 0, 1);
  return !0 === i ? 1 - o : o;
}

function getModel(t, e, i, s, n) {
  var o = e + t * (i - e);

  if (s > 0) {
    var r = (o - e) % s;
    o += (Math.abs(r) >= s / 2 ? (r < 0 ? -1 : 1) * s : 0) - r;
  }

  return n > 0 && (o = parseFloat(o.toFixed(n))), between(o, e, i);
}

var SliderMixin = {
  mixins: [DarkMixin, FormMixin],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1,
      validator: function validator(t) {
        return t >= 0;
      }
    },
    color: String,
    labelColor: String,
    labelTextColor: String,
    dense: Boolean,
    label: Boolean,
    labelAlways: Boolean,
    markers: Boolean,
    snap: Boolean,
    vertical: Boolean,
    reverse: Boolean,
    disable: Boolean,
    readonly: Boolean,
    tabindex: [String, Number],
    thumbPath: {
      type: String,
      default: "M 4, 10 a 6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0"
    }
  },
  data: function data() {
    return {
      active: !1,
      preventFocus: !1,
      focus: !1
    };
  },
  computed: {
    axis: function axis() {
      return !0 === this.vertical ? "--v" : "--h";
    },
    classes: function classes() {
      return "q-slider q-slider" + this.axis + " q-slider--" + (!0 === this.active ? "" : "in") + "active" + (!0 === this.isReversed ? " q-slider--reversed" : "") + (void 0 !== this.color ? " text-" + this.color : "") + (!0 === this.disable ? " disabled" : "") + (!0 === this.editable ? " q-slider--editable" : "") + ("both" === this.focus ? " q-slider--focus" : "") + (this.label || !0 === this.labelAlways ? " q-slider--label" : "") + (!0 === this.labelAlways ? " q-slider--label-always" : "") + (!0 === this.isDark ? " q-slider--dark" : "") + (!0 === this.dense ? " q-slider--dense q-slider--dense" + this.axis : "");
    },
    editable: function editable() {
      return !this.disable && !this.readonly;
    },
    decimals: function decimals() {
      return (String(this.step).trim("0").split(".")[1] || "").length;
    },
    computedStep: function computedStep() {
      return 0 === this.step ? 1 : this.step;
    },
    markerStyle: function markerStyle() {
      return {
        backgroundSize: !0 === this.vertical ? "2px " + 100 * this.computedStep / (this.max - this.min) + "%" : 100 * this.computedStep / (this.max - this.min) + "% 2px"
      };
    },
    computedTabindex: function computedTabindex() {
      return !0 === this.editable ? this.tabindex || 0 : -1;
    },
    isReversed: function isReversed() {
      return !0 === this.vertical ? !0 === this.reverse : this.reverse !== (!0 === this.$q.lang.rtl);
    },
    positionProp: function positionProp() {
      return !0 === this.vertical ? !0 === this.isReversed ? "bottom" : "top" : !0 === this.isReversed ? "right" : "left";
    },
    sizeProp: function sizeProp() {
      return !0 === this.vertical ? "height" : "width";
    },
    orientation: function orientation() {
      return !0 === this.vertical ? "vertical" : "horizontal";
    },
    attrs: function attrs() {
      var t = {
        role: "slider",
        "aria-valuemin": this.min,
        "aria-valuemax": this.max,
        "aria-orientation": this.orientation,
        "data-step": this.step
      };
      return !0 === this.disable ? t["aria-disabled"] = "" : !0 === this.readonly && (t["aria-readonly"] = ""), t;
    },
    panDirectives: function panDirectives() {
      var t;
      return !0 === this.editable ? [{
        name: "touch-pan",
        value: this.__pan,
        modifiers: (t = {}, t[this.orientation] = !0, t.prevent = !0, t.stop = !0, t.mouse = !0, t.mouseAllDir = !0, t)
      }] : null;
    }
  },
  methods: {
    __getThumbSvg: function __getThumbSvg(t) {
      return t("svg", {
        staticClass: "q-slider__thumb absolute",
        attrs: {
          focusable: "false",
          viewBox: "0 0 20 20",
          width: "20",
          height: "20"
        }
      }, [t("path", {
        attrs: {
          d: this.thumbPath
        }
      })]);
    },
    __getPinStyle: function __getPinStyle(t, e) {
      var i;
      if (!0 === this.vertical) return {};
      var s = Math.ceil(20 * Math.abs(.5 - e)) + "px";
      return {
        pin: {
          transformOrigin: (!0 === this.$q.lang.rtl ? s : !0 === this.$q.platform.is.ie ? "100%" : "calc(100% - " + s + ")") + " 50%"
        },
        pinTextContainer: (i = {}, i[!0 === this.$q.lang.rtl ? "left" : "right"] = 100 * t + "%", i.transform = "translateX(" + Math.ceil(20 * (!0 === this.$q.lang.rtl ? -1 : 1) * t) + "px)", i)
      };
    },
    __pan: function __pan(t) {
      t.isFinal ? (void 0 !== this.dragging && (this.__updatePosition(t.evt), !0 === t.touch && this.__updateValue(!0), this.dragging = void 0), this.active = !1) : t.isFirst ? (this.dragging = this.__getDragging(t.evt), this.__updatePosition(t.evt), this.__updateValue(), this.active = !0) : (this.__updatePosition(t.evt), this.__updateValue());
    },
    __blur: function __blur() {
      this.focus = !1;
    },
    __activate: function __activate(t) {
      this.__updatePosition(t, this.__getDragging(t)), this.__updateValue(), this.preventFocus = !0, this.active = !0, document.addEventListener("mouseup", this.__deactivate, !0);
    },
    __deactivate: function __deactivate() {
      this.preventFocus = !1, void 0 === this.dragging && (this.active = !1), this.__updateValue(!0), this.__blur(), document.removeEventListener("mouseup", this.__deactivate, !0);
    },
    __mobileClick: function __mobileClick(t) {
      this.__updatePosition(t, this.__getDragging(t)), this.__updateValue(!0);
    },
    __keyup: function __keyup(t) {
      keyCodes.includes(t.keyCode) && this.__updateValue(!0);
    }
  },
  beforeDestroy: function beforeDestroy() {
    document.removeEventListener("mouseup", this.__deactivate, !0);
  }
},
    QSlider = vue_runtime_esm["a" /* default */].extend({
  name: "QSlider",
  mixins: [SliderMixin],
  props: {
    value: {
      required: !0,
      default: null,
      validator: function validator(t) {
        return "number" == typeof t || null === t;
      }
    },
    labelValue: [String, Number]
  },
  data: function data() {
    return {
      model: null === this.value ? this.min : this.value,
      curRatio: 0
    };
  },
  watch: {
    value: function value(t) {
      this.model = null === t ? 0 : between(t, this.min, this.max);
    },
    min: function min(t) {
      this.model = between(this.model, t, this.max);
    },
    max: function max(t) {
      this.model = between(this.model, this.min, t);
    }
  },
  computed: {
    ratio: function ratio() {
      return !0 === this.active ? this.curRatio : this.modelRatio;
    },
    modelRatio: function modelRatio() {
      return (this.model - this.min) / (this.max - this.min);
    },
    trackStyle: function trackStyle() {
      var t;
      return (t = {})[this.positionProp] = 0, t[this.sizeProp] = 100 * this.ratio + "%", t;
    },
    thumbStyle: function thumbStyle() {
      var t;
      return (t = {})[this.positionProp] = 100 * this.ratio + "%", t;
    },
    thumbClass: function thumbClass() {
      if (!1 === this.preventFocus && !0 === this.focus) return "q-slider--focus";
    },
    pinClass: function pinClass() {
      if (void 0 !== this.labelColor) return "text-" + this.labelColor;
    },
    pinTextClass: function pinTextClass() {
      return "q-slider__pin-value-marker-text" + (void 0 !== this.labelTextColor ? " text-" + this.labelTextColor : "");
    },
    events: function events() {
      if (!0 === this.editable) return !0 === this.$q.platform.is.mobile ? {
        click: this.__mobileClick
      } : {
        mousedown: this.__activate,
        focus: this.__focus,
        blur: this.__blur,
        keydown: this.__keydown,
        keyup: this.__keyup
      };
    },
    computedLabel: function computedLabel() {
      return void 0 !== this.labelValue ? this.labelValue : this.model;
    },
    pinStyle: function pinStyle() {
      var t = !0 === this.reverse ? -this.ratio : this.ratio - 1;
      return this.__getPinStyle(t, this.ratio);
    }
  },
  methods: {
    __updateValue: function __updateValue(t) {
      this.model !== this.value && this.$emit("input", this.model), !0 === t && this.$emit("change", this.model);
    },
    __getDragging: function __getDragging() {
      return this.$el.getBoundingClientRect();
    },
    __updatePosition: function __updatePosition(t, e) {
      void 0 === e && (e = this.dragging);
      var i = getRatio(t, e, this.isReversed, this.vertical);
      this.model = getModel(i, this.min, this.max, this.step, this.decimals), this.curRatio = !0 !== this.snap || 0 === this.step ? i : (this.model - this.min) / (this.max - this.min);
    },
    __focus: function __focus() {
      this.focus = !0;
    },
    __keydown: function __keydown(t) {
      if (keyCodes.includes(t.keyCode)) {
        stopAndPrevent(t);
        var e = ([34, 33].includes(t.keyCode) ? 10 : 1) * this.computedStep,
            i = [34, 37, 40].includes(t.keyCode) ? -e : e;
        this.model = between(parseFloat((this.model + i).toFixed(this.decimals)), this.min, this.max), this.__updateValue();
      }
    }
  },
  render: function render(t) {
    var e = [this.__getThumbSvg(t), t("div", {
      staticClass: "q-slider__focus-ring"
    })];
    !0 !== this.label && !0 !== this.labelAlways || e.push(t("div", {
      staticClass: "q-slider__pin q-slider__pin" + this.axis + " absolute",
      style: this.pinStyle.pin,
      class: this.pinClass
    }, [t("div", {
      staticClass: "q-slider__pin-text-container q-slider__pin-text-container" + this.axis,
      style: this.pinStyle.pinTextContainer
    }, [t("span", {
      staticClass: "q-slider__pin-text",
      class: this.pinTextClass
    }, [this.computedLabel])])]), t("div", {
      staticClass: "q-slider__arrow q-slider__arrow" + this.axis,
      class: this.pinClass
    })), void 0 !== this.name && !0 !== this.disable && this.__injectFormInput(e, "push");
    var i = [t("div", {
      staticClass: "q-slider__track q-slider__track" + this.axis + " absolute",
      style: this.trackStyle
    })];
    return !0 === this.markers && i.push(t("div", {
      staticClass: "q-slider__track-markers q-slider__track-markers" + this.axis + " absolute-full fit",
      style: this.markerStyle
    })), t("div", {
      staticClass: null === this.value ? " q-slider--no-value" : "",
      attrs: Object.assign({}, this.attrs, {
        "aria-valuenow": this.value,
        tabindex: this.computedTabindex
      }),
      class: this.classes,
      on: this.events,
      directives: this.panDirectives
    }, [t("div", {
      staticClass: "q-slider__track-container q-slider__track-container" + this.axis + " absolute"
    }, i), t("div", {
      staticClass: "q-slider__thumb-container q-slider__thumb-container" + this.axis + " absolute non-selectable",
      class: this.thumbClass,
      style: this.thumbStyle
    }, e)]);
  }
}),
    CanRenderMixin = {
  data: function data() {
    return {
      canRender: !onSSR
    };
  },
  mounted: function mounted() {
    !1 === this.canRender && (this.canRender = !0);
  }
},
    QResizeObserver = vue_runtime_esm["a" /* default */].extend({
  name: "QResizeObserver",
  mixins: [CanRenderMixin],
  props: {
    debounce: {
      type: [String, Number],
      default: 100
    }
  },
  data: function data() {
    return !0 === this.hasObserver ? {} : {
      url: !0 === this.$q.platform.is.ie ? null : "about:blank"
    };
  },
  methods: {
    trigger: function trigger(t) {
      !0 === t || 0 === this.debounce || "0" === this.debounce ? this.__onResize() : this.timer || (this.timer = setTimeout(this.__onResize, this.debounce));
    },
    __onResize: function __onResize() {
      if (this.timer = null, this.$el && this.$el.parentNode) {
        var t = this.$el.parentNode,
            e = {
          width: t.offsetWidth,
          height: t.offsetHeight
        };
        e.width === this.size.width && e.height === this.size.height || (this.size = e, this.$emit("resize", this.size));
      }
    },
    __cleanup: function __cleanup() {
      void 0 !== this.curDocView && (void 0 !== this.curDocView.removeEventListener && this.curDocView.removeEventListener("resize", this.trigger, listenOpts.passive), this.curDocView = void 0);
    },
    __onObjLoad: function __onObjLoad() {
      this.__cleanup(), this.$el.contentDocument && (this.curDocView = this.$el.contentDocument.defaultView, this.curDocView.addEventListener("resize", this.trigger, listenOpts.passive)), this.__onResize();
    }
  },
  render: function render(t) {
    if (!1 !== this.canRender && !0 !== this.hasObserver) return t("object", {
      style: this.style,
      attrs: {
        tabindex: -1,
        type: "text/html",
        data: this.url,
        "aria-hidden": "true"
      },
      on: cache(this, "load", {
        load: this.__onObjLoad
      })
    });
  },
  beforeCreate: function beforeCreate() {
    this.size = {
      width: -1,
      height: -1
    }, !0 !== isSSR && (this.hasObserver = "undefined" != typeof ResizeObserver, !0 !== this.hasObserver && (this.style = (this.$q.platform.is.ie ? "visibility:hidden;" : "") + "display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;"));
  },
  mounted: function mounted() {
    if (!0 === this.hasObserver) return this.observer = new ResizeObserver(this.trigger), this.observer.observe(this.$el.parentNode), void this.__onResize();
    !0 === this.$q.platform.is.ie ? (this.url = "about:blank", this.__onResize()) : this.__onObjLoad();
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.timer), !0 !== this.hasObserver ? this.__cleanup() : void 0 !== this.observer && this.$el.parentNode && this.observer.unobserve(this.$el.parentNode);
  }
});

function getIndicatorClass(t, e, i) {
  var s = !0 === i ? ["left", "right"] : ["top", "bottom"];
  return "absolute-" + (!0 === e ? s[0] : s[1]) + (t ? " text-" + t : "");
}

function bufferPrioritySort(t, e) {
  return t.priorityMatched === e.priorityMatched ? e.priorityHref - t.priorityHref : e.priorityMatched - t.priorityMatched;
}

function bufferCleanSelected(t) {
  return t.selected = !1, t;
}

var bufferFilters = [function (t) {
  return !0 === t.selected && !0 === t.exact && !0 !== t.redirected;
}, function (t) {
  return !0 === t.selected && !0 === t.exact;
}, function (t) {
  return !0 === t.selected && !0 !== t.redirected;
}, function (t) {
  return !0 === t.selected;
}, function (t) {
  return !0 === t.exact && !0 !== t.redirected;
}, function (t) {
  return !0 !== t.redirected;
}, function (t) {
  return !0 === t.exact;
}, function (t) {
  return !0;
}],
    bufferFiltersLen = bufferFilters.length,
    QTabs = vue_runtime_esm["a" /* default */].extend({
  name: "QTabs",
  mixins: [TimeoutMixin, ListenersMixin],
  provide: function provide() {
    return {
      tabs: this.tabs,
      __recalculateScroll: this.__recalculateScroll,
      __activateTab: this.__activateTab,
      __activateRoute: this.__activateRoute
    };
  },
  props: {
    value: [Number, String],
    align: {
      type: String,
      default: "center",
      validator: function validator(t) {
        return ["left", "center", "right", "justify"].includes(t);
      }
    },
    breakpoint: {
      type: [String, Number],
      default: 600
    },
    vertical: Boolean,
    shrink: Boolean,
    stretch: Boolean,
    activeColor: String,
    activeBgColor: String,
    indicatorColor: String,
    leftIcon: String,
    rightIcon: String,
    switchIndicator: Boolean,
    narrowIndicator: Boolean,
    inlineLabel: Boolean,
    noCaps: Boolean,
    dense: Boolean
  },
  data: function data() {
    return {
      tabs: {
        current: this.value,
        activeColor: this.activeColor,
        activeBgColor: this.activeBgColor,
        indicatorClass: getIndicatorClass(this.indicatorColor, this.switchIndicator, this.vertical),
        narrowIndicator: this.narrowIndicator,
        inlineLabel: this.inlineLabel,
        noCaps: this.noCaps
      },
      scrollable: !1,
      leftArrow: !0,
      rightArrow: !1,
      justify: !1
    };
  },
  watch: {
    value: function value(t) {
      this.__activateTab(t, !0, !0);
    },
    activeColor: function activeColor(t) {
      this.tabs.activeColor = t;
    },
    activeBgColor: function activeBgColor(t) {
      this.tabs.activeBgColor = t;
    },
    vertical: function vertical(t) {
      this.tabs.indicatorClass = getIndicatorClass(this.indicatorColor, this.switchIndicator, t);
    },
    indicatorColor: function indicatorColor(t) {
      this.tabs.indicatorClass = getIndicatorClass(t, this.switchIndicator, this.vertical);
    },
    switchIndicator: function switchIndicator(t) {
      this.tabs.indicatorClass = getIndicatorClass(this.indicatorColor, t, this.vertical);
    },
    narrowIndicator: function narrowIndicator(t) {
      this.tabs.narrowIndicator = t;
    },
    inlineLabel: function inlineLabel(t) {
      this.tabs.inlineLabel = t;
    },
    noCaps: function noCaps(t) {
      this.tabs.noCaps = t;
    }
  },
  computed: {
    alignClass: function alignClass() {
      return "q-tabs__content--align-" + (!0 === this.scrollable ? "left" : !0 === this.justify ? "justify" : this.align);
    },
    classes: function classes() {
      return "q-tabs--" + (!0 === this.scrollable ? "" : "not-") + "scrollable q-tabs--" + (!0 === this.vertical ? "vertical" : "horizontal") + (!0 === this.dense ? " q-tabs--dense" : "") + (!0 === this.shrink ? " col-shrink" : "") + (!0 === this.stretch ? " self-stretch" : "");
    },
    domProps: function domProps() {
      return !0 === this.vertical ? {
        container: "height",
        content: "scrollHeight",
        posLeft: "top",
        posRight: "bottom"
      } : {
        container: "width",
        content: "scrollWidth",
        posLeft: "left",
        posRight: "right"
      };
    },
    onEvents: function onEvents() {
      return Object.assign({}, {
        input: stop
      }, this.qListeners);
    }
  },
  methods: {
    __activateTab: function __activateTab(t, e, i) {
      this.tabs.current !== t && (!0 !== i && this.$emit("input", t), !0 !== e && void 0 !== this.qListeners.input || (this.__animate(this.tabs.current, t), this.tabs.current = t));
    },
    __activateRoute: function __activateRoute(t) {
      var e = this;
      this.bufferRoute !== this.$route && this.buffer.length > 0 && (clearTimeout(this.bufferTimer), this.bufferTimer = void 0, this.buffer.length = 0), this.bufferRoute = this.$route, void 0 !== t && (!0 === t.remove ? this.buffer = this.buffer.filter(function (e) {
        return e.name !== t.name;
      }) : this.buffer.push(t)), void 0 === this.bufferTimer && (this.bufferTimer = setTimeout(function () {
        for (var t = [], i = 0; i < bufferFiltersLen && 0 === t.length; i++) {
          t = e.buffer.filter(bufferFilters[i]);
        }

        t.sort(bufferPrioritySort), e.__activateTab(0 === t.length ? null : t[0].name, !0), e.buffer = e.buffer.map(bufferCleanSelected), e.bufferTimer = void 0;
      }, 1));
    },
    __recalculateScroll: function __recalculateScroll() {
      var t = this;
      this.__nextTick(function () {
        !0 !== t._isDestroyed && t.__updateContainer({
          width: t.$el.offsetWidth,
          height: t.$el.offsetHeight
        });
      }), this.__prepareTick();
    },
    __updateContainer: function __updateContainer(t) {
      var e = this,
          i = t[this.domProps.container],
          s = this.$refs.content[this.domProps.content],
          n = i > 0 && s > i;
      this.scrollable !== n && (this.scrollable = n), !0 === n && this.$nextTick(function () {
        return e.__updateArrows();
      });
      var o = i < parseInt(this.breakpoint, 10);
      this.justify !== o && (this.justify = o);
    },
    __animate: function __animate(t, e) {
      var i = this,
          s = void 0 !== t && null !== t && "" !== t ? this.$children.find(function (e) {
        return e.name === t;
      }) : null,
          n = void 0 !== e && null !== e && "" !== e ? this.$children.find(function (t) {
        return t.name === e;
      }) : null;

      if (s && n) {
        var o = s.$el.getElementsByClassName("q-tab__indicator")[0],
            r = n.$el.getElementsByClassName("q-tab__indicator")[0];
        clearTimeout(this.animateTimer), o.style.transition = "none", o.style.transform = "none", r.style.transition = "none", r.style.transform = "none";
        var a = o.getBoundingClientRect(),
            l = r.getBoundingClientRect();
        r.style.transform = !0 === this.vertical ? "translate3d(0," + (a.top - l.top) + "px,0) scale3d(1," + (l.height ? a.height / l.height : 1) + ",1)" : "translate3d(" + (a.left - l.left) + "px,0,0) scale3d(" + (l.width ? a.width / l.width : 1) + ",1,1)", this.$nextTick(function () {
          i.animateTimer = setTimeout(function () {
            r.style.transition = "transform .25s cubic-bezier(.4, 0, .2, 1)", r.style.transform = "none";
          }, 30);
        });
      }

      if (n && !0 === this.scrollable) {
        var c = this.$refs.content.getBoundingClientRect(),
            u = c.left,
            h = c.width,
            d = c.top,
            p = c.height,
            f = n.$el.getBoundingClientRect(),
            m = !0 === this.vertical ? f.top - d : f.left - u;
        if (m < 0) return this.$refs.content[!0 === this.vertical ? "scrollTop" : "scrollLeft"] += Math.floor(m), void this.__updateArrows();
        (m += !0 === this.vertical ? f.height - p : f.width - h) > 0 && (this.$refs.content[!0 === this.vertical ? "scrollTop" : "scrollLeft"] += Math.ceil(m), this.__updateArrows());
      }
    },
    __updateArrows: function __updateArrows() {
      var t = this.$refs.content,
          e = t.getBoundingClientRect(),
          i = !0 === this.vertical ? t.scrollTop : t.scrollLeft;
      this.leftArrow = i > 0, this.rightArrow = !0 === this.vertical ? Math.ceil(i + e.height) < t.scrollHeight : Math.ceil(i + e.width) < t.scrollWidth;
    },
    __animScrollTo: function __animScrollTo(t) {
      var e = this;
      this.__stopAnimScroll(), this.__scrollTowards(t), this.scrollTimer = setInterval(function () {
        e.__scrollTowards(t) && e.__stopAnimScroll();
      }, 5);
    },
    __scrollToStart: function __scrollToStart() {
      this.__animScrollTo(0);
    },
    __scrollToEnd: function __scrollToEnd() {
      this.__animScrollTo(9999);
    },
    __stopAnimScroll: function __stopAnimScroll() {
      clearInterval(this.scrollTimer);
    },
    __scrollTowards: function __scrollTowards(t) {
      var e = this.$refs.content,
          i = !0 === this.vertical ? e.scrollTop : e.scrollLeft,
          s = t < i ? -1 : 1,
          n = !1;
      return (i += 5 * s) < 0 ? (n = !0, i = 0) : (-1 === s && i <= t || 1 === s && i >= t) && (n = !0, i = t), e[!0 === this.vertical ? "scrollTop" : "scrollLeft"] = i, this.__updateArrows(), n;
    }
  },
  created: function created() {
    this.buffer = [], !0 !== this.$q.platform.is.desktop && (this.__updateArrows = noop);
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.bufferTimer), clearTimeout(this.animateTimer);
  },
  render: function render(t) {
    var e = [t(QResizeObserver, {
      on: cache(this, "resize", {
        resize: this.__updateContainer
      })
    }), t("div", {
      ref: "content",
      staticClass: "q-tabs__content row no-wrap items-center self-stretch hide-scrollbar",
      class: this.alignClass
    }, slot(this, "default"))];
    return !0 === this.$q.platform.is.desktop && e.push(t(QIcon, {
      staticClass: "q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon",
      class: !0 === this.leftArrow ? "" : "q-tabs__arrow--faded",
      props: {
        name: this.leftIcon || (!0 === this.vertical ? this.$q.iconSet.tabs.up : this.$q.iconSet.tabs.left)
      },
      on: cache(this, "onL", {
        mousedown: this.__scrollToStart,
        touchstart: this.__scrollToStart,
        mouseup: this.__stopAnimScroll,
        mouseleave: this.__stopAnimScroll,
        touchend: this.__stopAnimScroll
      })
    }), t(QIcon, {
      staticClass: "q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon",
      class: !0 === this.rightArrow ? "" : "q-tabs__arrow--faded",
      props: {
        name: this.rightIcon || (!0 === this.vertical ? this.$q.iconSet.tabs.down : this.$q.iconSet.tabs.right)
      },
      on: cache(this, "onR", {
        mousedown: this.__scrollToEnd,
        touchstart: this.__scrollToEnd,
        mouseup: this.__stopAnimScroll,
        mouseleave: this.__stopAnimScroll,
        touchend: this.__stopAnimScroll
      })
    })), t("div", {
      staticClass: "q-tabs row no-wrap items-center",
      class: this.classes,
      on: this.onEvents,
      attrs: {
        role: "tablist"
      }
    }, e);
  }
}),
    uid$1 = 0,
    QTab = vue_runtime_esm["a" /* default */].extend({
  name: "QTab",
  mixins: [RippleMixin, ListenersMixin],
  inject: {
    tabs: {
      default: function _default() {
        console.error("QTab/QRouteTab components need to be child of QTabs");
      }
    },
    __activateTab: {},
    __recalculateScroll: {}
  },
  props: {
    icon: String,
    label: [Number, String],
    alert: [Boolean, String],
    alertIcon: String,
    name: {
      type: [Number, String],
      default: function _default() {
        return "t_" + uid$1++;
      }
    },
    noCaps: Boolean,
    tabindex: [String, Number],
    disable: Boolean
  },
  computed: {
    isActive: function isActive() {
      return this.tabs.current === this.name;
    },
    classes: function classes() {
      var t;
      return (t = {})["q-tab--" + (this.isActive ? "" : "in") + "active"] = !0, t["text-" + this.tabs.activeColor] = this.isActive && this.tabs.activeColor, t["bg-" + this.tabs.activeBgColor] = this.isActive && this.tabs.activeBgColor, t["q-tab--full"] = this.icon && this.label && !this.tabs.inlineLabel, t["q-tab--no-caps"] = !0 === this.noCaps || !0 === this.tabs.noCaps, t["q-focusable q-hoverable cursor-pointer"] = !this.disable, t.disabled = this.disable, t;
    },
    computedTabIndex: function computedTabIndex() {
      return !0 === this.disable || !0 === this.isActive ? -1 : this.tabindex || 0;
    },
    onEvents: function onEvents() {
      return Object.assign({}, {
        input: stop
      }, this.qListeners, {
        click: this.__activate,
        keyup: this.__onKeyup
      });
    },
    attrs: function attrs() {
      var t = {
        tabindex: this.computedTabIndex,
        role: "tab",
        "aria-selected": this.isActive
      };
      return !0 === this.disable && (t["aria-disabled"] = ""), t;
    }
  },
  methods: {
    __activate: function __activate(t, e) {
      !0 !== e && void 0 !== this.$refs.blurTarget && this.$refs.blurTarget.focus(), !0 !== this.disable && (void 0 !== this.qListeners.click && this.$emit("click", t), this.__activateTab(this.name));
    },
    __onKeyup: function __onKeyup(t) {
      !0 === isKeyCode(t, 13) && this.__activate(t, !0);
    },
    __getContent: function __getContent(t) {
      var e = this.tabs.narrowIndicator,
          i = [],
          s = t("div", {
        staticClass: "q-tab__indicator",
        class: this.tabs.indicatorClass
      });
      void 0 !== this.icon && i.push(t(QIcon, {
        staticClass: "q-tab__icon",
        props: {
          name: this.icon
        }
      })), void 0 !== this.label && i.push(t("div", {
        staticClass: "q-tab__label"
      }, [this.label])), !1 !== this.alert && i.push(void 0 !== this.alertIcon ? t(QIcon, {
        staticClass: "q-tab__alert-icon",
        props: {
          color: !0 !== this.alert ? this.alert : void 0,
          name: this.alertIcon
        }
      }) : t("div", {
        staticClass: "q-tab__alert",
        class: !0 !== this.alert ? "text-" + this.alert : null
      })), !0 === e && i.push(s);
      var n = [t("div", {
        staticClass: "q-focus-helper",
        attrs: {
          tabindex: -1
        },
        ref: "blurTarget"
      }), t("div", {
        staticClass: "q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable",
        class: !0 === this.tabs.inlineLabel ? "row no-wrap q-tab__content--inline" : "column"
      }, mergeSlot(i, this, "default"))];
      return !1 === e && n.push(s), n;
    },
    __renderTab: function __renderTab(t, e, i) {
      var s = {
        staticClass: "q-tab relative-position self-stretch flex flex-center text-center",
        class: this.classes,
        attrs: this.attrs,
        directives: !1 !== this.ripple && !0 === this.disable ? null : [{
          name: "ripple",
          value: this.ripple
        }]
      };
      return s["div" === e ? "on" : "nativeOn"] = this.onEvents, void 0 !== i && (s.props = i), t(e, s, this.__getContent(t));
    }
  },
  mounted: function mounted() {
    this.__recalculateScroll();
  },
  beforeDestroy: function beforeDestroy() {
    this.__recalculateScroll();
  },
  render: function render(t) {
    return this.__renderTab(t, "div");
  }
}),
    QTabPanels = vue_runtime_esm["a" /* default */].extend({
  name: "QTabPanels",
  mixins: [DarkMixin, PanelParentMixin],
  computed: {
    classes: function classes() {
      return "q-tab-panels q-panel-parent" + (!0 === this.isDark ? " q-tab-panels--dark q-dark" : "");
    }
  },
  methods: {
    __renderPanels: function __renderPanels(t) {
      return t("div", {
        class: this.classes,
        directives: this.panelDirectives,
        on: Object.assign({}, this.qListeners)
      }, this.__getPanelContent(t));
    }
  }
}),
    QTabPanel = vue_runtime_esm["a" /* default */].extend({
  name: "QTabPanel",
  mixins: [PanelChildMixin],
  render: function render(t) {
    return t("div", {
      staticClass: "q-tab-panel",
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    palette = ["rgb(255,204,204)", "rgb(255,230,204)", "rgb(255,255,204)", "rgb(204,255,204)", "rgb(204,255,230)", "rgb(204,255,255)", "rgb(204,230,255)", "rgb(204,204,255)", "rgb(230,204,255)", "rgb(255,204,255)", "rgb(255,153,153)", "rgb(255,204,153)", "rgb(255,255,153)", "rgb(153,255,153)", "rgb(153,255,204)", "rgb(153,255,255)", "rgb(153,204,255)", "rgb(153,153,255)", "rgb(204,153,255)", "rgb(255,153,255)", "rgb(255,102,102)", "rgb(255,179,102)", "rgb(255,255,102)", "rgb(102,255,102)", "rgb(102,255,179)", "rgb(102,255,255)", "rgb(102,179,255)", "rgb(102,102,255)", "rgb(179,102,255)", "rgb(255,102,255)", "rgb(255,51,51)", "rgb(255,153,51)", "rgb(255,255,51)", "rgb(51,255,51)", "rgb(51,255,153)", "rgb(51,255,255)", "rgb(51,153,255)", "rgb(51,51,255)", "rgb(153,51,255)", "rgb(255,51,255)", "rgb(255,0,0)", "rgb(255,128,0)", "rgb(255,255,0)", "rgb(0,255,0)", "rgb(0,255,128)", "rgb(0,255,255)", "rgb(0,128,255)", "rgb(0,0,255)", "rgb(128,0,255)", "rgb(255,0,255)", "rgb(245,0,0)", "rgb(245,123,0)", "rgb(245,245,0)", "rgb(0,245,0)", "rgb(0,245,123)", "rgb(0,245,245)", "rgb(0,123,245)", "rgb(0,0,245)", "rgb(123,0,245)", "rgb(245,0,245)", "rgb(214,0,0)", "rgb(214,108,0)", "rgb(214,214,0)", "rgb(0,214,0)", "rgb(0,214,108)", "rgb(0,214,214)", "rgb(0,108,214)", "rgb(0,0,214)", "rgb(108,0,214)", "rgb(214,0,214)", "rgb(163,0,0)", "rgb(163,82,0)", "rgb(163,163,0)", "rgb(0,163,0)", "rgb(0,163,82)", "rgb(0,163,163)", "rgb(0,82,163)", "rgb(0,0,163)", "rgb(82,0,163)", "rgb(163,0,163)", "rgb(92,0,0)", "rgb(92,46,0)", "rgb(92,92,0)", "rgb(0,92,0)", "rgb(0,92,46)", "rgb(0,92,92)", "rgb(0,46,92)", "rgb(0,0,92)", "rgb(46,0,92)", "rgb(92,0,92)", "rgb(255,255,255)", "rgb(205,205,205)", "rgb(178,178,178)", "rgb(153,153,153)", "rgb(127,127,127)", "rgb(102,102,102)", "rgb(76,76,76)", "rgb(51,51,51)", "rgb(25,25,25)", "rgb(0,0,0)"],
    QColor = vue_runtime_esm["a" /* default */].extend({
  name: "QColor",
  mixins: [ListenersMixin, DarkMixin, FormMixin],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    value: String,
    defaultValue: String,
    defaultView: {
      type: String,
      default: "spectrum",
      validator: function validator(t) {
        return ["spectrum", "tune", "palette"].includes(t);
      }
    },
    formatModel: {
      type: String,
      default: "auto",
      validator: function validator(t) {
        return ["auto", "hex", "rgb", "hexa", "rgba"].includes(t);
      }
    },
    palette: Array,
    noHeader: Boolean,
    noFooter: Boolean,
    square: Boolean,
    flat: Boolean,
    bordered: Boolean,
    disable: Boolean,
    readonly: Boolean
  },
  data: function data() {
    return {
      topView: "auto" === this.formatModel ? void 0 === this.value || null === this.value || "" === this.value || this.value.startsWith("#") ? "hex" : "rgb" : this.formatModel.startsWith("hex") ? "hex" : "rgb",
      view: this.defaultView,
      model: this.__parseModel(this.value || this.defaultValue)
    };
  },
  watch: {
    value: function value(t) {
      var e = this.__parseModel(t || this.defaultValue);

      e.hex !== this.model.hex && (this.model = e);
    },
    defaultValue: function defaultValue(t) {
      if (!this.value && t) {
        var e = this.__parseModel(t);

        e.hex !== this.model.hex && (this.model = e);
      }
    }
  },
  computed: {
    editable: function editable() {
      return !0 !== this.disable && !0 !== this.readonly;
    },
    forceHex: function forceHex() {
      return "auto" === this.formatModel ? null : this.formatModel.indexOf("hex") > -1;
    },
    forceAlpha: function forceAlpha() {
      return "auto" === this.formatModel ? null : this.formatModel.indexOf("a") > -1;
    },
    isHex: function isHex() {
      return void 0 === this.value || null === this.value || "" === this.value || this.value.startsWith("#");
    },
    isOutputHex: function isOutputHex() {
      return null !== this.forceHex ? this.forceHex : this.isHex;
    },
    formAttrs: function formAttrs() {
      return {
        type: "hidden",
        name: this.name,
        value: this.model[!0 === this.isOutputHex ? "hex" : "rgb"]
      };
    },
    hasAlpha: function hasAlpha() {
      return null !== this.forceAlpha ? this.forceAlpha : void 0 !== this.model.a;
    },
    currentBgColor: function currentBgColor() {
      return {
        backgroundColor: this.model.rgb || "#000"
      };
    },
    headerClass: function headerClass() {
      return "q-color-picker__header-content--" + (void 0 !== this.model.a && this.model.a < 65 || luminosity(this.model) > .4 ? "light" : "dark");
    },
    spectrumStyle: function spectrumStyle() {
      return {
        background: "hsl(" + this.model.h + ",100%,50%)"
      };
    },
    spectrumPointerStyle: function spectrumPointerStyle() {
      var t;
      return (t = {
        top: 100 - this.model.v + "%"
      })[!0 === this.$q.lang.rtl ? "right" : "left"] = this.model.s + "%", t;
    },
    inputsArray: function inputsArray() {
      var t = ["r", "g", "b"];
      return !0 === this.hasAlpha && t.push("a"), t;
    },
    computedPalette: function computedPalette() {
      return void 0 !== this.palette && this.palette.length > 0 ? this.palette : palette;
    },
    classes: function classes() {
      return "q-color-picker" + (!0 === this.bordered ? " q-color-picker--bordered" : "") + (!0 === this.square ? " q-color-picker--square no-border-radius" : "") + (!0 === this.flat ? " q-color-picker--flat no-shadow" : "") + (!0 === this.disable ? " disabled" : "") + (!0 === this.isDark ? " q-color-picker--dark q-dark" : "");
    },
    attrs: function attrs() {
      return !0 === this.disable ? {
        "aria-disabled": ""
      } : !0 === this.readonly ? {
        "aria-readonly": ""
      } : void 0;
    }
  },
  created: function created() {
    this.__spectrumChange = throttle(this.__spectrumChange, 20);
  },
  render: function render(t) {
    var e = [this.__getContent(t)];
    return void 0 !== this.name && !0 !== this.disable && this.__injectFormInput(e, "push"), !0 !== this.noHeader && e.unshift(this.__getHeader(t)), !0 !== this.noFooter && e.push(this.__getFooter(t)), t("div", {
      class: this.classes,
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    }, e);
  },
  methods: {
    __getHeader: function __getHeader(t) {
      var e = this;
      return t("div", {
        staticClass: "q-color-picker__header relative-position overflow-hidden"
      }, [t("div", {
        staticClass: "q-color-picker__header-bg absolute-full"
      }), t("div", {
        staticClass: "q-color-picker__header-content absolute-full",
        class: this.headerClass,
        style: this.currentBgColor
      }, [t(QTabs, {
        props: {
          value: this.topView,
          dense: !0,
          align: "justify"
        },
        on: cache(this, "topVTab", {
          input: function input(t) {
            e.topView = t;
          }
        })
      }, [t(QTab, {
        props: {
          label: "HEX" + (!0 === this.hasAlpha ? "A" : ""),
          name: "hex",
          ripple: !1
        }
      }), t(QTab, {
        props: {
          label: "RGB" + (!0 === this.hasAlpha ? "A" : ""),
          name: "rgb",
          ripple: !1
        }
      })]), t("div", {
        staticClass: "q-color-picker__header-banner row flex-center no-wrap"
      }, [t("input", {
        staticClass: "fit",
        domProps: {
          value: this.model[this.topView]
        },
        attrs: !0 !== this.editable ? {
          readonly: !0
        } : null,
        on: cache(this, "topIn", {
          input: function input(t) {
            e.__updateErrorIcon(!0 === e.__onEditorChange(t));
          },
          change: stop,
          blur: function blur(t) {
            !0 === e.__onEditorChange(t, !0) && e.$forceUpdate(), e.__updateErrorIcon(!1);
          }
        })
      }), t(QIcon, {
        ref: "errorIcon",
        staticClass: "q-color-picker__error-icon absolute no-pointer-events",
        props: {
          name: this.$q.iconSet.type.negative
        }
      })])])]);
    },
    __getContent: function __getContent(t) {
      return t(QTabPanels, {
        props: {
          value: this.view,
          animated: !0
        }
      }, [t(QTabPanel, {
        staticClass: "q-color-picker__spectrum-tab overflow-hidden",
        props: {
          name: "spectrum"
        }
      }, this.__getSpectrumTab(t)), t(QTabPanel, {
        staticClass: "q-pa-md q-color-picker__tune-tab",
        props: {
          name: "tune"
        }
      }, this.__getTuneTab(t)), t(QTabPanel, {
        staticClass: "q-color-picker__palette-tab",
        props: {
          name: "palette"
        }
      }, this.__getPaletteTab(t))]);
    },
    __getFooter: function __getFooter(t) {
      var e = this;
      return t("div", {
        staticClass: "q-color-picker__footer relative-position overflow-hidden"
      }, [t(QTabs, {
        staticClass: "absolute-full",
        props: {
          value: this.view,
          dense: !0,
          align: "justify"
        },
        on: cache(this, "ftIn", {
          input: function input(t) {
            e.view = t;
          }
        })
      }, [t(QTab, {
        props: {
          icon: this.$q.iconSet.colorPicker.spectrum,
          name: "spectrum",
          ripple: !1
        }
      }), t(QTab, {
        props: {
          icon: this.$q.iconSet.colorPicker.tune,
          name: "tune",
          ripple: !1
        }
      }), t(QTab, {
        props: {
          icon: this.$q.iconSet.colorPicker.palette,
          name: "palette",
          ripple: !1
        }
      })])]);
    },
    __getSpectrumTab: function __getSpectrumTab(t) {
      var e = this;
      return [t("div", {
        ref: "spectrum",
        staticClass: "q-color-picker__spectrum non-selectable relative-position cursor-pointer",
        style: this.spectrumStyle,
        class: {
          readonly: !0 !== this.editable
        },
        on: !0 === this.editable ? cache(this, "spectrT", {
          click: this.__spectrumClick,
          mousedown: this.__activate
        }) : null,
        directives: !0 === this.editable ? cache(this, "spectrDir", [{
          name: "touch-pan",
          modifiers: {
            prevent: !0,
            stop: !0,
            mouse: !0
          },
          value: this.__spectrumPan
        }]) : null
      }, [t("div", {
        style: {
          paddingBottom: "100%"
        }
      }), t("div", {
        staticClass: "q-color-picker__spectrum-white absolute-full"
      }), t("div", {
        staticClass: "q-color-picker__spectrum-black absolute-full"
      }), t("div", {
        staticClass: "absolute",
        style: this.spectrumPointerStyle
      }, [void 0 !== this.model.hex ? t("div", {
        staticClass: "q-color-picker__spectrum-circle"
      }) : null])]), t("div", {
        staticClass: "q-color-picker__sliders"
      }, [t("div", {
        staticClass: "q-color-picker__hue non-selectable"
      }, [t(QSlider, {
        props: {
          value: this.model.h,
          min: 0,
          max: 360,
          fillHandleAlways: !0,
          readonly: !0 !== this.editable,
          thumbPath: "M5 5 h10 v10 h-10 v-10 z"
        },
        on: cache(this, "hueSlide", {
          input: this.__onHueChange,
          change: function change(t) {
            return e.__onHueChange(t, !0);
          }
        })
      })]), !0 === this.hasAlpha ? t("div", {
        staticClass: "q-color-picker__alpha non-selectable"
      }, [t(QSlider, {
        props: {
          value: this.model.a,
          min: 0,
          max: 100,
          fillHandleAlways: !0,
          readonly: !0 !== this.editable,
          thumbPath: "M5 5 h10 v10 h-10 v-10 z"
        },
        on: cache(this, "alphaSlide", {
          input: function input(t) {
            return e.__onNumericChange(t, "a", 100);
          },
          change: function change(t) {
            return e.__onNumericChange(t, "a", 100, void 0, !0);
          }
        })
      })]) : null])];
    },
    __getTuneTab: function __getTuneTab(t) {
      var e = this;
      return [t("div", {
        staticClass: "row items-center no-wrap"
      }, [t("div", ["R"]), t(QSlider, {
        props: {
          value: this.model.r,
          min: 0,
          max: 255,
          color: "red",
          dark: this.isDark,
          readonly: !0 !== this.editable
        },
        on: cache(this, "rSlide", {
          input: function input(t) {
            return e.__onNumericChange(t, "r", 255);
          },
          change: function change(t) {
            return e.__onNumericChange(t, "r", 255, void 0, !0);
          }
        })
      }), t("input", {
        domProps: {
          value: this.model.r
        },
        attrs: {
          maxlength: 3,
          readonly: !0 !== this.editable
        },
        on: cache(this, "rIn", {
          input: function input(t) {
            return e.__onNumericChange(t.target.value, "r", 255, t);
          },
          change: stop,
          blur: function blur(t) {
            return e.__onNumericChange(t.target.value, "r", 255, t, !0);
          }
        })
      })]), t("div", {
        staticClass: "row items-center no-wrap"
      }, [t("div", ["G"]), t(QSlider, {
        props: {
          value: this.model.g,
          min: 0,
          max: 255,
          color: "green",
          dark: this.isDark,
          readonly: !0 !== this.editable
        },
        on: cache(this, "gSlide", {
          input: function input(t) {
            return e.__onNumericChange(t, "g", 255);
          },
          change: function change(t) {
            return e.__onNumericChange(t, "g", 255, void 0, !0);
          }
        })
      }), t("input", {
        domProps: {
          value: this.model.g
        },
        attrs: {
          maxlength: 3,
          readonly: !0 !== this.editable
        },
        on: cache(this, "gIn", {
          input: function input(t) {
            return e.__onNumericChange(t.target.value, "g", 255, t);
          },
          change: stop,
          blur: function blur(t) {
            return e.__onNumericChange(t.target.value, "g", 255, t, !0);
          }
        })
      })]), t("div", {
        staticClass: "row items-center no-wrap"
      }, [t("div", ["B"]), t(QSlider, {
        props: {
          value: this.model.b,
          min: 0,
          max: 255,
          color: "blue",
          readonly: !0 !== this.editable,
          dark: this.isDark
        },
        on: cache(this, "bSlide", {
          input: function input(t) {
            return e.__onNumericChange(t, "b", 255);
          },
          change: function change(t) {
            return e.__onNumericChange(t, "b", 255, void 0, !0);
          }
        })
      }), t("input", {
        domProps: {
          value: this.model.b
        },
        attrs: {
          maxlength: 3,
          readonly: !0 !== this.editable
        },
        on: cache(this, "bIn", {
          input: function input(t) {
            return e.__onNumericChange(t.target.value, "b", 255, t);
          },
          change: stop,
          blur: function blur(t) {
            return e.__onNumericChange(t.target.value, "b", 255, t, !0);
          }
        })
      })]), !0 === this.hasAlpha ? t("div", {
        staticClass: "row items-center no-wrap"
      }, [t("div", ["A"]), t(QSlider, {
        props: {
          value: this.model.a,
          color: "grey",
          readonly: !0 !== this.editable,
          dark: this.isDark
        },
        on: cache(this, "aSlide", {
          input: function input(t) {
            return e.__onNumericChange(t, "a", 100);
          },
          change: function change(t) {
            return e.__onNumericChange(t, "a", 100, void 0, !0);
          }
        })
      }), t("input", {
        domProps: {
          value: this.model.a
        },
        attrs: {
          maxlength: 3,
          readonly: !0 !== this.editable
        },
        on: cache(this, "aIn", {
          input: function input(t) {
            return e.__onNumericChange(t.target.value, "a", 100, t);
          },
          change: stop,
          blur: function blur(t) {
            return e.__onNumericChange(t.target.value, "a", 100, t, !0);
          }
        })
      })]) : null];
    },
    __getPaletteTab: function __getPaletteTab(t) {
      var e = this;
      return [t("div", {
        staticClass: "row items-center q-color-picker__palette-rows",
        class: !0 === this.editable ? "q-color-picker__palette-rows--editable" : ""
      }, this.computedPalette.map(function (i) {
        return t("div", {
          staticClass: "q-color-picker__cube col-auto",
          style: {
            backgroundColor: i
          },
          on: !0 === e.editable ? cache(e, "palette#" + i, {
            click: function click() {
              e.__onPalettePick(i);
            }
          }) : null
        });
      }))];
    },
    __onSpectrumChange: function __onSpectrumChange(t, e, i) {
      var s = this.$refs.spectrum;

      if (void 0 !== s) {
        var n = s.clientWidth,
            o = s.clientHeight,
            r = s.getBoundingClientRect(),
            a = Math.min(n, Math.max(0, t - r.left));
        !0 === this.$q.lang.rtl && (a = n - a);
        var l = Math.min(o, Math.max(0, e - r.top)),
            c = Math.round(100 * a / n),
            u = Math.round(100 * Math.max(0, Math.min(1, -l / o + 1))),
            h = hsvToRgb({
          h: this.model.h,
          s: c,
          v: u,
          a: !0 === this.hasAlpha ? this.model.a : void 0
        });
        this.model.s = c, this.model.v = u, this.__update(h, i);
      }
    },
    __onHueChange: function __onHueChange(t, e) {
      var i = hsvToRgb({
        h: t = Math.round(t),
        s: this.model.s,
        v: this.model.v,
        a: !0 === this.hasAlpha ? this.model.a : void 0
      });
      this.model.h = t, this.__update(i, e);
    },
    __onNumericChange: function __onNumericChange(t, e, i, s, n) {
      if (void 0 !== s && stop(s), /^[0-9]+$/.test(t)) {
        var o = Math.floor(Number(t));
        if (o < 0 || o > i) !0 === n && this.$forceUpdate();else {
          var r = {
            r: "r" === e ? o : this.model.r,
            g: "g" === e ? o : this.model.g,
            b: "b" === e ? o : this.model.b,
            a: !0 === this.hasAlpha ? "a" === e ? o : this.model.a : void 0
          };

          if ("a" !== e) {
            var a = rgbToHsv(r);
            this.model.h = a.h, this.model.s = a.s, this.model.v = a.v;
          }

          if (this.__update(r, n), void 0 !== s && !0 !== n && void 0 !== s.target.selectionEnd) {
            var l = s.target.selectionEnd;
            this.$nextTick(function () {
              s.target.setSelectionRange(l, l);
            });
          }
        }
      } else n && this.$forceUpdate();
    },
    __onEditorChange: function __onEditorChange(t, e) {
      var i,
          s = t.target.value;

      if (stop(t), "hex" === this.topView) {
        if (s.length !== (!0 === this.hasAlpha ? 9 : 7) || !/^#[0-9A-Fa-f]+$/.test(s)) return !0;
        i = hexToRgb(s);
      } else {
        var n;
        if (!s.endsWith(")")) return !0;

        if (!0 !== this.hasAlpha && s.startsWith("rgb(")) {
          if (3 !== (n = s.substring(4, s.length - 1).split(",").map(function (t) {
            return parseInt(t, 10);
          })).length || !/^rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)$/.test(s)) return !0;
        } else {
          if (!0 !== this.hasAlpha || !s.startsWith("rgba(")) return !0;
          if (4 !== (n = s.substring(5, s.length - 1).split(",")).length || !/^rgba\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/.test(s)) return !0;

          for (var o = 0; o < 3; o++) {
            var r = parseInt(n[o], 10);
            if (r < 0 || r > 255) return !0;
            n[o] = r;
          }

          var a = parseFloat(n[3]);
          if (a < 0 || a > 1) return !0;
          n[3] = a;
        }

        if (n[0] < 0 || n[0] > 255 || n[1] < 0 || n[1] > 255 || n[2] < 0 || n[2] > 255 || !0 === this.hasAlpha && (n[3] < 0 || n[3] > 1)) return !0;
        i = {
          r: n[0],
          g: n[1],
          b: n[2],
          a: !0 === this.hasAlpha ? 100 * n[3] : void 0
        };
      }

      var l = rgbToHsv(i);

      if (this.model.h = l.h, this.model.s = l.s, this.model.v = l.v, this.__update(i, e), !0 !== e) {
        var c = t.target.selectionEnd;
        this.$nextTick(function () {
          t.target.setSelectionRange(c, c);
        });
      }
    },
    __onPalettePick: function __onPalettePick(t) {
      var e = this.__parseModel(t),
          i = {
        r: e.r,
        g: e.g,
        b: e.b,
        a: e.a
      };

      void 0 === i.a && (i.a = this.model.a), this.model.h = e.h, this.model.s = e.s, this.model.v = e.v, this.__update(i, !0);
    },
    __update: function __update(t, e) {
      this.model.hex = rgbToHex(t), this.model.rgb = rgbToString(t), this.model.r = t.r, this.model.g = t.g, this.model.b = t.b, this.model.a = t.a;
      var i = this.model[!0 === this.isOutputHex ? "hex" : "rgb"];
      this.$emit("input", i), !0 === e && this.$emit("change", i);
    },
    __updateErrorIcon: function __updateErrorIcon(t) {
      void 0 !== this.$refs.errorIcon && (this.$refs.errorIcon.$el.style.opacity = t ? 1 : 0);
    },
    __parseModel: function __parseModel(t) {
      var e = void 0 !== this.forceAlpha ? this.forceAlpha : "auto" === this.formatModel ? null : this.formatModel.indexOf("a") > -1;
      if ("string" != typeof t || 0 === t.length || !0 !== testPattern.anyColor(t.replace(/ /g, ""))) return {
        h: 0,
        s: 0,
        v: 0,
        r: 0,
        g: 0,
        b: 0,
        a: !0 === e ? 100 : void 0,
        hex: void 0,
        rgb: void 0
      };
      var i = textToRgb(t);
      return !0 === e && void 0 === i.a && (i.a = 100), i.hex = rgbToHex(i), i.rgb = rgbToString(i), Object.assign(i, rgbToHsv(i));
    },
    __spectrumPan: function __spectrumPan(t) {
      t.isFinal ? this.__onSpectrumChange(t.position.left, t.position.top, !0) : this.__spectrumChange(t);
    },
    __spectrumChange: function __spectrumChange(t) {
      this.__onSpectrumChange(t.position.left, t.position.top);
    },
    __spectrumClick: function __spectrumClick(t) {
      this.__onSpectrumChange(t.pageX - window.pageXOffset, t.pageY - window.pageYOffset, !0);
    },
    __activate: function __activate(t) {
      this.__onSpectrumChange(t.pageX - window.pageXOffset, t.pageY - window.pageYOffset);
    }
  }
}),
    breaks = [-61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210, 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178];

function toJalaali(t, e, i) {
  return "[object Date]" === Object.prototype.toString.call(t) && (i = t.getDate(), e = t.getMonth() + 1, t = t.getFullYear()), d2j(g2d(t, e, i));
}

function toGregorian(t, e, i) {
  return d2g(j2d(t, e, i));
}

function isLeapJalaaliYear(t) {
  return 0 === jalCalLeap(t);
}

function jalaaliMonthLength(t, e) {
  return e <= 6 ? 31 : e <= 11 ? 30 : isLeapJalaaliYear(t) ? 30 : 29;
}

function jalCalLeap(t) {
  var e,
      i,
      s,
      n,
      o,
      r = breaks.length,
      a = breaks[0];
  if (t < a || t >= breaks[r - 1]) throw new Error("Invalid Jalaali year " + t);

  for (o = 1; o < r && (i = (e = breaks[o]) - a, !(t < e)); o += 1) {
    a = e;
  }

  return i - (n = t - a) < 6 && (n = n - i + 33 * div(i + 4, 33)), -1 === (s = mod(mod(n + 1, 33) - 1, 4)) && (s = 4), s;
}

function jalCal(t, e) {
  var i,
      s,
      n,
      o,
      r,
      a,
      l = breaks.length,
      c = t + 621,
      u = -14,
      h = breaks[0];
  if (t < h || t >= breaks[l - 1]) throw new Error("Invalid Jalaali year " + t);

  for (a = 1; a < l && (s = (i = breaks[a]) - h, !(t < i)); a += 1) {
    u = u + 8 * div(s, 33) + div(mod(s, 33), 4), h = i;
  }

  return u = u + 8 * div(r = t - h, 33) + div(mod(r, 33) + 3, 4), 4 === mod(s, 33) && s - r == 4 && (u += 1), o = 20 + u - (div(c, 4) - div(3 * (div(c, 100) + 1), 4) - 150), e || (s - r < 6 && (r = r - s + 33 * div(s + 4, 33)), -1 === (n = mod(mod(r + 1, 33) - 1, 4)) && (n = 4)), {
    leap: n,
    gy: c,
    march: o
  };
}

function j2d(t, e, i) {
  var s = jalCal(t, !0);
  return g2d(s.gy, 3, s.march) + 31 * (e - 1) - div(e, 7) * (e - 7) + i - 1;
}

function d2j(t) {
  var e,
      i = d2g(t).gy,
      s = i - 621,
      n = jalCal(s, !1);

  if ((e = t - g2d(i, 3, n.march)) >= 0) {
    if (e <= 185) return {
      jy: s,
      jm: 1 + div(e, 31),
      jd: mod(e, 31) + 1
    };
    e -= 186;
  } else s -= 1, e += 179, 1 === n.leap && (e += 1);

  return {
    jy: s,
    jm: 7 + div(e, 30),
    jd: mod(e, 30) + 1
  };
}

function g2d(t, e, i) {
  var s = div(1461 * (t + div(e - 8, 6) + 100100), 4) + div(153 * mod(e + 9, 12) + 2, 5) + i - 34840408;
  return s = s - div(3 * div(t + 100100 + div(e - 8, 6), 100), 4) + 752;
}

function d2g(t) {
  var e, i, s, n;
  return s = div(mod(i = 5 * div(mod(e = (e = 4 * t + 139361631) + 4 * div(3 * div(4 * t + 183187720, 146097), 4) - 3908, 1461), 4) + 308, 153), 5) + 1, n = mod(div(i, 153), 12) + 1, {
    gy: div(e, 1461) - 100100 + div(8 - n, 6),
    gm: n,
    gd: s
  };
}

function div(t, e) {
  return ~~(t / e);
}

function mod(t, e) {
  return t - ~~(t / e) * e;
}

var DateTimeMixin = {
  mixins: [DarkMixin, FormMixin, ListenersMixin],
  props: {
    value: {
      required: !0
    },
    mask: {
      type: String
    },
    locale: Object,
    calendar: {
      type: String,
      validator: function validator(t) {
        return ["gregorian", "persian"].includes(t);
      },
      default: "gregorian"
    },
    landscape: Boolean,
    color: String,
    textColor: String,
    square: Boolean,
    flat: Boolean,
    bordered: Boolean,
    readonly: Boolean,
    disable: Boolean
  },
  watch: {
    mask: function mask() {
      var t = this;
      this.$nextTick(function () {
        t.__updateValue({}, "mask");
      });
    },
    computedLocale: function computedLocale() {
      var t = this;
      this.$nextTick(function () {
        t.__updateValue({}, "locale");
      });
    }
  },
  computed: {
    editable: function editable() {
      return !0 !== this.disable && !0 !== this.readonly;
    },
    computedColor: function computedColor() {
      return this.color || "primary";
    },
    computedTextColor: function computedTextColor() {
      return this.textColor || "white";
    },
    computedTabindex: function computedTabindex() {
      return !0 === this.editable ? 0 : -1;
    },
    headerClass: function headerClass() {
      var t = [];
      return void 0 !== this.color && t.push("bg-" + this.color), void 0 !== this.textColor && t.push("text-" + this.textColor), t.join(" ");
    },
    computedLocale: function computedLocale() {
      return this.__getComputedLocale();
    }
  },
  methods: {
    __getComputedLocale: function __getComputedLocale() {
      return this.locale || this.$q.lang.date;
    },
    __getCurrentDate: function __getCurrentDate() {
      var t = new Date();

      if ("persian" === this.calendar) {
        var e = toJalaali(t);
        return {
          year: e.jy,
          month: e.jm,
          day: e.jd
        };
      }

      return {
        year: t.getFullYear(),
        month: t.getMonth() + 1,
        day: t.getDate()
      };
    },
    __getCurrentTime: function __getCurrentTime() {
      var t = new Date();
      return {
        hour: t.getHours(),
        minute: t.getMinutes(),
        second: t.getSeconds(),
        millisecond: t.getMilliseconds()
      };
    }
  }
},
    MILLISECONDS_IN_DAY = 864e5,
    MILLISECONDS_IN_HOUR = 36e5,
    MILLISECONDS_IN_MINUTE = 6e4,
    defaultMask = "YYYY-MM-DDTHH:mm:ss.SSSZ",
    token = /\[((?:[^\]\\]|\\]|\\)*)\]|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]/g,
    reverseToken = /(\[[^\]]*\])|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]|([.*+:?^,\s${}()|\\]+)/g,
    regexStore = {};

function getRegexData(t, e) {
  var i = "(" + e.days.join("|") + ")",
      s = t + i;
  if (void 0 !== regexStore[s]) return regexStore[s];
  var n = "(" + e.daysShort.join("|") + ")",
      o = "(" + e.months.join("|") + ")",
      r = "(" + e.monthsShort.join("|") + ")",
      a = {},
      l = 0,
      c = t.replace(reverseToken, function (t) {
    switch (l++, t) {
      case "YY":
        return a.YY = l, "(-?\\d{1,2})";

      case "YYYY":
        return a.YYYY = l, "(-?\\d{1,4})";

      case "M":
        return a.M = l, "(\\d{1,2})";

      case "MM":
        return a.M = l, "(\\d{2})";

      case "MMM":
        return a.MMM = l, r;

      case "MMMM":
        return a.MMMM = l, o;

      case "D":
        return a.D = l, "(\\d{1,2})";

      case "Do":
        return a.D = l++, "(\\d{1,2}(st|nd|rd|th))";

      case "DD":
        return a.D = l, "(\\d{2})";

      case "H":
        return a.H = l, "(\\d{1,2})";

      case "HH":
        return a.H = l, "(\\d{2})";

      case "h":
        return a.h = l, "(\\d{1,2})";

      case "hh":
        return a.h = l, "(\\d{2})";

      case "m":
        return a.m = l, "(\\d{1,2})";

      case "mm":
        return a.m = l, "(\\d{2})";

      case "s":
        return a.s = l, "(\\d{1,2})";

      case "ss":
        return a.s = l, "(\\d{2})";

      case "S":
        return a.S = l, "(\\d{1})";

      case "SS":
        return a.S = l, "(\\d{2})";

      case "SSS":
        return a.S = l, "(\\d{3})";

      case "A":
        return a.A = l, "(AM|PM)";

      case "a":
        return a.a = l, "(am|pm)";

      case "aa":
        return a.aa = l, "(a\\.m\\.|p\\.m\\.)";

      case "ddd":
        return n;

      case "dddd":
        return i;

      case "Q":
      case "d":
      case "E":
        return "(\\d{1})";

      case "Qo":
        return "(1st|2nd|3rd|4th)";

      case "DDD":
      case "DDDD":
        return "(\\d{1,3})";

      case "w":
        return "(\\d{1,2})";

      case "ww":
        return "(\\d{2})";

      case "Z":
        return a.Z = l, "(Z|[+-]\\d{2}:\\d{2})";

      case "ZZ":
        return a.ZZ = l, "(Z|[+-]\\d{2}\\d{2})";

      case "X":
        return a.X = l, "(-?\\d+)";

      case "x":
        return a.x = l, "(-?\\d{4,})";

      default:
        return l--, "[" === t[0] && (t = t.substring(1, t.length - 1)), t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  }),
      u = {
    map: a,
    regex: new RegExp("^" + c)
  };
  return regexStore[s] = u, u;
}

function extractDate(t, e, i) {
  var s = __splitDate(t, e, i),
      n = new Date(s.year, null === s.month ? null : s.month - 1, s.day, s.hour, s.minute, s.second, s.millisecond),
      o = n.getTimezoneOffset();

  return null === s.timezoneOffset || s.timezoneOffset === o ? n : getChange(n, {
    minutes: s.timezoneOffset - o
  }, !0);
}

function __splitDate(t, e, i, s, n) {
  var o = Object.assign({
    year: null,
    month: null,
    day: null,
    hour: null,
    minute: null,
    second: null,
    millisecond: null,
    timezoneOffset: null,
    dateHash: null,
    timeHash: null
  }, n);
  if (void 0 === t || null === t || "" === t || "string" != typeof t) return o;
  void 0 === e && (e = defaultMask);
  var r = void 0 !== i ? i : lang.props.date,
      a = r.months,
      l = r.monthsShort,
      c = getRegexData(e, r),
      u = c.regex,
      h = c.map,
      d = t.match(u);
  if (null === d) return o;
  var p = "";

  if (void 0 !== h.X || void 0 !== h.x) {
    var f = parseInt(d[void 0 !== h.X ? h.X : h.x], 10);
    if (!0 === isNaN(f) || f < 0) return o;
    var m = new Date(f * (void 0 !== h.X ? 1e3 : 1));
    o.year = m.getFullYear(), o.month = m.getMonth() + 1, o.day = m.getDate(), o.hour = m.getHours(), o.minute = m.getMinutes(), o.second = m.getSeconds(), o.millisecond = m.getMilliseconds();
  } else {
    if (void 0 !== h.YYYY) o.year = parseInt(d[h.YYYY], 10);else if (void 0 !== h.YY) {
      var v = parseInt(d[h.YY], 10);
      o.year = v < 0 ? v : 2e3 + v;
    }

    if (void 0 !== h.M) {
      if (o.month = parseInt(d[h.M], 10), o.month < 1 || o.month > 12) return o;
    } else void 0 !== h.MMM ? o.month = l.indexOf(d[h.MMM]) + 1 : void 0 !== h.MMMM && (o.month = a.indexOf(d[h.MMMM]) + 1);

    if (void 0 !== h.D) {
      if (o.day = parseInt(d[h.D], 10), null === o.year || null === o.month || o.day < 1) return o;
      var g = "persian" !== s ? new Date(o.year, o.month, 0).getDate() : jalaaliMonthLength(o.year, o.month);
      if (o.day > g) return o;
    }

    void 0 !== h.H ? o.hour = parseInt(d[h.H], 10) % 24 : void 0 !== h.h && (o.hour = parseInt(d[h.h], 10) % 12, (h.A && "PM" === d[h.A] || h.a && "pm" === d[h.a] || h.aa && "p.m." === d[h.aa]) && (o.hour += 12), o.hour = o.hour % 24), void 0 !== h.m && (o.minute = parseInt(d[h.m], 10) % 60), void 0 !== h.s && (o.second = parseInt(d[h.s], 10) % 60), void 0 !== h.S && (o.millisecond = parseInt(d[h.S], 10) * Math.pow(10, 3 - d[h.S].length)), void 0 === h.Z && void 0 === h.ZZ || (p = void 0 !== h.Z ? d[h.Z].replace(":", "") : d[h.ZZ], o.timezoneOffset = ("+" === p[0] ? -1 : 1) * (60 * p.slice(1, 3) + 1 * p.slice(3, 5)));
  }

  return o.dateHash = o.year + "/" + pad(o.month) + "/" + pad(o.day), o.timeHash = pad(o.hour) + ":" + pad(o.minute) + ":" + pad(o.second) + p, o;
}

function formatTimezone(t, e) {
  void 0 === e && (e = "");
  var i = t > 0 ? "-" : "+",
      s = Math.abs(t),
      n = s % 60;
  return i + pad(Math.floor(s / 60)) + e + pad(n);
}

function setMonth(t, e) {
  var i = new Date(t.getFullYear(), e, 0, 0, 0, 0, 0).getDate();
  t.setMonth(e - 1, Math.min(i, t.getDate()));
}

function getChange(t, e, i) {
  var s = new Date(t),
      n = i ? 1 : -1;
  return Object.keys(e).forEach(function (t) {
    if ("month" !== t) {
      var i = "year" === t ? "FullYear" : capitalize("days" === t ? "date" : t);
      s["set" + i](s["get" + i]() + n * e[t]);
    } else setMonth(s, s.getMonth() + 1 + n * e.month);
  }), s;
}

function isValid(t) {
  return "number" == typeof t || !1 === isNaN(Date.parse(t));
}

function buildDate(t, e) {
  return adjustDate(new Date(), t, e);
}

function getDayOfWeek(t) {
  var e = new Date(t).getDay();
  return 0 === e ? 7 : e;
}

function getWeekOfYear(t) {
  var e = new Date(t.getFullYear(), t.getMonth(), t.getDate());
  e.setDate(e.getDate() - (e.getDay() + 6) % 7 + 3);
  var i = new Date(e.getFullYear(), 0, 4);
  i.setDate(i.getDate() - (i.getDay() + 6) % 7 + 3);
  var s = e.getTimezoneOffset() - i.getTimezoneOffset();
  e.setHours(e.getHours() - s);
  var n = (e - i) / (7 * MILLISECONDS_IN_DAY);
  return 1 + Math.floor(n);
}

function getDayIdentifier(t) {
  return 1e4 * t.getFullYear() + 100 * t.getMonth() + t.getDate();
}

function getDateIdentifier(t, e) {
  var i = new Date(t);
  return !0 === e ? getDayIdentifier(i) : i.getTime();
}

function isBetweenDates(t, e, i, s) {
  void 0 === s && (s = {});
  var n = getDateIdentifier(e, s.onlyDate),
      o = getDateIdentifier(i, s.onlyDate),
      r = getDateIdentifier(t, s.onlyDate);
  return (r > n || !0 === s.inclusiveFrom && r === n) && (r < o || !0 === s.inclusiveTo && r === o);
}

function addToDate(t, e) {
  return getChange(t, e, !0);
}

function subtractFromDate(t, e) {
  return getChange(t, e, !1);
}

function adjustDate(t, e, i) {
  var s = new Date(t),
      n = "set" + (i ? "UTC" : "");
  return Object.keys(e).forEach(function (t) {
    if ("month" !== t) {
      var i = "year" === t ? "FullYear" : t.charAt(0).toUpperCase() + t.slice(1);
      s["" + n + i](e[t]);
    } else setMonth(s, e.month);
  }), s;
}

function startOfDate(t, e) {
  var i = new Date(t);

  switch (e) {
    case "year":
      i.setMonth(0);

    case "month":
      i.setDate(1);

    case "day":
      i.setHours(0);

    case "hour":
      i.setMinutes(0);

    case "minute":
      i.setSeconds(0);

    case "second":
      i.setMilliseconds(0);
  }

  return i;
}

function endOfDate(t, e) {
  var i = new Date(t);

  switch (e) {
    case "year":
      i.setMonth(11);

    case "month":
      i.setDate(daysInMonth(i));

    case "day":
      i.setHours(23);

    case "hour":
      i.setMinutes(59);

    case "minute":
      i.setSeconds(59);

    case "second":
      i.setMilliseconds(59);
  }

  return i;
}

function getMaxDate() {
  var t = 0;
  return Array.prototype.slice.call(arguments).forEach(function (e) {
    t = Math.max(t, new Date(e));
  }), t;
}

function getMinDate(t) {
  var e = new Date(t);
  return Array.prototype.slice.call(arguments, 1).forEach(function (t) {
    e = Math.min(e, new Date(t));
  }), e;
}

function getDiff(t, e, i) {
  return (t.getTime() - t.getTimezoneOffset() * MILLISECONDS_IN_MINUTE - (e.getTime() - e.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)) / i;
}

function getDateDiff(t, e, i) {
  void 0 === i && (i = "days");
  var s = new Date(t),
      n = new Date(e);

  switch (i) {
    case "years":
      return s.getFullYear() - n.getFullYear();

    case "months":
      return 12 * (s.getFullYear() - n.getFullYear()) + s.getMonth() - n.getMonth();

    case "days":
      return getDiff(startOfDate(s, "day"), startOfDate(n, "day"), MILLISECONDS_IN_DAY);

    case "hours":
      return getDiff(startOfDate(s, "hour"), startOfDate(n, "hour"), MILLISECONDS_IN_HOUR);

    case "minutes":
      return getDiff(startOfDate(s, "minute"), startOfDate(n, "minute"), MILLISECONDS_IN_MINUTE);

    case "seconds":
      return getDiff(startOfDate(s, "second"), startOfDate(n, "second"), 1e3);
  }
}

function getDayOfYear(t) {
  return getDateDiff(t, startOfDate(t, "year"), "days") + 1;
}

function inferDateFormat(t) {
  return !0 === isDate(t) ? "date" : "number" == typeof t ? "number" : "string";
}

function getDateBetween(t, e, i) {
  var s = new Date(t);

  if (e) {
    var n = new Date(e);
    if (s < n) return n;
  }

  if (i) {
    var o = new Date(i);
    if (s > o) return o;
  }

  return s;
}

function isSameDate(t, e, i) {
  var s = new Date(t),
      n = new Date(e);
  if (void 0 === i) return s.getTime() === n.getTime();

  switch (i) {
    case "second":
      if (s.getSeconds() !== n.getSeconds()) return !1;

    case "minute":
      if (s.getMinutes() !== n.getMinutes()) return !1;

    case "hour":
      if (s.getHours() !== n.getHours()) return !1;

    case "day":
      if (s.getDate() !== n.getDate()) return !1;

    case "month":
      if (s.getMonth() !== n.getMonth()) return !1;

    case "year":
      if (s.getFullYear() !== n.getFullYear()) return !1;
      break;

    default:
      throw new Error("date isSameDate unknown unit " + i);
  }

  return !0;
}

function daysInMonth(t) {
  return new Date(t.getFullYear(), t.getMonth() + 1, 0).getDate();
}

function getOrdinal(t) {
  if (t >= 11 && t <= 13) return t + "th";

  switch (t % 10) {
    case 1:
      return t + "st";

    case 2:
      return t + "nd";

    case 3:
      return t + "rd";
  }

  return t + "th";
}

var formatter = {
  YY: function YY(t, e, i) {
    var s = this.YYYY(t, e, i) % 100;
    return s > 0 ? pad(s) : "-" + pad(Math.abs(s));
  },
  YYYY: function YYYY(t, e, i) {
    return void 0 !== i && null !== i ? i : t.getFullYear();
  },
  M: function M(t) {
    return t.getMonth() + 1;
  },
  MM: function MM(t) {
    return pad(t.getMonth() + 1);
  },
  MMM: function MMM(t, e) {
    return e.monthsShort[t.getMonth()];
  },
  MMMM: function MMMM(t, e) {
    return e.months[t.getMonth()];
  },
  Q: function Q(t) {
    return Math.ceil((t.getMonth() + 1) / 3);
  },
  Qo: function Qo(t) {
    return getOrdinal(this.Q(t));
  },
  D: function D(t) {
    return t.getDate();
  },
  Do: function Do(t) {
    return getOrdinal(t.getDate());
  },
  DD: function DD(t) {
    return pad(t.getDate());
  },
  DDD: function DDD(t) {
    return getDayOfYear(t);
  },
  DDDD: function DDDD(t) {
    return pad(getDayOfYear(t), 3);
  },
  d: function d(t) {
    return t.getDay();
  },
  dd: function dd(t, e) {
    return this.dddd(t, e).slice(0, 2);
  },
  ddd: function ddd(t, e) {
    return e.daysShort[t.getDay()];
  },
  dddd: function dddd(t, e) {
    return e.days[t.getDay()];
  },
  E: function E(t) {
    return t.getDay() || 7;
  },
  w: function w(t) {
    return getWeekOfYear(t);
  },
  ww: function ww(t) {
    return pad(getWeekOfYear(t));
  },
  H: function H(t) {
    return t.getHours();
  },
  HH: function HH(t) {
    return pad(t.getHours());
  },
  h: function h(t) {
    var e = t.getHours();
    return 0 === e ? 12 : e > 12 ? e % 12 : e;
  },
  hh: function hh(t) {
    return pad(this.h(t));
  },
  m: function m(t) {
    return t.getMinutes();
  },
  mm: function mm(t) {
    return pad(t.getMinutes());
  },
  s: function s(t) {
    return t.getSeconds();
  },
  ss: function ss(t) {
    return pad(t.getSeconds());
  },
  S: function S(t) {
    return Math.floor(t.getMilliseconds() / 100);
  },
  SS: function SS(t) {
    return pad(Math.floor(t.getMilliseconds() / 10));
  },
  SSS: function SSS(t) {
    return pad(t.getMilliseconds(), 3);
  },
  A: function A(t) {
    return this.H(t) < 12 ? "AM" : "PM";
  },
  a: function a(t) {
    return this.H(t) < 12 ? "am" : "pm";
  },
  aa: function aa(t) {
    return this.H(t) < 12 ? "a.m." : "p.m.";
  },
  Z: function Z(t, e, i, s) {
    return formatTimezone(void 0 === s || null === s ? t.getTimezoneOffset() : s, ":");
  },
  ZZ: function ZZ(t, e, i, s) {
    return formatTimezone(void 0 === s || null === s ? t.getTimezoneOffset() : s);
  },
  X: function X(t) {
    return Math.floor(t.getTime() / 1e3);
  },
  x: function x(t) {
    return t.getTime();
  }
};

function formatDate(t, e, i, s, n) {
  if ((0 === t || t) && t !== 1 / 0 && t !== -1 / 0) {
    var o = new Date(t);

    if (!isNaN(o)) {
      void 0 === e && (e = defaultMask);
      var r = void 0 !== i ? i : lang.props.date;
      return e.replace(token, function (t, e) {
        return t in formatter ? formatter[t](o, r, s, n) : void 0 === e ? t : e.split("\\]").join("]");
      });
    }
  }
}

function clone(t) {
  return !0 === isDate(t) ? new Date(t.getTime()) : t;
}

var scrollPositionX,
    scrollPositionY,
    maxScrollTop,
    bodyLeft,
    bodyTop,
    closeTimer,
    date = {
  isValid: isValid,
  extractDate: extractDate,
  buildDate: buildDate,
  getDayOfWeek: getDayOfWeek,
  getWeekOfYear: getWeekOfYear,
  isBetweenDates: isBetweenDates,
  addToDate: addToDate,
  subtractFromDate: subtractFromDate,
  adjustDate: adjustDate,
  startOfDate: startOfDate,
  endOfDate: endOfDate,
  getMaxDate: getMaxDate,
  getMinDate: getMinDate,
  getDateDiff: getDateDiff,
  getDayOfYear: getDayOfYear,
  inferDateFormat: inferDateFormat,
  getDateBetween: getDateBetween,
  isSameDate: isSameDate,
  daysInMonth: daysInMonth,
  formatDate: formatDate,
  clone: clone
},
    yearsInterval = 20,
    viewIsValid = function viewIsValid(t) {
  return ["Calendar", "Years", "Months"].includes(t);
},
    QDate = vue_runtime_esm["a" /* default */].extend({
  name: "QDate",
  mixins: [DateTimeMixin],
  props: {
    title: String,
    subtitle: String,
    emitImmediately: Boolean,
    mask: {
      default: "YYYY/MM/DD"
    },
    defaultYearMonth: {
      type: String,
      validator: function validator(t) {
        return /^-?[\d]+\/[0-1]\d$/.test(t);
      }
    },
    yearsInMonthView: Boolean,
    events: [Array, Function],
    eventColor: [String, Function],
    options: [Array, Function],
    firstDayOfWeek: [String, Number],
    todayBtn: Boolean,
    minimal: Boolean,
    defaultView: {
      type: String,
      default: "Calendar",
      validator: viewIsValid
    }
  },
  data: function data() {
    var t = this.__getModels(this.value, this.mask, this.__getComputedLocale()),
        e = t.inner,
        i = t.external,
        s = !0 === this.$q.lang.rtl ? "right" : "left";

    return {
      view: this.defaultView,
      monthDirection: s,
      yearDirection: s,
      startYear: e.year - e.year % yearsInterval,
      innerModel: e,
      extModel: i
    };
  },
  watch: {
    value: function value(t) {
      var e = this,
          i = this.__getModels(t, this.mask, this.__getComputedLocale()),
          s = i.inner,
          n = i.external;

      this.extModel.dateHash === n.dateHash && this.extModel.timeHash === n.timeHash || (this.extModel = n), s.dateHash !== this.innerModel.dateHash && (this.monthDirection = this.innerModel.dateHash < s.dateHash == (!0 !== this.$q.lang.rtl) ? "left" : "right", s.year !== this.innerModel.year && (this.yearDirection = this.monthDirection), this.$nextTick(function () {
        e.startYear = s.year - s.year % yearsInterval, e.innerModel = s;
      }));
    },
    view: function view() {
      void 0 !== this.$refs.blurTarget && this.$refs.blurTarget.focus();
    }
  },
  computed: {
    classes: function classes() {
      var t = !0 === this.landscape ? "landscape" : "portrait";
      return "q-date q-date--" + t + " q-date--" + t + "-" + (!0 === this.minimal ? "minimal" : "standard") + (!0 === this.isDark ? " q-date--dark q-dark" : "") + (!0 === this.bordered ? " q-date--bordered" : "") + (!0 === this.square ? " q-date--square no-border-radius" : "") + (!0 === this.flat ? " q-date--flat no-shadow" : "") + (!0 === this.disable ? " disabled" : !0 === this.readonly ? " q-date--readonly" : "");
    },
    headerTitle: function headerTitle() {
      if (void 0 !== this.title && null !== this.title && this.title.length > 0) return this.title;
      var t,
          e = this.extModel;
      if (null === e.dateHash) return " --- ";
      if ("persian" !== this.calendar) t = new Date(e.year, e.month - 1, e.day);else {
        var i = toGregorian(e.year, e.month, e.day);
        t = new Date(i.gy, i.gm - 1, i.gd);
      }
      return !0 === isNaN(t.valueOf()) ? " --- " : void 0 !== this.computedLocale.headerTitle ? this.computedLocale.headerTitle(t, e) : this.computedLocale.daysShort[t.getDay()] + ", " + this.computedLocale.monthsShort[e.month - 1] + " " + e.day;
    },
    headerSubtitle: function headerSubtitle() {
      return void 0 !== this.subtitle && null !== this.subtitle && this.subtitle.length > 0 ? this.subtitle : null !== this.extModel.year ? this.extModel.year : " --- ";
    },
    dateArrow: function dateArrow() {
      var t = [this.$q.iconSet.datetime.arrowLeft, this.$q.iconSet.datetime.arrowRight];
      return !0 === this.$q.lang.rtl ? t.reverse() : t;
    },
    computedFirstDayOfWeek: function computedFirstDayOfWeek() {
      return void 0 !== this.firstDayOfWeek ? Number(this.firstDayOfWeek) : this.computedLocale.firstDayOfWeek;
    },
    daysOfWeek: function daysOfWeek() {
      var t = this.computedLocale.daysShort,
          e = this.computedFirstDayOfWeek;
      return e > 0 ? t.slice(e, 7).concat(t.slice(0, e)) : t;
    },
    daysInMonth: function daysInMonth() {
      return this.__getDaysInMonth(this.innerModel);
    },
    today: function today() {
      return this.__getCurrentDate();
    },
    evtFn: function evtFn() {
      var t = this;
      return "function" == typeof this.events ? this.events : function (e) {
        return t.events.includes(e);
      };
    },
    evtColor: function evtColor() {
      var t = this;
      return "function" == typeof this.eventColor ? this.eventColor : function (e) {
        return t.eventColor;
      };
    },
    isInSelection: function isInSelection() {
      var t = this;
      return "function" == typeof this.options ? this.options : function (e) {
        return t.options.includes(e);
      };
    },
    days: function days() {
      var t,
          e,
          i = [];
      if ("persian" !== this.calendar) t = new Date(this.innerModel.year, this.innerModel.month - 1, 1), e = new Date(this.innerModel.year, this.innerModel.month - 1, 0).getDate();else {
        var s = toGregorian(this.innerModel.year, this.innerModel.month, 1);
        t = new Date(s.gy, s.gm - 1, s.gd);
        var n = this.innerModel.month - 1,
            o = this.innerModel.year;
        0 === n && (n = 12, o--), e = jalaaliMonthLength(o, n);
      }
      var r = t.getDay() - this.computedFirstDayOfWeek - 1,
          a = r < 0 ? r + 7 : r;
      if (a < 6) for (var l = e - a; l <= e; l++) {
        i.push({
          i: l,
          fill: !0
        });
      }

      for (var c = i.length, u = this.innerModel.year + "/" + pad(this.innerModel.month) + "/", h = 1; h <= this.daysInMonth; h++) {
        var d = u + pad(h);
        if (void 0 !== this.options && !0 !== this.isInSelection(d)) i.push({
          i: h
        });else {
          var p = void 0 !== this.events && !0 === this.evtFn(d) && this.evtColor(d);
          i.push({
            i: h,
            in: !0,
            flat: !0,
            event: p
          });
        }
      }

      if (this.innerModel.year === this.extModel.year && this.innerModel.month === this.extModel.month) {
        var f = c + this.innerModel.day - 1;
        void 0 !== i[f] && Object.assign(i[f], {
          unelevated: !0,
          flat: !1,
          color: this.computedColor,
          textColor: this.computedTextColor
        });
      }

      this.innerModel.year === this.today.year && this.innerModel.month === this.today.month && (i[c + this.today.day - 1].today = !0);
      var m = i.length % 7;
      if (m > 0) for (var v = 7 - m, g = 1; g <= v; g++) {
        i.push({
          i: g,
          fill: !0
        });
      }
      return i;
    },
    attrs: function attrs() {
      return !0 === this.disable ? {
        "aria-disabled": ""
      } : !0 === this.readonly ? {
        "aria-readonly": ""
      } : void 0;
    }
  },
  methods: {
    setToday: function setToday() {
      this.__updateValue(Object.assign({}, this.today), "today"), this.view = "Calendar";
    },
    setView: function setView(t) {
      !0 === viewIsValid(t) && (this.view = t);
    },
    offsetCalendar: function offsetCalendar(t, e) {
      ["month", "year"].includes(t) && this["__goTo" + ("month" === t ? "Month" : "Year")](!0 === e ? -1 : 1);
    },
    __getModels: function __getModels(t, e, i) {
      var s = __splitDate(t, "persian" === this.calendar ? "YYYY/MM/DD" : e, i, this.calendar);

      return {
        external: s,
        inner: null === s.dateHash ? this.__getDefaultModel() : Object.assign({}, s)
      };
    },
    __getDefaultModel: function __getDefaultModel() {
      var t, e;

      if (void 0 !== this.defaultYearMonth) {
        var i = this.defaultYearMonth.split("/");
        t = parseInt(i[0], 10), e = parseInt(i[1], 10);
      } else {
        var s = void 0 !== this.today ? this.today : this.__getCurrentDate();
        t = s.year, e = s.month;
      }

      return {
        year: t,
        month: e,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        dateHash: t + "/" + pad(e) + "/01"
      };
    },
    __getHeader: function __getHeader(t) {
      var e = this;
      if (!0 !== this.minimal) return t("div", {
        staticClass: "q-date__header",
        class: this.headerClass
      }, [t("div", {
        staticClass: "relative-position"
      }, [t("transition", {
        props: {
          name: "q-transition--fade"
        }
      }, [t("div", {
        key: "h-yr-" + this.headerSubtitle,
        staticClass: "q-date__header-subtitle q-date__header-link",
        class: "Years" === this.view ? "q-date__header-link--active" : "cursor-pointer",
        attrs: {
          tabindex: this.computedTabindex
        },
        on: cache(this, "vY", {
          click: function click() {
            e.view = "Years";
          },
          keyup: function keyup(t) {
            13 === t.keyCode && (e.view = "Years");
          }
        })
      }, [this.headerSubtitle])])]), t("div", {
        staticClass: "q-date__header-title relative-position flex no-wrap"
      }, [t("div", {
        staticClass: "relative-position col"
      }, [t("transition", {
        props: {
          name: "q-transition--fade"
        }
      }, [t("div", {
        key: "h-sub" + this.headerTitle,
        staticClass: "q-date__header-title-label q-date__header-link",
        class: "Calendar" === this.view ? "q-date__header-link--active" : "cursor-pointer",
        attrs: {
          tabindex: this.computedTabindex
        },
        on: cache(this, "vC", {
          click: function click() {
            e.view = "Calendar";
          },
          keyup: function keyup(t) {
            13 === t.keyCode && (e.view = "Calendar");
          }
        })
      }, [this.headerTitle])])]), !0 === this.todayBtn ? t(QBtn, {
        staticClass: "q-date__header-today",
        props: {
          icon: this.$q.iconSet.datetime.today,
          flat: !0,
          size: "sm",
          round: !0,
          tabindex: this.computedTabindex
        },
        on: cache(this, "today", {
          click: this.setToday
        })
      }) : null])]);
    },
    __getNavigation: function __getNavigation(t, e) {
      var i = this,
          s = e.label,
          n = e.view,
          o = e.key,
          r = e.dir,
          a = e.goTo,
          l = e.cls;
      return [t("div", {
        staticClass: "row items-center q-date__arrow"
      }, [t(QBtn, {
        props: {
          round: !0,
          dense: !0,
          size: "sm",
          flat: !0,
          icon: this.dateArrow[0],
          tabindex: this.computedTabindex
        },
        on: cache(this, "go-#" + n, {
          click: function click() {
            a(-1);
          }
        })
      })]), t("div", {
        staticClass: "relative-position overflow-hidden flex flex-center" + l
      }, [t("transition", {
        props: {
          name: "q-transition--jump-" + r
        }
      }, [t("div", {
        key: o
      }, [t(QBtn, {
        props: {
          flat: !0,
          dense: !0,
          noCaps: !0,
          label: s,
          tabindex: this.computedTabindex
        },
        on: cache(this, "view#" + n, {
          click: function click() {
            i.view = n;
          }
        })
      })])])]), t("div", {
        staticClass: "row items-center q-date__arrow"
      }, [t(QBtn, {
        props: {
          round: !0,
          dense: !0,
          size: "sm",
          flat: !0,
          icon: this.dateArrow[1],
          tabindex: this.computedTabindex
        },
        on: cache(this, "go+#" + n, {
          click: function click() {
            a(1);
          }
        })
      })])];
    },
    __getCalendarView: function __getCalendarView(t) {
      var e = this;
      return [t("div", {
        key: "calendar-view",
        staticClass: "q-date__view q-date__calendar"
      }, [t("div", {
        staticClass: "q-date__navigation row items-center no-wrap"
      }, this.__getNavigation(t, {
        label: this.computedLocale.months[this.innerModel.month - 1],
        view: "Months",
        key: this.innerModel.month,
        dir: this.monthDirection,
        goTo: this.__goToMonth,
        cls: " col"
      }).concat(this.__getNavigation(t, {
        label: this.innerModel.year,
        view: "Years",
        key: this.innerModel.year,
        dir: this.yearDirection,
        goTo: this.__goToYear,
        cls: ""
      }))), t("div", {
        staticClass: "q-date__calendar-weekdays row items-center no-wrap"
      }, this.daysOfWeek.map(function (e) {
        return t("div", {
          staticClass: "q-date__calendar-item"
        }, [t("div", [e])]);
      })), t("div", {
        staticClass: "q-date__calendar-days-container relative-position overflow-hidden"
      }, [t("transition", {
        props: {
          name: "q-transition--slide-" + this.monthDirection
        }
      }, [t("div", {
        key: this.innerModel.year + "/" + this.innerModel.month,
        staticClass: "q-date__calendar-days fit"
      }, this.days.map(function (i) {
        return t("div", {
          staticClass: "q-date__calendar-item q-date__calendar-item--" + (!0 === i.fill ? "fill" : !0 === i.in ? "in" : "out")
        }, [!0 === i.in ? t(QBtn, {
          staticClass: !0 === i.today ? "q-date__today" : null,
          props: {
            dense: !0,
            flat: i.flat,
            unelevated: i.unelevated,
            color: i.color,
            textColor: i.textColor,
            label: i.i,
            tabindex: e.computedTabindex
          },
          on: cache(e, "day#" + i.i, {
            click: function click() {
              e.__setDay(i.i);
            }
          })
        }, !1 !== i.event ? [t("div", {
          staticClass: "q-date__event bg-" + i.event
        })] : null) : t("div", [i.i])]);
      }))])])])];
    },
    __getMonthsView: function __getMonthsView(t) {
      var e = this,
          i = this.innerModel.year === this.today.year,
          s = this.computedLocale.monthsShort.map(function (s, n) {
        var o = e.innerModel.month === n + 1;
        return t("div", {
          staticClass: "q-date__months-item flex flex-center"
        }, [t(QBtn, {
          staticClass: !0 === i && e.today.month === n + 1 ? "q-date__today" : null,
          props: {
            flat: !0 !== o,
            label: s,
            unelevated: o,
            color: !0 === o ? e.computedColor : null,
            textColor: !0 === o ? e.computedTextColor : null,
            tabindex: e.computedTabindex
          },
          on: cache(e, "month#" + n, {
            click: function click() {
              e.__setMonth(n + 1);
            }
          })
        })]);
      });
      return !0 === this.yearsInMonthView && s.unshift(t("div", {
        staticClass: "row no-wrap full-width"
      }, [this.__getNavigation(t, {
        label: this.innerModel.year,
        view: "Years",
        key: this.innerModel.year,
        dir: this.yearDirection,
        goTo: this.__goToYear,
        cls: " col"
      })])), t("div", {
        key: "months-view",
        staticClass: "q-date__view q-date__months flex flex-center"
      }, s);
    },
    __getYearsView: function __getYearsView(t) {
      for (var e = this, i = this.startYear, s = i + yearsInterval, n = [], o = function o(i) {
        var s = e.innerModel.year === i;
        n.push(t("div", {
          staticClass: "q-date__years-item flex flex-center"
        }, [t(QBtn, {
          key: "yr" + i,
          staticClass: e.today.year === i ? "q-date__today" : null,
          props: {
            flat: !s,
            label: i,
            dense: !0,
            unelevated: s,
            color: s ? e.computedColor : null,
            textColor: s ? e.computedTextColor : null,
            tabindex: e.computedTabindex
          },
          on: cache(e, "yr#" + i, {
            click: function click() {
              e.__setYear(i);
            }
          })
        })]));
      }, r = i; r <= s; r++) {
        o(r);
      }

      return t("div", {
        staticClass: "q-date__view q-date__years flex flex-center"
      }, [t("div", {
        staticClass: "col-auto"
      }, [t(QBtn, {
        props: {
          round: !0,
          dense: !0,
          flat: !0,
          icon: this.dateArrow[0],
          tabindex: this.computedTabindex
        },
        on: cache(this, "y-", {
          click: function click() {
            e.startYear -= yearsInterval;
          }
        })
      })]), t("div", {
        staticClass: "q-date__years-content col self-stretch row items-center"
      }, n), t("div", {
        staticClass: "col-auto"
      }, [t(QBtn, {
        props: {
          round: !0,
          dense: !0,
          flat: !0,
          icon: this.dateArrow[1],
          tabindex: this.computedTabindex
        },
        on: cache(this, "y+", {
          click: function click() {
            e.startYear += yearsInterval;
          }
        })
      })])]);
    },
    __getDaysInMonth: function __getDaysInMonth(t) {
      return "persian" !== this.calendar ? new Date(t.year, t.month, 0).getDate() : jalaaliMonthLength(t.year, t.month);
    },
    __goToMonth: function __goToMonth(t) {
      var e = Number(this.innerModel.month) + t,
          i = this.yearDirection;
      13 === e ? (e = 1, this.innerModel.year++, i = !0 !== this.$q.lang.rtl ? "left" : "right") : 0 === e && (e = 12, this.innerModel.year--, i = !0 !== this.$q.lang.rtl ? "right" : "left"), this.monthDirection = t > 0 == (!0 !== this.$q.lang.rtl) ? "left" : "right", this.yearDirection = i, this.innerModel.month = e, !0 === this.emitImmediately && this.__updateValue({}, "month");
    },
    __goToYear: function __goToYear(t) {
      this.monthDirection = this.yearDirection = t > 0 == (!0 !== this.$q.lang.rtl) ? "left" : "right", this.innerModel.year = Number(this.innerModel.year) + t, !0 === this.emitImmediately && this.__updateValue({}, "year");
    },
    __setYear: function __setYear(t) {
      this.innerModel.year = t, !0 === this.emitImmediately && this.__updateValue({
        year: t
      }, "year"), this.view = null === this.extModel.month || "Years" === this.defaultView ? "Months" : "Calendar";
    },
    __setMonth: function __setMonth(t) {
      this.innerModel.month = t, !0 === this.emitImmediately && this.__updateValue({
        month: t
      }, "month"), this.view = "Calendar";
    },
    __setDay: function __setDay(t) {
      this.__updateValue({
        day: t
      }, "day");
    },
    __updateValue: function __updateValue(t, e) {
      var i = this;

      if (void 0 === t.year && (t.year = this.innerModel.year), void 0 === t.month && (t.month = this.innerModel.month), void 0 === t.day || !0 === this.emitImmediately && ("year" === e || "month" === e)) {
        t.day = this.innerModel.day;
        var s = !0 === this.emitImmediately ? this.__getDaysInMonth(t) : this.daysInMonth;
        t.day = Math.min(Math.max(1, t.day), s);
      }

      var n = "persian" === this.calendar ? t.year + "/" + pad(t.month) + "/" + pad(t.day) : formatDate(new Date(t.year, t.month - 1, t.day, this.extModel.hour, this.extModel.minute, this.extModel.second, this.extModel.millisecond), this.mask, this.computedLocale, t.year, this.extModel.timezoneOffset);

      if (t.changed = n !== this.value, this.$emit("input", n, e, t), n === this.value && "today" === e) {
        var o = t.year + "/" + pad(t.month) + "/" + pad(t.day),
            r = this.innerModel.year + "/" + pad(this.innerModel.month) + "/" + pad(this.innerModel.day);
        o !== r && (this.monthDirection = r < o == (!0 !== this.$q.lang.rtl) ? "left" : "right", t.year !== this.innerModel.year && (this.yearDirection = this.monthDirection), this.$nextTick(function () {
          i.startYear = t.year - t.year % yearsInterval, Object.assign(i.innerModel, {
            year: t.year,
            month: t.month,
            day: t.day,
            dateHash: o
          });
        }));
      }
    }
  },
  render: function render(t) {
    var e = [t("div", {
      staticClass: "q-date__content col relative-position"
    }, [t("transition", {
      props: {
        name: "q-transition--fade"
      }
    }, [this["__get" + this.view + "View"](t)])])],
        i = slot(this, "default");
    return void 0 !== i && e.push(t("div", {
      staticClass: "q-date__actions"
    }, i)), void 0 !== this.name && !0 !== this.disable && this.__injectFormInput(e, "push"), t("div", {
      class: this.classes,
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    }, [this.__getHeader(t), t("div", {
      staticClass: "q-date__main col column",
      attrs: {
        tabindex: -1
      },
      ref: "blurTarget"
    }, e)]);
  }
}),
    HistoryMixin = {
  methods: {
    __addHistory: function __addHistory() {
      var t = this;
      this.__historyEntry = {
        condition: function condition() {
          return !0 === t.hideOnRouteChange;
        },
        handler: this.hide
      }, History.add(this.__historyEntry);
    },
    __removeHistory: function __removeHistory() {
      void 0 !== this.__historyEntry && (History.remove(this.__historyEntry), this.__historyEntry = void 0);
    }
  },
  beforeDestroy: function beforeDestroy() {
    !0 === this.showing && this.__removeHistory();
  }
},
    registered = 0,
    vpPendingUpdate = !1;

function onWheel(t) {
  shouldPreventScroll(t) && stopAndPrevent(t);
}

function shouldPreventScroll(t) {
  if (t.target === document.body || t.target.classList.contains("q-layout__backdrop")) return !0;

  for (var e = getEventPath(t), i = t.shiftKey && !t.deltaX, s = !i && Math.abs(t.deltaX) <= Math.abs(t.deltaY), n = i || s ? t.deltaY : t.deltaX, o = 0; o < e.length; o++) {
    var r = e[o];
    if (hasScrollbar(r, s)) return s ? n < 0 && 0 === r.scrollTop || n > 0 && r.scrollTop + r.clientHeight === r.scrollHeight : n < 0 && 0 === r.scrollLeft || n > 0 && r.scrollLeft + r.clientWidth === r.scrollWidth;
  }

  return !0;
}

function onAppleScroll(t) {
  t.target === document && (document.scrollingElement.scrollTop = document.scrollingElement.scrollTop);
}

function onAppleResize(t) {
  !0 !== vpPendingUpdate && (vpPendingUpdate = !0, requestAnimationFrame(function () {
    vpPendingUpdate = !1;
    var e = t.target.height,
        i = document.scrollingElement,
        s = i.clientHeight,
        n = i.scrollTop;
    void 0 !== maxScrollTop && e === window.innerHeight || (maxScrollTop = s - e, document.scrollingElement.scrollTop = n), n > maxScrollTop && (document.scrollingElement.scrollTop -= Math.ceil((n - maxScrollTop) / 8));
  }));
}

function apply(t) {
  var e = document.body,
      i = void 0 !== window.visualViewport;

  if ("add" === t) {
    var s = window.getComputedStyle(e).overflowY;
    scrollPositionX = getHorizontalScrollPosition(window), scrollPositionY = getScrollPosition(window), bodyLeft = e.style.left, bodyTop = e.style.top, e.style.left = "-" + scrollPositionX + "px", e.style.top = "-" + scrollPositionY + "px", "hidden" !== s && ("scroll" === s || e.scrollHeight > window.innerHeight) && e.classList.add("q-body--force-scrollbar"), e.classList.add("q-body--prevent-scroll"), document.qScrollPrevented = !0, !0 === client.is.ios && (!0 === i ? (window.scrollTo(0, 0), window.visualViewport.addEventListener("resize", onAppleResize, listenOpts.passiveCapture), window.visualViewport.addEventListener("scroll", onAppleResize, listenOpts.passiveCapture), window.scrollTo(0, 0)) : window.addEventListener("scroll", onAppleScroll, listenOpts.passiveCapture));
  }

  !0 === client.is.desktop && !0 === client.is.mac && window[t + "EventListener"]("wheel", onWheel, listenOpts.notPassive), "remove" === t && (!0 === client.is.ios && (!0 === i ? (window.visualViewport.removeEventListener("resize", onAppleResize, listenOpts.passiveCapture), window.visualViewport.removeEventListener("scroll", onAppleResize, listenOpts.passiveCapture)) : window.removeEventListener("scroll", onAppleScroll, listenOpts.passiveCapture)), e.classList.remove("q-body--prevent-scroll"), e.classList.remove("q-body--force-scrollbar"), document.qScrollPrevented = !1, e.style.left = bodyLeft, e.style.top = bodyTop, window.scrollTo(scrollPositionX, scrollPositionY), maxScrollTop = void 0);
}

function preventScroll(t) {
  var e = "add";

  if (!0 === t) {
    if (registered++, void 0 !== closeTimer) return clearTimeout(closeTimer), void (closeTimer = void 0);
    if (registered > 1) return;
  } else {
    if (0 === registered) return;
    if (--registered > 0) return;
    if (e = "remove", !0 === client.is.ios && !0 === client.is.nativeMobile) return clearTimeout(closeTimer), void (closeTimer = setTimeout(function () {
      apply(e), closeTimer = void 0;
    }, 100));
  }

  apply(e);
}

for (var buf, PreventScrollMixin = {
  methods: {
    __preventScroll: function __preventScroll(t) {
      t === this.preventedScroll || void 0 === this.preventedScroll && !0 !== t || (this.preventedScroll = t, preventScroll(t));
    }
  }
}, maximizedModals = 0, positionClass = {
  standard: "fixed-full flex-center",
  top: "fixed-top justify-center",
  bottom: "fixed-bottom justify-center",
  right: "fixed-right items-center",
  left: "fixed-left items-center"
}, transitions = {
  standard: ["scale", "scale"],
  top: ["slide-down", "slide-up"],
  bottom: ["slide-up", "slide-down"],
  right: ["slide-left", "slide-right"],
  left: ["slide-right", "slide-left"]
}, QDialog = vue_runtime_esm["a" /* default */].extend({
  name: "QDialog",
  mixins: [AttrsMixin, HistoryMixin, ModelToggleMixin, PortalMixin, PreventScrollMixin],
  props: {
    persistent: Boolean,
    autoClose: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    position: {
      type: String,
      default: "standard",
      validator: function validator(t) {
        return "standard" === t || ["top", "bottom", "left", "right"].includes(t);
      }
    },
    transitionShow: String,
    transitionHide: String
  },
  data: function data() {
    return {
      transitionState: this.showing
    };
  },
  watch: {
    showing: function showing(t) {
      var e = this;
      this.transitionShowComputed !== this.transitionHideComputed && this.$nextTick(function () {
        e.transitionState = t;
      });
    },
    maximized: function maximized(t) {
      !0 === this.showing && this.__updateMaximized(t);
    },
    useBackdrop: function useBackdrop(t) {
      this.__preventScroll(t), this.__preventFocusout(t);
    }
  },
  computed: {
    classes: function classes() {
      return "q-dialog__inner--" + (!0 === this.maximized ? "maximized" : "minimized") + " q-dialog__inner--" + this.position + " " + positionClass[this.position] + (!0 === this.fullWidth ? " q-dialog__inner--fullwidth" : "") + (!0 === this.fullHeight ? " q-dialog__inner--fullheight" : "") + (!0 === this.square ? " q-dialog__inner--square" : "");
    },
    transitionShowComputed: function transitionShowComputed() {
      return "q-transition--" + (void 0 === this.transitionShow ? transitions[this.position][0] : this.transitionShow);
    },
    transitionHideComputed: function transitionHideComputed() {
      return "q-transition--" + (void 0 === this.transitionHide ? transitions[this.position][1] : this.transitionHide);
    },
    transition: function transition() {
      return !0 === this.transitionState ? this.transitionHideComputed : this.transitionShowComputed;
    },
    useBackdrop: function useBackdrop() {
      return !0 === this.showing && !0 !== this.seamless;
    },
    hideOnRouteChange: function hideOnRouteChange() {
      return !0 !== this.persistent && !0 !== this.noRouteDismiss && !0 !== this.seamless;
    },
    onEvents: function onEvents() {
      var t = Object.assign({}, this.qListeners, {
        input: stop,
        "popup-show": stop,
        "popup-hide": stop
      });
      return !0 === this.autoClose && (t.click = this.__onAutoClose), t;
    }
  },
  methods: {
    focus: function focus() {
      var t = this.__getInnerNode();

      void 0 !== t && !0 !== t.contains(document.activeElement) && (t = t.querySelector("[autofocus], [data-autofocus]") || t).focus();
    },
    shake: function shake() {
      this.focus(), this.$emit("shake");

      var t = this.__getInnerNode();

      void 0 !== t && (t.classList.remove("q-animate--scale"), t.classList.add("q-animate--scale"), clearTimeout(this.shakeTimeout), this.shakeTimeout = setTimeout(function () {
        t.classList.remove("q-animate--scale");
      }, 170));
    },
    __getInnerNode: function __getInnerNode() {
      return void 0 !== this.__portal && void 0 !== this.__portal.$refs ? this.__portal.$refs.inner : void 0;
    },
    __show: function __show(t) {
      var e = this;
      this.__addHistory(), this.__refocusTarget = !1 === this.noRefocus && null !== document.activeElement ? document.activeElement : void 0, this.$el.dispatchEvent(create("popup-show", {
        bubbles: !0
      })), this.__updateMaximized(this.maximized), EscapeKey.register(this, function () {
        !0 !== e.seamless && (!0 === e.persistent || !0 === e.noEscDismiss ? !0 !== e.maximized && e.shake() : (e.$emit("escape-key"), e.hide()));
      }), this.__showPortal(), !0 !== this.noFocus && (null !== document.activeElement && document.activeElement.blur(), this.__nextTick(this.focus)), this.__setTimeout(function () {
        if (!0 === e.$q.platform.is.ios) {
          if (!0 !== e.seamless && document.activeElement) {
            var i = document.activeElement.getBoundingClientRect(),
                s = i.top,
                n = i.bottom,
                o = window.innerHeight,
                r = void 0 !== window.visualViewport ? window.visualViewport.height : o;

            if (s > 0 && n > r / 2) {
              var a = Math.min(document.scrollingElement.scrollHeight - r, n >= o ? 1 / 0 : Math.ceil(document.scrollingElement.scrollTop + n - r / 2)),
                  l = function l() {
                requestAnimationFrame(function () {
                  document.scrollingElement.scrollTop += Math.ceil((a - document.scrollingElement.scrollTop) / 8), document.scrollingElement.scrollTop !== a && l();
                });
              };

              l();
            }

            document.activeElement.scrollIntoView();
          }

          e.__portal.$el.click();
        }

        e.$emit("show", t);
      }, 300);
    },
    __hide: function __hide(t) {
      var e = this;
      this.__removeHistory(), this.__cleanup(!0), void 0 !== this.__refocusTarget && null !== this.__refocusTarget && this.__refocusTarget.focus(), this.$el.dispatchEvent(create("popup-hide", {
        bubbles: !0
      })), this.__setTimeout(function () {
        e.__hidePortal(), e.$emit("hide", t);
      }, 300);
    },
    __cleanup: function __cleanup(t) {
      clearTimeout(this.shakeTimeout), !0 !== t && !0 !== this.showing || (EscapeKey.pop(this), this.__updateMaximized(!1), !0 !== this.seamless && (this.__preventScroll(!1), this.__preventFocusout(!1)));
    },
    __updateMaximized: function __updateMaximized(t) {
      !0 === t ? !0 !== this.isMaximized && (maximizedModals < 1 && document.body.classList.add("q-body--dialog"), maximizedModals++, this.isMaximized = !0) : !0 === this.isMaximized && (maximizedModals < 2 && document.body.classList.remove("q-body--dialog"), maximizedModals--, this.isMaximized = !1);
    },
    __preventFocusout: function __preventFocusout(t) {
      if (!0 === this.$q.platform.is.desktop) {
        var e = (!0 === t ? "add" : "remove") + "EventListener";
        document.body[e]("focusin", this.__onFocusChange);
      }
    },
    __onAutoClose: function __onAutoClose(t) {
      this.hide(t), void 0 !== this.qListeners.click && this.$emit("click", t);
    },
    __onBackdropClick: function __onBackdropClick(t) {
      !0 !== this.persistent && !0 !== this.noBackdropDismiss ? this.hide(t) : this.shake();
    },
    __onFocusChange: function __onFocusChange(t) {
      !0 === this.showing && void 0 !== this.__portal && !0 !== childHasFocus(this.__portal.$el, t.target) && this.focus();
    },
    __renderPortal: function __renderPortal(t) {
      return t("div", {
        staticClass: "q-dialog fullscreen no-pointer-events",
        class: this.contentClass,
        style: this.contentStyle,
        attrs: this.qAttrs
      }, [t("transition", {
        props: {
          name: "q-transition--fade"
        }
      }, !0 === this.useBackdrop ? [t("div", {
        staticClass: "q-dialog__backdrop fixed-full",
        on: cache(this, "bkdrop", {
          click: this.__onBackdropClick
        })
      })] : null), t("transition", {
        props: {
          name: this.transition
        }
      }, [!0 === this.showing ? t("div", {
        ref: "inner",
        staticClass: "q-dialog__inner flex no-pointer-events",
        class: this.classes,
        attrs: {
          tabindex: -1
        },
        on: this.onEvents
      }, slot(this, "default")) : null])]);
    }
  },
  mounted: function mounted() {
    this.__processModelChange(this.value);
  },
  beforeDestroy: function beforeDestroy() {
    this.__cleanup();
  }
}), duration = 150, mouseEvents = ["mouseover", "mouseout", "mouseenter", "mouseleave"], QDrawer = vue_runtime_esm["a" /* default */].extend({
  name: "QDrawer",
  inject: {
    layout: {
      default: function _default() {
        console.error("QDrawer needs to be child of QLayout");
      }
    }
  },
  mixins: [DarkMixin, HistoryMixin, ModelToggleMixin, PreventScrollMixin],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    side: {
      type: String,
      default: "left",
      validator: function validator(t) {
        return ["left", "right"].includes(t);
      }
    },
    width: {
      type: Number,
      default: 300
    },
    mini: Boolean,
    miniToOverlay: Boolean,
    miniWidth: {
      type: Number,
      default: 57
    },
    breakpoint: {
      type: Number,
      default: 1023
    },
    showIfAbove: Boolean,
    behavior: {
      type: String,
      validator: function validator(t) {
        return ["default", "desktop", "mobile"].includes(t);
      },
      default: "default"
    },
    bordered: Boolean,
    elevated: Boolean,
    contentStyle: [String, Object, Array],
    contentClass: [String, Object, Array],
    overlay: Boolean,
    persistent: Boolean,
    noSwipeOpen: Boolean,
    noSwipeClose: Boolean,
    noSwipeBackdrop: Boolean
  },
  data: function data() {
    var t = "mobile" === this.behavior || "desktop" !== this.behavior && this.layout.totalWidth <= this.breakpoint;
    return {
      belowBreakpoint: t,
      showing: !0 === this.showIfAbove && !1 === t || !0 === this.value
    };
  },
  watch: {
    belowBreakpoint: function belowBreakpoint(t) {
      !0 === t ? (this.lastDesktopState = this.showing, !0 === this.showing && this.hide(!1)) : !1 === this.overlay && "mobile" !== this.behavior && !1 !== this.lastDesktopState && (!0 === this.showing ? (this.__applyPosition(0), this.__applyBackdrop(0), this.__cleanup()) : this.show(!1));
    },
    "layout.totalWidth": function layoutTotalWidth(t) {
      this.__updateLocal("belowBreakpoint", "mobile" === this.behavior || "desktop" !== this.behavior && t <= this.breakpoint);
    },
    side: function side(t, e) {
      this.layout.instances[e] === this && (this.layout.instances[e] = void 0, this.layout[e].space = !1, this.layout[e].offset = 0), this.layout.instances[t] = this, this.layout[t].size = this.size, this.layout[t].space = this.onLayout, this.layout[t].offset = this.offset;
    },
    behavior: function behavior(t) {
      this.__updateLocal("belowBreakpoint", "mobile" === t || "desktop" !== t && this.layout.totalWidth <= this.breakpoint);
    },
    breakpoint: function breakpoint(t) {
      this.__updateLocal("belowBreakpoint", "mobile" === this.behavior || "desktop" !== this.behavior && this.layout.totalWidth <= t);
    },
    "layout.container": function layoutContainer(t) {
      !0 === this.showing && this.__preventScroll(!0 !== t);
    },
    "layout.scrollbarWidth": function layoutScrollbarWidth() {
      this.__applyPosition(!0 === this.showing ? 0 : void 0);
    },
    offset: function offset(t) {
      this.__update("offset", t);
    },
    onLayout: function onLayout(t) {
      this.$emit("on-layout", t), this.__update("space", t);
    },
    rightSide: function rightSide() {
      this.__applyPosition();
    },
    size: function size(t) {
      this.__applyPosition(), this.__updateSizeOnLayout(this.miniToOverlay, t);
    },
    miniToOverlay: function miniToOverlay(t) {
      this.__updateSizeOnLayout(t, this.size);
    },
    "$q.lang.rtl": function $qLangRtl() {
      this.__applyPosition();
    },
    mini: function mini() {
      !0 === this.value && (this.__animateMini(), this.layout.__animate());
    },
    isMini: function isMini(t) {
      this.$emit("mini-state", t);
    }
  },
  computed: {
    rightSide: function rightSide() {
      return "right" === this.side;
    },
    otherSide: function otherSide() {
      return !0 === this.rightSide ? "left" : "right";
    },
    offset: function offset() {
      return !0 === this.showing && !1 === this.belowBreakpoint && !1 === this.overlay ? !0 === this.miniToOverlay ? this.miniWidth : this.size : 0;
    },
    size: function size() {
      return !0 === this.isMini ? this.miniWidth : this.width;
    },
    fixed: function fixed() {
      return !0 === this.overlay || !0 === this.miniToOverlay || this.layout.view.indexOf(this.rightSide ? "R" : "L") > -1 || this.$q.platform.is.ios && !0 === this.layout.container;
    },
    onLayout: function onLayout() {
      return !0 === this.showing && !1 === this.belowBreakpoint && !1 === this.overlay;
    },
    onScreenOverlay: function onScreenOverlay() {
      return !0 === this.showing && !1 === this.belowBreakpoint && !0 === this.overlay;
    },
    backdropClass: function backdropClass() {
      return !1 === this.showing ? "no-pointer-events" : null;
    },
    headerSlot: function headerSlot() {
      return !0 === this.rightSide ? "r" === this.layout.rows.top[2] : "l" === this.layout.rows.top[0];
    },
    footerSlot: function footerSlot() {
      return !0 === this.rightSide ? "r" === this.layout.rows.bottom[2] : "l" === this.layout.rows.bottom[0];
    },
    aboveStyle: function aboveStyle() {
      var t = {};
      return !0 === this.layout.header.space && !1 === this.headerSlot && (!0 === this.fixed ? t.top = this.layout.header.offset + "px" : !0 === this.layout.header.space && (t.top = this.layout.header.size + "px")), !0 === this.layout.footer.space && !1 === this.footerSlot && (!0 === this.fixed ? t.bottom = this.layout.footer.offset + "px" : !0 === this.layout.footer.space && (t.bottom = this.layout.footer.size + "px")), t;
    },
    style: function style() {
      var t = {
        width: this.size + "px"
      };
      return !0 === this.belowBreakpoint ? t : Object.assign(t, this.aboveStyle);
    },
    classes: function classes() {
      return "q-drawer--" + this.side + (!0 === this.bordered ? " q-drawer--bordered" : "") + (!0 === this.isDark ? " q-drawer--dark q-dark" : "") + (!0 !== this.showing ? " q-layout--prevent-focus" : "") + (!0 === this.belowBreakpoint ? " fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding" : " q-drawer--" + (!0 === this.isMini ? "mini" : "standard") + (!0 === this.fixed || !0 !== this.onLayout ? " fixed" : "") + (!0 === this.overlay || !0 === this.miniToOverlay ? " q-drawer--on-top" : "") + (!0 === this.headerSlot ? " q-drawer--top-padding" : ""));
    },
    stateDirection: function stateDirection() {
      return (!0 === this.$q.lang.rtl ? -1 : 1) * (!0 === this.rightSide ? 1 : -1);
    },
    isMini: function isMini() {
      return !0 === this.mini && !0 !== this.belowBreakpoint;
    },
    onNativeEvents: function onNativeEvents() {
      var t = this;

      if (!0 !== this.belowBreakpoint) {
        var e = {
          "!click": function click(e) {
            t.$emit("click", e);
          }
        };
        return mouseEvents.forEach(function (i) {
          e[i] = function (e) {
            void 0 !== t.qListeners[i] && t.$emit(i, e);
          };
        }), e;
      }
    },
    hideOnRouteChange: function hideOnRouteChange() {
      return !0 !== this.persistent && (!0 === this.belowBreakpoint || !0 === this.onScreenOverlay);
    },
    openDirective: function openDirective() {
      var t,
          e = !0 === this.$q.lang.rtl ? this.side : this.otherSide;
      return [{
        name: "touch-pan",
        value: this.__openByTouch,
        modifiers: (t = {}, t[e] = !0, t.mouse = !0, t)
      }];
    },
    contentCloseDirective: function contentCloseDirective() {
      var t;

      if (!0 !== this.noSwipeClose) {
        var e = !0 === this.$q.lang.rtl ? this.otherSide : this.side;
        return [{
          name: "touch-pan",
          value: this.__closeByTouch,
          modifiers: (t = {}, t[e] = !0, t.mouse = !0, t)
        }];
      }
    },
    backdropCloseDirective: function backdropCloseDirective() {
      var t;

      if (!0 !== this.noSwipeBackdrop) {
        var e = !0 === this.$q.lang.rtl ? this.otherSide : this.side;
        return [{
          name: "touch-pan",
          value: this.__closeByTouch,
          modifiers: (t = {}, t[e] = !0, t.mouse = !0, t.mouseAllDir = !0, t)
        }];
      }
    }
  },
  methods: {
    __applyPosition: function __applyPosition(t) {
      var e = this;
      void 0 === t ? this.$nextTick(function () {
        t = !0 === e.showing ? 0 : e.size, e.__applyPosition(e.stateDirection * t);
      }) : void 0 !== this.$refs.content && (!0 !== this.layout.container || !0 !== this.rightSide || !0 !== this.belowBreakpoint && Math.abs(t) !== this.size || (t += this.stateDirection * this.layout.scrollbarWidth), this.__lastPosition !== t && (this.$refs.content.style.transform = "translateX(" + t + "px)", this.__lastPosition = t));
    },
    __applyBackdrop: function __applyBackdrop(t, e) {
      var i = this;
      void 0 !== this.$refs.backdrop ? this.$refs.backdrop.style.backgroundColor = this.lastBackdropBg = "rgba(0,0,0," + .4 * t + ")" : !0 !== e && this.$nextTick(function () {
        i.__applyBackdrop(t, !0);
      });
    },
    __setScrollable: function __setScrollable(t) {
      var e = !0 === t ? "remove" : !0 !== this.layout.container ? "add" : "";
      "" !== e && document.body.classList[e]("q-body--drawer-toggle");
    },
    __animateMini: function __animateMini() {
      var t = this;
      void 0 !== this.timerMini ? clearTimeout(this.timerMini) : void 0 !== this.$el && this.$el.classList.add("q-drawer--mini-animate"), this.timerMini = setTimeout(function () {
        void 0 !== t.$el && t.$el.classList.remove("q-drawer--mini-animate"), t.timerMini = void 0;
      }, 150);
    },
    __openByTouch: function __openByTouch(t) {
      if (!1 === this.showing) {
        var e = this.size,
            i = between(t.distance.x, 0, e);

        if (!0 === t.isFinal) {
          var s = this.$refs.content,
              n = i >= Math.min(75, e);
          return s.classList.remove("no-transition"), void (!0 === n ? this.show() : (this.layout.__animate(), this.__applyBackdrop(0), this.__applyPosition(this.stateDirection * e), s.classList.remove("q-drawer--delimiter"), s.classList.add("q-layout--prevent-focus")));
        }

        if (this.__applyPosition((!0 === this.$q.lang.rtl ? !0 !== this.rightSide : this.rightSide) ? Math.max(e - i, 0) : Math.min(0, i - e)), this.__applyBackdrop(between(i / e, 0, 1)), !0 === t.isFirst) {
          var o = this.$refs.content;
          o.classList.add("no-transition"), o.classList.add("q-drawer--delimiter"), o.classList.remove("q-layout--prevent-focus");
        }
      }
    },
    __closeByTouch: function __closeByTouch(t) {
      if (!0 === this.showing) {
        var e = this.size,
            i = t.direction === this.side,
            s = (!0 === this.$q.lang.rtl ? !0 !== i : i) ? between(t.distance.x, 0, e) : 0;

        if (!0 === t.isFinal) {
          var n = Math.abs(s) < Math.min(75, e);
          return this.$refs.content.classList.remove("no-transition"), void (!0 === n ? (this.layout.__animate(), this.__applyBackdrop(1), this.__applyPosition(0)) : this.hide());
        }

        this.__applyPosition(this.stateDirection * s), this.__applyBackdrop(between(1 - s / e, 0, 1)), !0 === t.isFirst && this.$refs.content.classList.add("no-transition");
      }
    },
    __show: function __show(t, e) {
      var i = this;

      if (this.__addHistory(), !1 !== t && this.layout.__animate(), this.__applyPosition(0), !0 === this.belowBreakpoint) {
        var s = this.layout.instances[this.otherSide];
        void 0 !== s && !0 === s.belowBreakpoint && s.hide(!1), this.__applyBackdrop(1), !0 !== this.layout.container && this.__preventScroll(!0);
      } else this.__applyBackdrop(0), !1 !== t && this.__setScrollable(!1);

      this.__setTimeout(function () {
        !1 !== t && i.__setScrollable(!0), !0 !== e && i.$emit("show", t);
      }, duration);
    },
    __hide: function __hide(t, e) {
      var i = this;
      this.__removeHistory(), !1 !== t && this.layout.__animate(), this.__applyBackdrop(0), this.__applyPosition(this.stateDirection * this.size), this.__cleanup(), !0 !== e && this.__setTimeout(function () {
        i.$emit("hide", t);
      }, duration);
    },
    __cleanup: function __cleanup() {
      this.__preventScroll(!1), this.__setScrollable(!0);
    },
    __update: function __update(t, e) {
      this.layout[this.side][t] !== e && (this.layout[this.side][t] = e);
    },
    __updateLocal: function __updateLocal(t, e) {
      this[t] !== e && (this[t] = e);
    },
    __updateSizeOnLayout: function __updateSizeOnLayout(t, e) {
      this.__update("size", !0 === t ? this.miniWidth : e);
    }
  },
  created: function created() {
    this.layout.instances[this.side] = this, this.__updateSizeOnLayout(this.miniToOverlay, this.size), this.__update("space", this.onLayout), this.__update("offset", this.offset), !0 === this.showIfAbove && !0 !== this.value && !0 === this.showing && void 0 !== this.qListeners.input && this.$emit("input", !0);
  },
  mounted: function mounted() {
    var t = this;
    this.$emit("on-layout", this.onLayout), this.$emit("mini-state", this.isMini), this.lastDesktopState = !0 === this.showIfAbove;

    var e = function e() {
      var e = !0 === t.showing ? "show" : "hide";
      t["__" + e](!1, !0);
    };

    0 === this.layout.totalWidth ? this.watcher = this.$watch("layout.totalWidth", function () {
      t.watcher(), t.watcher = void 0, !1 === t.showing && !0 === t.showIfAbove && !1 === t.belowBreakpoint ? t.show(!1) : e();
    }) : e();
  },
  beforeDestroy: function beforeDestroy() {
    void 0 !== this.watcher && this.watcher(), clearTimeout(this.timerMini), !0 === this.showing && this.__cleanup(), this.layout.instances[this.side] === this && (this.layout.instances[this.side] = void 0, this.__update("size", 0), this.__update("offset", 0), this.__update("space", !1));
  },
  render: function render(t) {
    var e = [];
    !0 === this.belowBreakpoint && (!0 !== this.noSwipeOpen && e.push(t("div", {
      staticClass: "q-drawer__opener fixed-" + this.side,
      directives: this.openDirective
    })), e.push(t("div", {
      ref: "backdrop",
      staticClass: "fullscreen q-drawer__backdrop",
      class: this.backdropClass,
      style: void 0 !== this.lastBackdropBg ? {
        backgroundColor: this.lastBackdropBg
      } : null,
      on: cache(this, "bkdrop", {
        click: this.hide
      }),
      directives: this.backdropCloseDirective
    })));
    var i = [t("div", {
      staticClass: "q-drawer__content fit " + (!0 === this.layout.container ? "overflow-auto" : "scroll"),
      class: this.contentClass,
      style: this.contentStyle
    }, !0 === this.isMini && void 0 !== this.$scopedSlots.mini ? this.$scopedSlots.mini() : slot(this, "default"))];
    return !0 === this.elevated && !0 === this.showing && i.push(t("div", {
      staticClass: "q-layout__shadow absolute-full overflow-hidden no-pointer-events"
    })), e.push(t("aside", {
      ref: "content",
      staticClass: "q-drawer",
      class: this.classes,
      style: this.style,
      on: this.onNativeEvents,
      directives: !0 === this.belowBreakpoint ? this.contentCloseDirective : void 0
    }, i)), t("div", {
      staticClass: "q-drawer-container"
    }, e);
  }
}), lazyRulesValues = [!0, !1, "ondemand"], ValidateMixin = {
  props: {
    value: {},
    error: {
      type: Boolean,
      default: null
    },
    errorMessage: String,
    noErrorIcon: Boolean,
    rules: Array,
    reactiveRules: Boolean,
    lazyRules: {
      type: [Boolean, String],
      validator: function validator(t) {
        return lazyRulesValues.includes(t);
      }
    }
  },
  data: function data() {
    return {
      isDirty: null,
      innerError: !1,
      innerErrorMessage: void 0
    };
  },
  watch: {
    value: function value() {
      this.__validateIfNeeded();
    },
    reactiveRules: {
      handler: function handler(t) {
        var e = this;
        !0 === t ? void 0 === this.unwatchRules && (this.unwatchRules = this.$watch("rules", function () {
          e.__validateIfNeeded(!0);
        })) : void 0 !== this.unwatchRules && (this.unwatchRules(), this.unwatchRules = void 0);
      },
      immediate: !0
    },
    focused: function focused(t) {
      "ondemand" !== this.lazyRules && (!0 === t ? null === this.isDirty && (this.isDirty = !1) : !1 === this.isDirty && !0 === this.hasRules && (this.isDirty = !0, this.validate()));
    }
  },
  computed: {
    hasRules: function hasRules() {
      return void 0 !== this.rules && null !== this.rules && this.rules.length > 0;
    },
    hasError: function hasError() {
      return !0 === this.error || !0 === this.innerError;
    },
    computedErrorMessage: function computedErrorMessage() {
      return "string" == typeof this.errorMessage && this.errorMessage.length > 0 ? this.errorMessage : this.innerErrorMessage;
    }
  },
  mounted: function mounted() {
    this.validateIndex = 0;
  },
  beforeDestroy: function beforeDestroy() {
    void 0 !== this.unwatchRules && this.unwatchRules();
  },
  methods: {
    resetValidation: function resetValidation() {
      this.validateIndex++, this.innerLoading = !1, this.isDirty = null, this.innerError = !1, this.innerErrorMessage = void 0;
    },
    validate: function validate(t) {
      var e = this;
      if (void 0 === t && (t = this.value), !0 !== this.hasRules) return !0;
      this.validateIndex++, !0 !== this.innerLoading && !0 !== this.lazyRules && (this.isDirty = !0);

      for (var i = function i(t, _i) {
        e.innerError !== t && (e.innerError = t);
        var s = _i || void 0;
        e.innerErrorMessage !== s && (e.innerErrorMessage = s), !1 !== e.innerLoading && (e.innerLoading = !1);
      }, s = [], n = 0; n < this.rules.length; n++) {
        var o = this.rules[n],
            r = void 0;
        if ("function" == typeof o ? r = o(t) : "string" == typeof o && void 0 !== testPattern[o] && (r = testPattern[o](t)), !1 === r || "string" == typeof r) return i(!0, r), !1;
        !0 !== r && void 0 !== r && s.push(r);
      }

      if (0 === s.length) return i(!1), !0;
      !0 !== this.innerLoading && (this.innerLoading = !0);
      var a = this.validateIndex;
      return Promise.all(s).then(function (t) {
        if (a !== e.validateIndex) return !0;
        if (void 0 === t || !1 === Array.isArray(t) || 0 === t.length) return i(!1), !0;
        var s = t.find(function (t) {
          return !1 === t || "string" == typeof t;
        });
        return i(void 0 !== s, s), void 0 === s;
      }, function (t) {
        return a !== e.validateIndex || (console.error(t), i(!0), !1);
      });
    },
    __validateIfNeeded: function __validateIfNeeded(t) {
      !0 === this.hasRules && "ondemand" !== this.lazyRules && (!0 === this.isDirty || !0 !== this.lazyRules && !0 !== t) && this.validate();
    }
  }
}, bufIdx = 0, hexBytes = new Array(256), quasar_esm_i = 0; quasar_esm_i < 256; quasar_esm_i++) {
  hexBytes[quasar_esm_i] = (quasar_esm_i + 256).toString(16).substr(1);
}

var randomBytes = function () {
  var t = "undefined" != typeof crypto ? crypto : "undefined" != typeof window ? window.msCrypto : void 0;

  if (void 0 !== t) {
    if (void 0 !== t.randomBytes) return t.randomBytes;
    if (void 0 !== t.getRandomValues) return function (e) {
      var i = new Uint8Array(e);
      return t.getRandomValues(i), i;
    };
  }

  return function (t) {
    for (var e = [], i = t; i > 0; i--) {
      e.push(Math.floor(256 * Math.random()));
    }

    return e;
  };
}(),
    BUFFER_SIZE = 4096;

function uid$2() {
  (void 0 === buf || bufIdx + 16 > BUFFER_SIZE) && (bufIdx = 0, buf = randomBytes(BUFFER_SIZE));
  var t = Array.prototype.slice.call(buf, bufIdx, bufIdx += 16);
  return t[6] = 15 & t[6] | 64, t[8] = 63 & t[8] | 128, hexBytes[t[0]] + hexBytes[t[1]] + hexBytes[t[2]] + hexBytes[t[3]] + "-" + hexBytes[t[4]] + hexBytes[t[5]] + "-" + hexBytes[t[6]] + hexBytes[t[7]] + "-" + hexBytes[t[8]] + hexBytes[t[9]] + "-" + hexBytes[t[10]] + hexBytes[t[11]] + hexBytes[t[12]] + hexBytes[t[13]] + hexBytes[t[14]] + hexBytes[t[15]];
}

function getTargetUid(t) {
  return void 0 === t ? "f_" + uid$2() : t;
}

var QField = vue_runtime_esm["a" /* default */].extend({
  name: "QField",
  mixins: [DarkMixin, ValidateMixin, AttrsMixin],
  inheritAttrs: !1,
  props: {
    label: String,
    stackLabel: Boolean,
    hint: String,
    hideHint: Boolean,
    prefix: String,
    suffix: String,
    labelColor: String,
    color: String,
    bgColor: String,
    filled: Boolean,
    outlined: Boolean,
    borderless: Boolean,
    standout: [Boolean, String],
    square: Boolean,
    loading: Boolean,
    bottomSlots: Boolean,
    hideBottomSpace: Boolean,
    rounded: Boolean,
    dense: Boolean,
    itemAligned: Boolean,
    counter: Boolean,
    clearable: Boolean,
    clearIcon: String,
    disable: Boolean,
    readonly: Boolean,
    autofocus: Boolean,
    for: String,
    maxlength: [Number, String],
    maxValues: [Number, String]
  },
  data: function data() {
    return {
      focused: !1,
      targetUid: getTargetUid(this.for),
      innerLoading: !1
    };
  },
  watch: {
    for: function _for(t) {
      this.targetUid = getTargetUid(t);
    }
  },
  computed: {
    editable: function editable() {
      return !0 !== this.disable && !0 !== this.readonly;
    },
    hasValue: function hasValue() {
      var t = void 0 === this.__getControl ? this.value : this.innerValue;
      return void 0 !== t && null !== t && ("" + t).length > 0;
    },
    computedCounter: function computedCounter() {
      if (!1 !== this.counter) {
        var t = "string" == typeof this.value || "number" == typeof this.value ? ("" + this.value).length : !0 === Array.isArray(this.value) ? this.value.length : 0,
            e = void 0 !== this.maxlength ? this.maxlength : this.maxValues;
        return t + (void 0 !== e ? " / " + e : "");
      }
    },
    floatingLabel: function floatingLabel() {
      return !0 === this.stackLabel || !0 === this.focused || (void 0 !== this.inputValue && !0 === this.hideSelected ? this.inputValue.length > 0 : !0 === this.hasValue) || void 0 !== this.displayValue && null !== this.displayValue && ("" + this.displayValue).length > 0;
    },
    shouldRenderBottom: function shouldRenderBottom() {
      return !0 === this.bottomSlots || void 0 !== this.hint || !0 === this.hasRules || !0 === this.counter || null !== this.error;
    },
    classes: function classes() {
      var t;
      return (t = {})[this.fieldClass] = void 0 !== this.fieldClass, t["q-field--" + this.styleType] = !0, t["q-field--rounded"] = this.rounded, t["q-field--square"] = this.square, t["q-field--focused"] = !0 === this.focused || !0 === this.hasError, t["q-field--float"] = this.floatingLabel, t["q-field--labeled"] = void 0 !== this.label, t["q-field--dense"] = this.dense, t["q-field--item-aligned q-item-type"] = this.itemAligned, t["q-field--dark"] = this.isDark, t["q-field--auto-height"] = void 0 === this.__getControl, t["q-field--with-bottom"] = !0 !== this.hideBottomSpace && !0 === this.shouldRenderBottom, t["q-field--error"] = this.hasError, t["q-field--readonly"] = !0 === this.readonly && !0 !== this.disable, t["q-field--disabled"] = this.disable, t;
    },
    styleType: function styleType() {
      return !0 === this.filled ? "filled" : !0 === this.outlined ? "outlined" : !0 === this.borderless ? "borderless" : this.standout ? "standout" : "standard";
    },
    contentClass: function contentClass() {
      var t = [];
      if (!0 === this.hasError) t.push("text-negative");else {
        if ("string" == typeof this.standout && this.standout.length > 0 && !0 === this.focused) return this.standout;
        void 0 !== this.color && t.push("text-" + this.color);
      }
      return void 0 !== this.bgColor && t.push("bg-" + this.bgColor), t;
    },
    labelClass: function labelClass() {
      if (void 0 !== this.labelColor && !0 !== this.hasError) return "text-" + this.labelColor;
    },
    controlSlotScope: function controlSlotScope() {
      return {
        id: this.targetUid,
        field: this.$el,
        editable: this.editable,
        focused: this.focused,
        floatingLabel: this.floatingLabel,
        value: this.value,
        emitValue: this.__emitValue
      };
    },
    attrs: function attrs() {
      var t = {
        for: this.targetUid
      };
      return !0 === this.disable ? t["aria-disabled"] = "" : !0 === this.readonly && (t["aria-readonly"] = ""), t;
    }
  },
  methods: {
    focus: function focus() {
      void 0 === this.showPopup || !0 !== this.hasDialog ? this.__focus() : this.showPopup();
    },
    blur: function blur() {
      var t = document.activeElement;
      null !== t && this.$el.contains(t) && t.blur();
    },
    __focus: function __focus() {
      var t = document.activeElement,
          e = this.$refs.target;
      void 0 === e || null !== t && t.id === this.targetUid || (!0 === e.hasAttribute("tabindex") || (e = e.querySelector("[tabindex]")), null !== e && e !== t && e.focus());
    },
    __getContent: function __getContent(t) {
      var e = [];
      return void 0 !== this.$scopedSlots.prepend && e.push(t("div", {
        staticClass: "q-field__prepend q-field__marginal row no-wrap items-center",
        key: "prepend",
        on: this.slotsEvents
      }, this.$scopedSlots.prepend())), e.push(t("div", {
        staticClass: "q-field__control-container col relative-position row no-wrap q-anchor--skip"
      }, this.__getControlContainer(t))), void 0 !== this.$scopedSlots.append && e.push(t("div", {
        staticClass: "q-field__append q-field__marginal row no-wrap items-center",
        key: "append",
        on: this.slotsEvents
      }, this.$scopedSlots.append())), !0 === this.hasError && !1 === this.noErrorIcon && e.push(this.__getInnerAppendNode(t, "error", [t(QIcon, {
        props: {
          name: this.$q.iconSet.field.error,
          color: "negative"
        }
      })])), !0 === this.loading || !0 === this.innerLoading ? e.push(this.__getInnerAppendNode(t, "inner-loading-append", void 0 !== this.$scopedSlots.loading ? this.$scopedSlots.loading() : [t(QSpinner, {
        props: {
          color: this.color
        }
      })])) : !0 === this.clearable && !0 === this.hasValue && !0 === this.editable && e.push(this.__getInnerAppendNode(t, "inner-clearable-append", [t(QIcon, {
        staticClass: "q-field__focusable-action",
        props: {
          tag: "button",
          name: this.clearIcon || this.$q.iconSet.field.clear
        },
        attrs: {
          tabindex: 0,
          type: "button"
        },
        on: this.clearableEvents
      })])), void 0 !== this.__getInnerAppend && e.push(this.__getInnerAppendNode(t, "inner-append", this.__getInnerAppend(t))), void 0 !== this.__getControlChild && e.push(this.__getControlChild(t)), e;
    },
    __getControlContainer: function __getControlContainer(t) {
      var e = [];
      return void 0 !== this.prefix && null !== this.prefix && e.push(t("div", {
        staticClass: "q-field__prefix no-pointer-events row items-center"
      }, [this.prefix])), !0 === this.hasShadow && void 0 !== this.__getShadowControl && e.push(this.__getShadowControl(t)), void 0 !== this.__getControl ? e.push(this.__getControl(t)) : void 0 !== this.$scopedSlots.rawControl ? e.push(this.$scopedSlots.rawControl()) : void 0 !== this.$scopedSlots.control && e.push(t("div", {
        ref: "target",
        staticClass: "q-field__native row",
        attrs: Object.assign({}, this.qAttrs, {
          "data-autofocus": this.autofocus
        })
      }, this.$scopedSlots.control(this.controlSlotScope))), void 0 !== this.label && e.push(t("div", {
        staticClass: "q-field__label no-pointer-events absolute ellipsis",
        class: this.labelClass
      }, [this.label])), void 0 !== this.suffix && null !== this.suffix && e.push(t("div", {
        staticClass: "q-field__suffix no-pointer-events row items-center"
      }, [this.suffix])), e.concat(void 0 !== this.__getDefaultSlot ? this.__getDefaultSlot(t) : slot(this, "default"));
    },
    __getBottom: function __getBottom(t) {
      var e, i;
      !0 === this.hasError ? void 0 !== this.computedErrorMessage ? (e = [t("div", [this.computedErrorMessage])], i = this.computedErrorMessage) : (e = slot(this, "error"), i = "q--slot-error") : !0 === this.hideHint && !0 !== this.focused || (void 0 !== this.hint ? (e = [t("div", [this.hint])], i = this.hint) : (e = slot(this, "hint"), i = "q--slot-hint"));
      var s = !0 === this.counter || void 0 !== this.$scopedSlots.counter;

      if (!0 !== this.hideBottomSpace || !1 !== s || void 0 !== e) {
        var n = t("div", {
          key: i,
          staticClass: "q-field__messages col"
        }, e);
        return t("div", {
          staticClass: "q-field__bottom row items-start q-field__bottom--" + (!0 !== this.hideBottomSpace ? "animated" : "stale")
        }, [!0 === this.hideBottomSpace ? n : t("transition", {
          props: {
            name: "q-transition--field-message"
          }
        }, [n]), !0 === s ? t("div", {
          staticClass: "q-field__counter"
        }, void 0 !== this.$scopedSlots.counter ? this.$scopedSlots.counter() : [this.computedCounter]) : null]);
      }
    },
    __getInnerAppendNode: function __getInnerAppendNode(t, e, i) {
      return null === i ? null : t("div", {
        staticClass: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip",
        key: e
      }, i);
    },
    __onControlPopupShow: function __onControlPopupShow(t) {
      void 0 !== t && stop(t), this.$emit("popup-show", t), this.hasPopupOpen = !0, this.__onControlFocusin(t);
    },
    __onControlPopupHide: function __onControlPopupHide(t) {
      void 0 !== t && stop(t), this.$emit("popup-hide", t), this.hasPopupOpen = !1, this.__onControlFocusout(t);
    },
    __onControlFocusin: function __onControlFocusin(t) {
      !0 === this.editable && !1 === this.focused && (this.focused = !0, this.$emit("focus", t));
    },
    __onControlFocusout: function __onControlFocusout(t, e) {
      var i = this;
      clearTimeout(this.focusoutTimer), this.focusoutTimer = setTimeout(function () {
        (!0 !== document.hasFocus() || !0 !== i.hasPopupOpen && void 0 !== i.$refs && void 0 !== i.$refs.control && !1 === i.$refs.control.contains(document.activeElement)) && (!0 === i.focused && (i.focused = !1, i.$emit("blur", t)), void 0 !== e && e());
      });
    },
    __clearValue: function __clearValue(t) {
      this.focused = !1, stopAndPrevent(t), this.$el.focus(), "file" === this.type && (prevent(t), this.$refs.input.value = null), this.$emit("input", null), this.$emit("clear", this.value);
    },
    __emitValue: function __emitValue(t) {
      this.$emit("input", t);
    }
  },
  render: function render(t) {
    return void 0 !== this.__onPreRender && this.__onPreRender(), void 0 !== this.__onPostRender && this.$nextTick(this.__onPostRender), t("label", {
      staticClass: "q-field row no-wrap items-start",
      class: this.classes,
      attrs: this.attrs
    }, [void 0 !== this.$scopedSlots.before ? t("div", {
      staticClass: "q-field__before q-field__marginal row no-wrap items-center",
      on: this.slotsEvents
    }, this.$scopedSlots.before()) : null, t("div", {
      staticClass: "q-field__inner relative-position col self-stretch column justify-center"
    }, [t("div", {
      ref: "control",
      staticClass: "q-field__control relative-position row no-wrap",
      class: this.contentClass,
      attrs: {
        tabindex: -1
      },
      on: this.controlEvents
    }, this.__getContent(t)), !0 === this.shouldRenderBottom ? this.__getBottom(t) : null]), void 0 !== this.$scopedSlots.after ? t("div", {
      staticClass: "q-field__after q-field__marginal row no-wrap items-center",
      on: this.slotsEvents
    }, this.$scopedSlots.after()) : null]);
  },
  created: function created() {
    void 0 !== this.__onPreRender && this.__onPreRender(), this.slotsEvents = {
      click: prevent
    }, this.clearableEvents = {
      click: this.__clearValue
    }, this.controlEvents = void 0 !== this.__getControlEvents ? this.__getControlEvents() : {
      focusin: this.__onControlFocusin,
      focusout: this.__onControlFocusout,
      "popup-show": this.__onControlPopupShow,
      "popup-hide": this.__onControlPopupHide
    };
  },
  mounted: function mounted() {
    !0 === fromSSR && void 0 === this.for && (this.targetUid = getTargetUid()), !0 === this.autofocus && this.focus();
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.focusoutTimer);
  }
});

function filterFiles(t, e, i, s) {
  var n = [];
  return t.forEach(function (t) {
    !0 === s(t) ? n.push(t) : e.push({
      failedPropValidation: i,
      file: t
    });
  }), n;
}

var FileMixin = {
  props: {
    multiple: Boolean,
    accept: String,
    maxFileSize: [Number, String],
    maxTotalSize: [Number, String],
    maxFiles: [Number, String],
    filter: Function
  },
  computed: {
    extensions: function extensions() {
      if (void 0 !== this.accept) return this.accept.split(",").map(function (t) {
        return (t = t.trim()).endsWith("/*") && (t = t.slice(0, t.length - 1)), t.toUpperCase();
      });
    },
    maxFilesNumber: function maxFilesNumber() {
      return parseInt(this.maxFiles, 10);
    },
    maxTotalSizeNumber: function maxTotalSizeNumber() {
      return parseInt(this.maxTotalSize, 10);
    }
  },
  methods: {
    pickFiles: function pickFiles(t) {
      if (this.editable) {
        var e = this.__getFileInput();

        e && e.click(t);
      }
    },
    addFiles: function addFiles(t) {
      this.editable && t && this.__addFiles(null, t);
    },
    __processFiles: function __processFiles(t, e, i, s) {
      var n = this,
          o = Array.from(e || t.target.files),
          r = [],
          a = function a() {
        r.length > 0 && n.$emit("rejected", r);
      };

      if (void 0 !== this.accept && 0 === (o = filterFiles(o, r, "accept", function (t) {
        return n.extensions.some(function (e) {
          return t.type.toUpperCase().startsWith(e) || t.name.toUpperCase().endsWith(e);
        });
      })).length) return a();

      if (void 0 !== this.maxFileSize) {
        var l = parseInt(this.maxFileSize, 10);
        if (0 === (o = filterFiles(o, r, "max-file-size", function (t) {
          return t.size <= l;
        })).length) return a();
      }

      if (!0 !== this.multiple && (o = [o[0]]), void 0 !== this.maxTotalSize) {
        var c = !0 === s ? i.reduce(function (t, e) {
          return t + e.size;
        }, 0) : 0;
        if (0 === (o = filterFiles(o, r, "max-total-size", function (t) {
          return (c += t.size) <= n.maxTotalSizeNumber;
        })).length) return a();
      }

      if ("function" == typeof this.filter) {
        var u = this.filter(o);
        o = filterFiles(o, r, "filter", function (t) {
          return u.includes(t);
        });
      }

      if (void 0 !== this.maxFiles) {
        var h = !0 === s ? i.length : 0;
        if (0 === (o = filterFiles(o, r, "max-files", function () {
          return ++h <= n.maxFilesNumber;
        })).length) return a();
      }

      return a(), o.length > 0 ? o : void 0;
    },
    __onDragOver: function __onDragOver(t) {
      stopAndPrevent(t), this.dnd = !0;
    },
    __onDragLeave: function __onDragLeave(t) {
      stopAndPrevent(t), this.dnd = !1;
    },
    __onDrop: function __onDrop(t) {
      stopAndPrevent(t);
      var e = t.dataTransfer.files;
      e.length > 0 && this.__addFiles(null, e), this.dnd = !1;
    },
    __getDnd: function __getDnd(t, e) {
      if (!0 === this.dnd) return t("div", {
        staticClass: "q-" + e + "__dnd absolute-full",
        on: cache(this, "dnd", {
          dragenter: stopAndPrevent,
          dragover: stopAndPrevent,
          dragleave: this.__onDragLeave,
          drop: this.__onDrop
        })
      });
    }
  }
},
    FileValueMixin = {
  computed: {
    formDomProps: function formDomProps() {
      if ("file" === this.type) try {
        var t = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
        return Object(this.value) === this.value && ("length" in this.value ? Array.from(this.value) : [this.value]).forEach(function (e) {
          t.items.add(e);
        }), {
          files: t.files
        };
      } catch (t) {
        return {
          files: void 0
        };
      }
    }
  }
},
    NAMED_MASKS = {
  date: "####/##/##",
  datetime: "####/##/## ##:##",
  time: "##:##",
  fulltime: "##:##:##",
  phone: "(###) ### - ####",
  card: "#### #### #### ####"
},
    TOKENS = {
  "#": {
    pattern: "[\\d]",
    negate: "[^\\d]"
  },
  S: {
    pattern: "[a-zA-Z]",
    negate: "[^a-zA-Z]"
  },
  N: {
    pattern: "[0-9a-zA-Z]",
    negate: "[^0-9a-zA-Z]"
  },
  A: {
    pattern: "[a-zA-Z]",
    negate: "[^a-zA-Z]",
    transform: function transform(t) {
      return t.toLocaleUpperCase();
    }
  },
  a: {
    pattern: "[a-zA-Z]",
    negate: "[^a-zA-Z]",
    transform: function transform(t) {
      return t.toLocaleLowerCase();
    }
  },
  X: {
    pattern: "[0-9a-zA-Z]",
    negate: "[^0-9a-zA-Z]",
    transform: function transform(t) {
      return t.toLocaleUpperCase();
    }
  },
  x: {
    pattern: "[0-9a-zA-Z]",
    negate: "[^0-9a-zA-Z]",
    transform: function transform(t) {
      return t.toLocaleLowerCase();
    }
  }
},
    KEYS = Object.keys(TOKENS);
KEYS.forEach(function (t) {
  TOKENS[t].regex = new RegExp(TOKENS[t].pattern);
});
var tokenRegexMask = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + KEYS.join("") + "])|(.)", "g"),
    escRegex = /[.*+?^${}()|[\]\\]/g,
    MARKER = String.fromCharCode(1),
    MaskMixin = {
  props: {
    mask: String,
    reverseFillMask: Boolean,
    fillMask: [Boolean, String],
    unmaskedValue: Boolean
  },
  watch: {
    type: function type() {
      this.__updateMaskInternals();
    },
    mask: function mask(t) {
      if (void 0 !== t) this.__updateMaskValue(this.innerValue, !0);else {
        var e = this.__unmask(this.innerValue);

        this.__updateMaskInternals(), this.value !== e && this.$emit("input", e);
      }
    },
    fillMask: function fillMask() {
      !0 === this.hasMask && this.__updateMaskValue(this.innerValue, !0);
    },
    reverseFillMask: function reverseFillMask() {
      !0 === this.hasMask && this.__updateMaskValue(this.innerValue, !0);
    },
    unmaskedValue: function unmaskedValue() {
      !0 === this.hasMask && this.__updateMaskValue(this.innerValue);
    }
  },
  methods: {
    __getInitialMaskedValue: function __getInitialMaskedValue() {
      if (this.__updateMaskInternals(), !0 === this.hasMask) {
        var t = this.__mask(this.__unmask(this.value));

        return !1 !== this.fillMask ? this.__fillWithMask(t) : t;
      }

      return this.value;
    },
    __getPaddedMaskMarked: function __getPaddedMaskMarked(t) {
      if (t < this.maskMarked.length) return this.maskMarked.slice(-t);
      var e = this.maskMarked,
          i = e.indexOf(MARKER),
          s = "";

      if (i > -1) {
        for (var n = t - e.length; n > 0; n--) {
          s += MARKER;
        }

        e = e.slice(0, i) + s + e.slice(i);
      }

      return e;
    },
    __updateMaskInternals: function __updateMaskInternals() {
      var t = this;
      if (this.hasMask = void 0 !== this.mask && this.mask.length > 0 && ["text", "search", "url", "tel", "password"].includes(this.type), !1 === this.hasMask) return this.computedUnmask = void 0, this.maskMarked = "", void (this.maskReplaced = "");
      var e = void 0 === NAMED_MASKS[this.mask] ? this.mask : NAMED_MASKS[this.mask],
          i = "string" == typeof this.fillMask && this.fillMask.length > 0 ? this.fillMask.slice(0, 1) : "_",
          s = i.replace(escRegex, "\\$&"),
          n = [],
          o = [],
          r = [],
          a = !0 === this.reverseFillMask,
          l = "",
          c = "";
      e.replace(tokenRegexMask, function (t, e, i, s, u) {
        if (void 0 !== s) {
          var h = TOKENS[s];
          r.push(h), c = h.negate, !0 === a && (o.push("(?:" + c + "+)?(" + h.pattern + "+)?(?:" + c + "+)?(" + h.pattern + "+)?"), a = !1), o.push("(?:" + c + "+)?(" + h.pattern + ")?");
        } else if (void 0 !== i) l = "\\" + ("\\" === i ? "" : i), r.push(i), n.push("([^" + l + "]+)?" + l + "?");else {
          var d = void 0 !== e ? e : u;
          l = "\\" === d ? "\\\\\\\\" : d.replace(escRegex, "\\\\$&"), r.push(d), n.push("([^" + l + "]+)?" + l + "?");
        }
      });
      var u = new RegExp("^" + n.join("") + "(" + ("" === l ? "." : "[^" + l + "]") + "+)?$"),
          h = o.length - 1,
          d = o.map(function (e, i) {
        return 0 === i && !0 === t.reverseFillMask ? new RegExp("^" + s + "*" + e) : i === h ? new RegExp("^" + e + "(" + ("" === c ? "." : c) + "+)?" + (!0 === t.reverseFillMask ? "$" : s + "*")) : new RegExp("^" + e);
      });
      this.computedMask = r, this.computedUnmask = function (t) {
        var e = u.exec(t);
        null !== e && (t = e.slice(1).join(""));

        for (var i = [], s = d.length, n = 0, o = t; n < s; n++) {
          var r = d[n].exec(o);
          if (null === r) break;
          o = o.slice(r.shift().length), i.push.apply(i, r);
        }

        return i.length > 0 ? i.join("") : t;
      }, this.maskMarked = r.map(function (t) {
        return "string" == typeof t ? t : MARKER;
      }).join(""), this.maskReplaced = this.maskMarked.split(MARKER).join(i);
    },
    __updateMaskValue: function __updateMaskValue(t, e, i) {
      var s = this,
          n = this.$refs.input,
          o = n.selectionEnd,
          r = n.value.length - o,
          a = this.__unmask(t);

      !0 === e && this.__updateMaskInternals();

      var l = this.__mask(a),
          c = !1 !== this.fillMask ? this.__fillWithMask(l) : l,
          u = this.innerValue !== c;

      n.value !== c && (n.value = c), !0 === u && (this.innerValue = c), this.$nextTick(function () {
        if (c !== s.maskReplaced) {
          if ("insertFromPaste" !== i || !0 === s.reverseFillMask) {
            if (["deleteContentBackward", "deleteContentForward"].indexOf(i) > -1) {
              var t = !0 === s.reverseFillMask ? Math.max(0, c.length - (c === s.maskReplaced ? 0 : Math.min(l.length, r) + 1)) + 1 : o;
              n.setSelectionRange(t, t, "forward");
            } else if (!0 === s.reverseFillMask) {
              if (!0 === u) {
                var e = Math.max(0, c.length - (c === s.maskReplaced ? 0 : Math.min(l.length, r + 1)));

                s.__moveCursorRightReverse(n, e, e);
              } else {
                var a = c.length - r;
                n.setSelectionRange(a, a, "backward");
              }
            } else if (!0 === u) {
              var h = Math.max(0, s.maskMarked.indexOf(MARKER), Math.min(l.length, o) - 1);

              s.__moveCursorRight(n, h, h);
            } else {
              var d = o - 1;

              s.__moveCursorRight(n, d, d);
            }
          } else {
            var p = o - 1;

            s.__moveCursorRight(n, p, p);
          }
        } else {
          var f = !0 === s.reverseFillMask ? s.maskReplaced.length : 0;
          n.setSelectionRange(f, f, "forward");
        }
      });
      var h = !0 === this.unmaskedValue ? this.__unmask(c) : c;
      this.value !== h && this.__emitValue(h, !0);
    },
    __moveCursorForPaste: function __moveCursorForPaste(t, e, i) {
      var s = this.__mask(this.__unmask(t.value));

      e = Math.max(0, this.maskMarked.indexOf(MARKER), Math.min(s.length, e)), t.setSelectionRange(e, i, "forward");
    },
    __moveCursorLeft: function __moveCursorLeft(t, e, i, s) {
      for (var n = -1 === this.maskMarked.slice(e - 1).indexOf(MARKER), o = Math.max(0, e - 1); o >= 0; o--) {
        if (this.maskMarked[o] === MARKER) {
          e = o, !0 === n && e++;
          break;
        }
      }

      if (o < 0 && void 0 !== this.maskMarked[e] && this.maskMarked[e] !== MARKER) return this.__moveCursorRight(t, 0, 0);
      e >= 0 && t.setSelectionRange(e, !0 === s ? i : e, "backward");
    },
    __moveCursorRight: function __moveCursorRight(t, e, i, s) {
      for (var n = t.value.length, o = Math.min(n, i + 1); o <= n; o++) {
        if (this.maskMarked[o] === MARKER) {
          i = o;
          break;
        }

        this.maskMarked[o - 1] === MARKER && (i = o);
      }

      if (o > n && void 0 !== this.maskMarked[i - 1] && this.maskMarked[i - 1] !== MARKER) return this.__moveCursorLeft(t, n, n);
      t.setSelectionRange(s ? e : i, i, "forward");
    },
    __moveCursorLeftReverse: function __moveCursorLeftReverse(t, e, i, s) {
      for (var n = this.__getPaddedMaskMarked(t.value.length), o = Math.max(0, e - 1); o >= 0; o--) {
        if (n[o - 1] === MARKER) {
          e = o;
          break;
        }

        if (n[o] === MARKER && (e = o, 0 === o)) break;
      }

      if (o < 0 && void 0 !== n[e] && n[e] !== MARKER) return this.__moveCursorRightReverse(t, 0, 0);
      e >= 0 && t.setSelectionRange(e, !0 === s ? i : e, "backward");
    },
    __moveCursorRightReverse: function __moveCursorRightReverse(t, e, i, s) {
      for (var n = t.value.length, o = this.__getPaddedMaskMarked(n), r = -1 === o.slice(0, i + 1).indexOf(MARKER), a = Math.min(n, i + 1); a <= n; a++) {
        if (o[a - 1] === MARKER) {
          (i = a) > 0 && !0 === r && i--;
          break;
        }
      }

      if (a > n && void 0 !== o[i - 1] && o[i - 1] !== MARKER) return this.__moveCursorLeftReverse(t, n, n);
      t.setSelectionRange(!0 === s ? e : i, i, "forward");
    },
    __onMaskedKeydown: function __onMaskedKeydown(t) {
      if (!0 !== shouldIgnoreKey(t)) {
        var e = this.$refs.input,
            i = e.selectionStart,
            s = e.selectionEnd;

        if (37 === t.keyCode || 39 === t.keyCode) {
          var n = this["__moveCursor" + (39 === t.keyCode ? "Right" : "Left") + (!0 === this.reverseFillMask ? "Reverse" : "")];
          t.preventDefault(), n(e, i, s, t.shiftKey);
        } else 8 === t.keyCode && !0 !== this.reverseFillMask && i === s ? this.__moveCursorLeft(e, i, s, !0) : 46 === t.keyCode && !0 === this.reverseFillMask && i === s && this.__moveCursorRightReverse(e, i, s, !0);

        this.$emit("keydown", t);
      }
    },
    __mask: function __mask(t) {
      if (void 0 === t || null === t || "" === t) return "";
      if (!0 === this.reverseFillMask) return this.__maskReverse(t);

      for (var e = this.computedMask, i = 0, s = "", n = 0; n < e.length; n++) {
        var o = t[i],
            r = e[n];
        if ("string" == typeof r) s += r, o === r && i++;else {
          if (void 0 === o || !r.regex.test(o)) return s;
          s += void 0 !== r.transform ? r.transform(o) : o, i++;
        }
      }

      return s;
    },
    __maskReverse: function __maskReverse(t) {
      for (var e = this.computedMask, i = this.maskMarked.indexOf(MARKER), s = t.length - 1, n = "", o = e.length - 1; o >= 0; o--) {
        var r = e[o],
            a = t[s];
        if ("string" == typeof r) n = r + n, a === r && s--;else {
          if (void 0 === a || !r.regex.test(a)) return n;

          do {
            n = (void 0 !== r.transform ? r.transform(a) : a) + n, a = t[--s];
          } while (i === o && void 0 !== a && r.regex.test(a));
        }
      }

      return n;
    },
    __unmask: function __unmask(t) {
      return "string" != typeof t || void 0 === this.computedUnmask ? "number" == typeof t ? this.computedUnmask("" + t) : t : this.computedUnmask(t);
    },
    __fillWithMask: function __fillWithMask(t) {
      return this.maskReplaced.length - t.length <= 0 ? t : !0 === this.reverseFillMask && t.length > 0 ? this.maskReplaced.slice(0, -t.length) + t : t + this.maskReplaced.slice(t.length);
    }
  }
},
    isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/,
    isChinese = /(?:[\u3300-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFE30-\uFE4F]|[\uD840-\uD868\uD86A-\uD872][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD873[\uDC00-\uDEAF]|\uD87E[\uDC00-\uDE1F])/,
    isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/,
    CompositionMixin = {
  methods: {
    __onComposition: function __onComposition(t) {
      if ("compositionend" === t.type || "change" === t.type) {
        if (!0 !== t.target.composing) return;
        t.target.composing = !1, this.__onInput(t);
      } else "compositionupdate" === t.type ? "string" == typeof t.data && !1 === isJapanese.test(t.data) && !1 === isChinese.test(t.data) && !1 === isKorean.test(t.data) && (t.target.composing = !1) : t.target.composing = !0;
    }
  }
},
    QInput = vue_runtime_esm["a" /* default */].extend({
  name: "QInput",
  mixins: [QField, MaskMixin, CompositionMixin, FormFieldMixin, FileValueMixin, ListenersMixin],
  props: {
    value: {
      required: !1
    },
    shadowText: String,
    type: {
      type: String,
      default: "text"
    },
    debounce: [String, Number],
    autogrow: Boolean,
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  watch: {
    value: function value(t) {
      if (!0 === this.hasMask) {
        if (!0 === this.stopValueWatcher) return void (this.stopValueWatcher = !1);

        this.__updateMaskValue(t);
      } else this.innerValue !== t && (this.innerValue = t, "number" === this.type && !0 === this.hasOwnProperty("tempValue") && (!0 === this.typedNumber ? this.typedNumber = !1 : delete this.tempValue));

      !0 === this.autogrow && this.$nextTick(this.__adjustHeight);
    },
    autogrow: function autogrow(t) {
      if (!0 === t) this.$nextTick(this.__adjustHeight);else if (this.qAttrs.rows > 0 && void 0 !== this.$refs.input) {
        this.$refs.input.style.height = "auto";
      }
    },
    dense: function dense() {
      !0 === this.autogrow && this.$nextTick(this.__adjustHeight);
    }
  },
  data: function data() {
    return {
      innerValue: this.__getInitialMaskedValue()
    };
  },
  computed: {
    isTextarea: function isTextarea() {
      return "textarea" === this.type || !0 === this.autogrow;
    },
    fieldClass: function fieldClass() {
      return "q-" + (!0 === this.isTextarea ? "textarea" : "input") + (!0 === this.autogrow ? " q-textarea--autogrow" : "");
    },
    hasShadow: function hasShadow() {
      return "file" !== this.type && "string" == typeof this.shadowText && this.shadowText.length > 0;
    },
    onEvents: function onEvents() {
      var t = Object.assign({}, this.qListeners, {
        input: this.__onInput,
        paste: this.__onPaste,
        change: this.__onChange,
        blur: this.__onFinishEditing,
        focus: stop
      });
      return t.compositionstart = t.compositionupdate = t.compositionend = this.__onComposition, !0 === this.hasMask && (t.keydown = this.__onMaskedKeydown), !0 === this.autogrow && (t.animationend = this.__adjustHeight), t;
    },
    inputAttrs: function inputAttrs() {
      var t = Object.assign({}, {
        tabindex: 0,
        "data-autofocus": this.autofocus,
        rows: "textarea" === this.type ? 6 : void 0,
        "aria-label": this.label,
        name: this.nameProp
      }, this.qAttrs, {
        id: this.targetUid,
        type: this.type,
        maxlength: this.maxlength,
        disabled: !0 === this.disable,
        readonly: !0 === this.readonly
      });
      return !0 === this.autogrow && (t.rows = 1), t;
    }
  },
  methods: {
    focus: function focus() {
      var t = document.activeElement;
      void 0 === this.$refs.input || this.$refs.input === t || null !== t && t.id === this.targetUid || this.$refs.input.focus();
    },
    select: function select() {
      void 0 !== this.$refs.input && this.$refs.input.select();
    },
    __onPaste: function __onPaste(t) {
      if (!0 === this.hasMask && !0 !== this.reverseFillMask) {
        var e = t.target;

        this.__moveCursorForPaste(e, e.selectionStart, e.selectionEnd);
      }
    },
    __onInput: function __onInput(t) {
      if (!t || !t.target || !0 !== t.target.composing) if ("file" !== this.type) {
        var e = t.target.value;
        !0 === this.hasMask ? this.__updateMaskValue(e, !1, t.inputType) : this.__emitValue(e), !0 === this.autogrow && this.__adjustHeight();
      } else this.$emit("input", t.target.files);
    },
    __emitValue: function __emitValue(t, e) {
      var i = this;
      this.emitValueFn = function () {
        "number" !== i.type && !0 === i.hasOwnProperty("tempValue") && delete i.tempValue, i.value !== t && (!0 === e && (i.stopValueWatcher = !0), i.$emit("input", t)), i.emitValueFn = void 0;
      }, "number" === this.type && (this.typedNumber = !0, this.tempValue = t), void 0 !== this.debounce ? (clearTimeout(this.emitTimer), this.tempValue = t, this.emitTimer = setTimeout(this.emitValueFn, this.debounce)) : this.emitValueFn();
    },
    __adjustHeight: function __adjustHeight() {
      var t = this.$refs.input;

      if (void 0 !== t) {
        var e = t.parentNode.style;
        e.marginBottom = t.scrollHeight - 1 + "px", t.style.height = "1px", t.style.height = t.scrollHeight + "px", e.marginBottom = "";
      }
    },
    __onChange: function __onChange(t) {
      this.__onComposition(t), clearTimeout(this.emitTimer), void 0 !== this.emitValueFn && this.emitValueFn(), this.$emit("change", t);
    },
    __onFinishEditing: function __onFinishEditing(t) {
      var e = this;
      void 0 !== t && stop(t), clearTimeout(this.emitTimer), void 0 !== this.emitValueFn && this.emitValueFn(), this.typedNumber = !1, this.stopValueWatcher = !1, delete this.tempValue, "file" !== this.type && this.$nextTick(function () {
        void 0 !== e.$refs.input && (e.$refs.input.value = void 0 !== e.innerValue ? e.innerValue : "");
      });
    },
    __getCurValue: function __getCurValue() {
      return !0 === this.hasOwnProperty("tempValue") ? this.tempValue : void 0 !== this.innerValue ? this.innerValue : "";
    },
    __getShadowControl: function __getShadowControl(t) {
      return t("div", {
        staticClass: "q-field__native q-field__shadow absolute-full no-pointer-events"
      }, [t("span", {
        staticClass: "invisible"
      }, this.__getCurValue()), t("span", this.shadowText)]);
    },
    __getControl: function __getControl(t) {
      return t(!0 === this.isTextarea ? "textarea" : "input", {
        ref: "input",
        staticClass: "q-field__native q-placeholder",
        style: this.inputStyle,
        class: this.inputClass,
        attrs: this.inputAttrs,
        on: this.onEvents,
        domProps: "file" !== this.type ? {
          value: this.__getCurValue()
        } : this.formDomProps
      });
    }
  },
  mounted: function mounted() {
    !0 === this.autogrow && this.__adjustHeight();
  },
  beforeDestroy: function beforeDestroy() {
    this.__onFinishEditing();
  }
}),
    QTooltip = vue_runtime_esm["a" /* default */].extend({
  name: "QTooltip",
  mixins: [AnchorMixin, ModelToggleMixin, PortalMixin, TransitionMixin],
  props: {
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    },
    transitionShow: {
      default: "jump-down"
    },
    transitionHide: {
      default: "jump-up"
    },
    anchor: {
      type: String,
      default: "bottom middle",
      validator: validatePosition
    },
    self: {
      type: String,
      default: "top middle",
      validator: validatePosition
    },
    offset: {
      type: Array,
      default: function _default() {
        return [14, 14];
      },
      validator: validateOffset
    },
    scrollTarget: {
      default: void 0
    },
    delay: {
      type: Number,
      default: 0
    },
    hideDelay: {
      type: Number,
      default: 0
    }
  },
  computed: {
    anchorOrigin: function anchorOrigin() {
      return parsePosition(this.anchor);
    },
    selfOrigin: function selfOrigin() {
      return parsePosition(this.self);
    },
    hideOnRouteChange: function hideOnRouteChange() {
      return !0 !== this.persistent;
    }
  },
  methods: {
    __show: function __show(t) {
      var e = this;
      this.__showPortal(), this.__nextTick(function () {
        e.observer = new MutationObserver(function () {
          return e.updatePosition();
        }), e.observer.observe(e.__portal.$el, {
          attributes: !1,
          childList: !0,
          characterData: !0,
          subtree: !0
        }), e.updatePosition(), e.__configureScrollTarget();
      }), this.__setTimeout(function () {
        e.$emit("show", t);
      }, 300);
    },
    __hide: function __hide(t) {
      var e = this;
      this.__anchorCleanup(), this.__setTimeout(function () {
        e.__hidePortal(), e.$emit("hide", t);
      }, 300);
    },
    __anchorCleanup: function __anchorCleanup() {
      void 0 !== this.observer && (this.observer.disconnect(), this.observer = void 0), this.__unconfigureScrollTarget(), cleanEvt(this, "tooltipTemp");
    },
    updatePosition: function updatePosition() {
      if (void 0 !== this.anchorEl && void 0 !== this.__portal) {
        var t = this.__portal.$el;
        8 !== t.nodeType ? setPosition({
          el: t,
          offset: this.offset,
          anchorEl: this.anchorEl,
          anchorOrigin: this.anchorOrigin,
          selfOrigin: this.selfOrigin,
          maxHeight: this.maxHeight,
          maxWidth: this.maxWidth
        }) : setTimeout(this.updatePosition, 25);
      }
    },
    __delayShow: function __delayShow(t) {
      var e = this;

      if (!0 === this.$q.platform.is.mobile) {
        clearSelection(), document.body.classList.add("non-selectable");
        var i = getTouchTarget(this.anchorEl);
        addEvt(this, "tooltipTemp", ["touchmove", "touchcancel", "touchend", "click"].map(function (t) {
          return [i, t, "__delayHide", "passiveCapture"];
        }));
      }

      this.__setTimeout(function () {
        e.show(t);
      }, this.delay);
    },
    __delayHide: function __delayHide(t) {
      var e = this;
      this.__clearTimeout(), !0 === this.$q.platform.is.mobile && (cleanEvt(this, "tooltipTemp"), clearSelection(), setTimeout(function () {
        document.body.classList.remove("non-selectable");
      }, 10)), this.__setTimeout(function () {
        e.hide(t);
      }, this.hideDelay);
    },
    __configureAnchorEl: function __configureAnchorEl() {
      !0 !== this.noParentEvent && void 0 !== this.anchorEl && addEvt(this, "anchor", !0 === this.$q.platform.is.mobile ? [[this.anchorEl, "touchstart", "__delayShow", "passive"]] : [[this.anchorEl, "mouseenter", "__delayShow", "passive"], [this.anchorEl, "mouseleave", "__delayHide", "passive"]]);
    },
    __unconfigureScrollTarget: function __unconfigureScrollTarget() {
      void 0 !== this.__scrollTarget && (this.__changeScrollEvent(this.__scrollTarget), this.__scrollTarget = void 0);
    },
    __configureScrollTarget: function __configureScrollTarget() {
      if (void 0 !== this.anchorEl || void 0 !== this.scrollTarget) {
        this.__scrollTarget = getScrollTarget(this.anchorEl, this.scrollTarget);
        var t = !0 === this.noParentEvent ? this.updatePosition : this.hide;

        this.__changeScrollEvent(this.__scrollTarget, t);
      }
    },
    __renderPortal: function __renderPortal(t) {
      return t("transition", {
        props: {
          name: this.transition
        }
      }, [!0 === this.showing ? t("div", {
        staticClass: "q-tooltip q-tooltip--style q-position-engine no-pointer-events",
        class: this.contentClass,
        style: this.contentStyle,
        attrs: {
          role: "complementary"
        }
      }, slot(this, "default")) : null]);
    }
  },
  mounted: function mounted() {
    this.__processModelChange(this.value);
  }
}),
    QList = vue_runtime_esm["a" /* default */].extend({
  name: "QList",
  mixins: [ListenersMixin, DarkMixin],
  props: {
    bordered: Boolean,
    dense: Boolean,
    separator: Boolean,
    padding: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-list" + (!0 === this.bordered ? " q-list--bordered" : "") + (!0 === this.dense ? " q-list--dense" : "") + (!0 === this.separator ? " q-list--separator" : "") + (!0 === this.isDark ? " q-list--dark" : "") + (!0 === this.padding ? " q-list--padding" : "");
    }
  },
  render: function render(t) {
    return t("div", {
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QItem = vue_runtime_esm["a" /* default */].extend({
  name: "QItem",
  mixins: [DarkMixin, RouterLinkMixin, TagMixin, ListenersMixin],
  props: {
    active: Boolean,
    clickable: Boolean,
    dense: Boolean,
    insetLevel: Number,
    tabindex: [String, Number],
    focused: Boolean,
    manualFocus: Boolean
  },
  computed: {
    isActionable: function isActionable() {
      return !0 === this.clickable || !0 === this.hasRouterLink || "a" === this.tag || "label" === this.tag;
    },
    isClickable: function isClickable() {
      return !0 !== this.disable && !0 === this.isActionable;
    },
    classes: function classes() {
      var t;
      return (t = {
        "q-item--clickable q-link cursor-pointer": this.isClickable,
        "q-focusable q-hoverable": !0 === this.isClickable && !1 === this.manualFocus,
        "q-manual-focusable": !0 === this.isClickable && !0 === this.manualFocus,
        "q-manual-focusable--focused": !0 === this.isClickable && !0 === this.focused,
        "q-item--dense": this.dense,
        "q-item--dark": this.isDark,
        "q-item--active": this.active
      })[this.activeClass] = !0 === this.active && !0 !== this.hasRouterLink && void 0 !== this.activeClass, t.disabled = this.disable, t;
    },
    style: function style() {
      var t;
      if (void 0 !== this.insetLevel) return (t = {})["padding" + (!0 === this.$q.lang.rtl ? "Right" : "Left")] = 16 + 56 * this.insetLevel + "px", t;
    },
    onEvents: function onEvents() {
      return Object.assign({}, this.qListeners, {
        click: this.__onClick,
        keyup: this.__onKeyup
      });
    }
  },
  methods: {
    __getContent: function __getContent(t) {
      var e = uniqueSlot(this, "default", []);
      return !0 === this.isClickable && e.unshift(t("div", {
        staticClass: "q-focus-helper",
        attrs: {
          tabindex: -1
        },
        ref: "blurTarget"
      })), e;
    },
    __onClick: function __onClick(t) {
      !0 === this.isClickable && (void 0 !== this.$refs.blurTarget && (!0 !== t.qKeyEvent && document.activeElement === this.$el ? this.$refs.blurTarget.focus() : document.activeElement === this.$refs.blurTarget && this.$el.focus()), this.$emit("click", t));
    },
    __onKeyup: function __onKeyup(t) {
      if (!0 === this.isClickable && !0 === isKeyCode(t, 13)) {
        stopAndPrevent(t), t.qKeyEvent = !0;
        var e = new MouseEvent("click", t);
        e.qKeyEvent = !0, this.$el.dispatchEvent(e);
      }

      this.$emit("keyup", t);
    }
  },
  render: function render(t) {
    var e = {
      staticClass: "q-item q-item-type row no-wrap",
      class: this.classes,
      style: this.style
    };
    return e[!0 === this.hasRouterLink ? "nativeOn" : "on"] = this.onEvents, !0 === this.isClickable ? e.attrs = {
      tabindex: this.tabindex || "0"
    } : !0 === this.isActionable && (e.attrs = {
      "aria-disabled": ""
    }), !0 === this.hasRouterLink ? (e.tag = "a", e.props = this.routerLinkProps, t("router-link", e, this.__getContent(t))) : t(this.tag, e, this.__getContent(t));
  }
}),
    QItemSection = vue_runtime_esm["a" /* default */].extend({
  name: "QItemSection",
  mixins: [ListenersMixin],
  props: {
    avatar: Boolean,
    thumbnail: Boolean,
    side: Boolean,
    top: Boolean,
    noWrap: Boolean
  },
  computed: {
    classes: function classes() {
      var t,
          e = this.avatar || this.side || this.thumbnail;
      return (t = {
        "q-item__section--top": this.top,
        "q-item__section--avatar": this.avatar,
        "q-item__section--thumbnail": this.thumbnail,
        "q-item__section--side": e,
        "q-item__section--nowrap": this.noWrap,
        "q-item__section--main": !e
      })["justify-" + (this.top ? "start" : "center")] = !0, t;
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-item__section column",
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
});

function run(t, e, i) {
  e.handler ? e.handler(t, i, i.caret) : i.runCmd(e.cmd, e.param);
}

function __getGroup(t, e) {
  return t("div", {
    staticClass: "q-editor__toolbar-group"
  }, e);
}

function getBtn(t, e, i, s, n) {
  void 0 === n && (n = !1);
  var o = n || "toggle" === i.type && (i.toggled ? i.toggled(e) : i.cmd && e.caret.is(i.cmd, i.param)),
      r = [],
      a = {
    click: function click(t) {
      s && s(), run(t, i, e);
    }
  };

  if (i.tip && e.$q.platform.is.desktop) {
    var l = i.key ? t("div", [t("small", "(CTRL + " + String.fromCharCode(i.key) + ")")]) : null;
    r.push(t(QTooltip, {
      props: {
        delay: 1e3
      }
    }, [t("div", {
      domProps: {
        innerHTML: i.tip
      }
    }), l]));
  }

  return t(QBtn, {
    props: Object.assign({}, e.buttonProps, {
      icon: i.icon,
      color: o ? i.toggleColor || e.toolbarToggleColor : i.color || e.toolbarColor,
      textColor: o && !e.toolbarPush ? null : i.textColor || e.toolbarTextColor,
      label: i.label,
      disable: !!i.disable && ("function" != typeof i.disable || i.disable(e)),
      size: "sm"
    }),
    on: a
  }, r);
}

function getDropdown(t, e, i) {
  var s,
      n,
      o = i.label,
      r = i.icon;

  function a() {
    h.componentInstance.hide();
  }

  if ("only-icons" === i.list) n = i.options.map(function (i) {
    var s = void 0 === i.type && e.caret.is(i.cmd, i.param);
    return s && (o = i.tip, r = i.icon), getBtn(t, e, i, a, s);
  }), s = e.toolbarBackgroundClass, n = [__getGroup(t, n)];else {
    var l = void 0 !== e.toolbarToggleColor ? "text-" + e.toolbarToggleColor : null,
        c = void 0 !== e.toolbarTextColor ? "text-" + e.toolbarTextColor : null;
    n = i.options.map(function (i) {
      var s = !!i.disable && i.disable(e),
          n = void 0 === i.type && e.caret.is(i.cmd, i.param);
      n && (o = i.tip, r = i.icon);
      var u = i.htmlTip;
      return t(QItem, {
        props: {
          active: n,
          activeClass: l,
          clickable: !0,
          disable: s,
          dense: !0
        },
        on: {
          click: function click(t) {
            a(), e.$refs.content && e.$refs.content.focus(), e.caret.restore(), run(t, i, e);
          }
        }
      }, ["no-icons" === i.list ? null : t(QItemSection, {
        class: n ? l : c,
        props: {
          side: !0
        }
      }, [t(QIcon, {
        props: {
          name: i.icon
        }
      })]), t(QItemSection, [u ? t("div", {
        domProps: {
          innerHTML: i.htmlTip
        }
      }) : i.tip ? t("div", [i.tip]) : null])]);
    }), s = [e.toolbarBackgroundClass, c], n = [t(QList, [n])];
  }
  var u = i.highlight && o !== i.label,
      h = t(QBtnDropdown, {
    props: Object.assign({}, e.buttonProps, {
      noCaps: !0,
      noWrap: !0,
      color: u ? e.toolbarToggleColor : e.toolbarColor,
      textColor: u && !e.toolbarPush ? null : e.toolbarTextColor,
      label: i.fixedLabel ? i.label : o,
      icon: i.fixedIcon ? i.icon : r,
      contentClass: s
    })
  }, n);
  return h;
}

function getToolbar(t, e) {
  if (e.caret) return e.buttons.filter(function (t) {
    return !e.isViewingSource || t.find(function (t) {
      return "viewsource" === t.cmd;
    });
  }).map(function (i) {
    return __getGroup(t, i.map(function (i) {
      return (!e.isViewingSource || "viewsource" === i.cmd) && ("slot" === i.type ? slot(e, i.slot) : "dropdown" === i.type ? getDropdown(t, e, i) : getBtn(t, e, i));
    }));
  });
}

function getFonts(t, e, i, s) {
  void 0 === s && (s = {});
  var n = Object.keys(s);
  if (0 === n.length) return {};
  var o = {
    default_font: {
      cmd: "fontName",
      param: t,
      icon: i,
      tip: e
    }
  };
  return n.forEach(function (t) {
    var e = s[t];
    o[t] = {
      cmd: "fontName",
      param: e,
      icon: i,
      tip: e,
      htmlTip: '<font face="' + e + '">' + e + "</font>"
    };
  }), o;
}

function getLinkEditor(t, e, i) {
  if (e.caret) {
    var s = e.toolbarColor || e.toolbarTextColor,
        n = e.editLinkUrl,
        o = function o() {
      e.caret.restore(), n !== e.editLinkUrl && document.execCommand("createLink", !1, "" === n ? " " : n), e.editLinkUrl = null, !0 === i && e.$nextTick(e.__onInput);
    };

    return [t("div", {
      staticClass: "q-mx-xs",
      class: "text-" + s
    }, [e.$q.lang.editor.url + ": "]), t(QInput, {
      key: "qedt_btm_input",
      staticClass: "q-ma-none q-pa-none col q-editor-input",
      props: {
        value: n,
        color: s,
        autofocus: !0,
        borderless: !0,
        dense: !0
      },
      on: {
        input: function input(t) {
          n = t;
        },
        keydown: function keydown(t) {
          if (!0 !== shouldIgnoreKey(t)) switch (t.keyCode) {
            case 13:
              return prevent(t), o();

            case 27:
              prevent(t), e.caret.restore(), e.editLinkUrl && "https://" !== e.editLinkUrl || document.execCommand("unlink"), e.editLinkUrl = null;
          }
        }
      }
    }), __getGroup(t, [t(QBtn, {
      key: "qedt_btm_rem",
      attrs: {
        tabindex: -1
      },
      props: Object.assign({}, e.buttonProps, {
        label: e.$q.lang.label.remove,
        noCaps: !0
      }),
      on: {
        click: function click() {
          e.caret.restore(), document.execCommand("unlink"), e.editLinkUrl = null, !0 === i && e.$nextTick(e.__onInput);
        }
      }
    }), t(QBtn, {
      key: "qedt_btm_upd",
      props: Object.assign({}, e.buttonProps, {
        label: e.$q.lang.label.update,
        noCaps: !0
      }),
      on: {
        click: o
      }
    })])];
  }
}

function getBlockElement(t, e) {
  if (e && t === e) return null;
  var i = t.nodeName.toLowerCase();
  if (!0 === ["div", "li", "ul", "ol", "blockquote"].includes(i)) return t;
  var s = (window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle).display;
  return "block" === s || "table" === s ? t : getBlockElement(t.parentNode);
}

function isChildOf(t, e) {
  return !(!t || t === document.body) && (e === document ? document.body : e).contains(t.parentNode);
}

var urlRegex = /^https?:\/\//,
    Caret = function Caret(t, e) {
  this.el = t, this.vm = e, this._range = null;
},
    prototypeAccessors = {
  selection: {
    configurable: !0
  },
  hasSelection: {
    configurable: !0
  },
  range: {
    configurable: !0
  },
  parent: {
    configurable: !0
  },
  blockParent: {
    configurable: !0
  }
};

prototypeAccessors.selection.get = function () {
  if (this.el) {
    var t = document.getSelection();
    if (isChildOf(t.anchorNode, this.el) && isChildOf(t.focusNode, this.el)) return t;
  }

  return null;
}, prototypeAccessors.hasSelection.get = function () {
  return null !== this.selection && this.selection.toString().length > 0;
}, prototypeAccessors.range.get = function () {
  var t = this.selection;
  return null !== t && t.rangeCount ? t.getRangeAt(0) : this._range;
}, prototypeAccessors.parent.get = function () {
  var t = this.range;

  if (null !== t) {
    var e = t.startContainer;
    return e.nodeType === document.ELEMENT_NODE ? e : e.parentNode;
  }

  return null;
}, prototypeAccessors.blockParent.get = function () {
  var t = this.parent;
  return null !== t ? getBlockElement(t, this.el) : null;
}, Caret.prototype.save = function (t) {
  void 0 === t && (t = this.range), null !== t && (this._range = t);
}, Caret.prototype.restore = function (t) {
  void 0 === t && (t = this._range);
  var e = document.createRange(),
      i = document.getSelection();
  null !== t ? (e.setStart(t.startContainer, t.startOffset), e.setEnd(t.endContainer, t.endOffset), i.removeAllRanges(), i.addRange(e)) : (i.selectAllChildren(this.el), i.collapseToEnd());
}, Caret.prototype.hasParent = function (t, e) {
  var i = e ? this.parent : this.blockParent;
  return null !== i && i.nodeName.toLowerCase() === t.toLowerCase();
}, Caret.prototype.hasParents = function (t, e, i) {
  return void 0 === i && (i = this.parent), null !== i && (null !== i && !0 === t.includes(i.nodeName.toLowerCase()) || !0 === e && this.hasParents(t, e, i.parentNode));
}, Caret.prototype.is = function (t, e) {
  switch (t) {
    case "formatBlock":
      return "DIV" === e && this.parent === this.el || this.hasParent(e, "PRE" === e);

    case "link":
      return this.hasParent("A", !0);

    case "fontSize":
      return document.queryCommandValue(t) === e;

    case "fontName":
      var i = document.queryCommandValue(t);
      return i === '"' + e + '"' || i === e;

    case "fullscreen":
      return this.vm.inFullscreen;

    case "viewsource":
      return this.vm.isViewingSource;

    case void 0:
      return !1;

    default:
      var s = document.queryCommandState(t);
      return void 0 !== e ? s === e : s;
  }
}, Caret.prototype.getParentAttribute = function (t) {
  return null !== this.parent ? this.parent.getAttribute(t) : null;
}, Caret.prototype.can = function (t) {
  return "outdent" === t ? this.hasParents(["blockquote", "li"], !0) : "indent" === t ? this.hasParents(["li"], !0) : "link" === t ? null !== this.selection || this.is("link") : void 0;
}, Caret.prototype.apply = function (t, e, i) {
  if (void 0 === i && (i = noop), "formatBlock" === t) ["BLOCKQUOTE", "H1", "H2", "H3", "H4", "H5", "H6"].includes(e) && this.is(t, e) && (t = "outdent", e = null), "PRE" === e && this.is(t, "PRE") && (e = "P");else {
    if ("print" === t) {
      i();
      var s = window.open();
      return s.document.write("\n        <!doctype html>\n        <html>\n          <head>\n            <title>Print - " + document.title + "</title>\n          </head>\n          <body>\n            <div>" + this.el.innerHTML + "</div>\n          </body>\n        </html>\n      "), s.print(), void s.close();
    }

    if ("link" === t) {
      var n = this.getParentAttribute("href");

      if (null === n) {
        var o = this.selectWord(this.selection),
            r = o ? o.toString() : "";
        if (!r.length) return;
        this.vm.editLinkUrl = urlRegex.test(r) ? r : "https://", document.execCommand("createLink", !1, this.vm.editLinkUrl), this.save(o.getRangeAt(0));
      } else this.vm.editLinkUrl = n, this.range.selectNodeContents(this.parent), this.save();

      return;
    }

    if ("fullscreen" === t) return this.vm.toggleFullscreen(), void i();
    if ("viewsource" === t) return this.vm.isViewingSource = !1 === this.vm.isViewingSource, this.vm.__setContent(this.vm.value), void i();
  }
  document.execCommand(t, !1, e), i();
}, Caret.prototype.selectWord = function (t) {
  if (null === t || !0 !== t.isCollapsed || void 0 === t.modify) return t;
  var e = document.createRange();
  e.setStart(t.anchorNode, t.anchorOffset), e.setEnd(t.focusNode, t.focusOffset);
  var i = e.collapsed ? ["backward", "forward"] : ["forward", "backward"];
  e.detach();
  var s = t.focusNode,
      n = t.focusOffset;
  return t.collapse(t.anchorNode, t.anchorOffset), t.modify("move", i[0], "character"), t.modify("move", i[1], "word"), t.extend(s, n), t.modify("extend", i[1], "character"), t.modify("extend", i[0], "word"), t;
}, Object.defineProperties(Caret.prototype, prototypeAccessors);
var quasar_esm_toString = Object.prototype.toString,
    hasOwn = Object.prototype.hasOwnProperty,
    class2type = {};

function type(t) {
  return null === t ? String(t) : class2type[quasar_esm_toString.call(t)] || "object";
}

function isPlainObject(t) {
  if (!t || "object" !== type(t)) return !1;
  if (t.constructor && !hasOwn.call(t, "constructor") && !hasOwn.call(t.constructor.prototype, "isPrototypeOf")) return !1;
  var e;

  for (e in t) {
    ;
  }

  return void 0 === e || hasOwn.call(t, e);
}

function extend() {
  var t,
      e,
      i,
      s,
      n,
      o,
      r = arguments,
      a = arguments[0] || {},
      l = 1,
      c = arguments.length,
      u = !1;

  for ("boolean" == typeof a && (u = a, a = arguments[1] || {}, l = 2), Object(a) !== a && "function" !== type(a) && (a = {}), c === l && (a = this, l--); l < c; l++) {
    if (null !== (t = r[l])) for (e in t) {
      i = a[e], a !== (s = t[e]) && (u && s && (isPlainObject(s) || (n = "array" === type(s))) ? (n ? (n = !1, o = i && "array" === type(i) ? i : []) : o = i && isPlainObject(i) ? i : {}, a[e] = extend(u, o, s)) : void 0 !== s && (a[e] = s));
    }
  }

  return a;
}

"Boolean Number String Function Array Date RegExp Object".split(" ").forEach(function (t) {
  class2type["[object " + t + "]"] = t.toLowerCase();
});
var QEditor = vue_runtime_esm["a" /* default */].extend({
  name: "QEditor",
  mixins: [ListenersMixin, FullscreenMixin, DarkMixin],
  props: {
    value: {
      type: String,
      required: !0
    },
    readonly: Boolean,
    disable: Boolean,
    minHeight: {
      type: String,
      default: "10rem"
    },
    maxHeight: String,
    height: String,
    definitions: Object,
    fonts: Object,
    placeholder: String,
    toolbar: {
      type: Array,
      validator: function validator(t) {
        return 0 === t.length || t.every(function (t) {
          return t.length;
        });
      },
      default: function _default() {
        return [["left", "center", "right", "justify"], ["bold", "italic", "underline", "strike"], ["undo", "redo"]];
      }
    },
    toolbarColor: String,
    toolbarBg: String,
    toolbarTextColor: String,
    toolbarToggleColor: {
      type: String,
      default: "primary"
    },
    toolbarOutline: Boolean,
    toolbarPush: Boolean,
    toolbarRounded: Boolean,
    contentStyle: Object,
    contentClass: [Object, Array, String],
    square: Boolean,
    flat: Boolean,
    dense: Boolean
  },
  computed: {
    editable: function editable() {
      return !this.readonly && !this.disable;
    },
    hasToolbar: function hasToolbar() {
      return this.toolbar && this.toolbar.length > 0;
    },
    toolbarBackgroundClass: function toolbarBackgroundClass() {
      if (this.toolbarBg) return "bg-" + this.toolbarBg;
    },
    buttonProps: function buttonProps() {
      return {
        type: "a",
        flat: !0 !== this.toolbarOutline && !0 !== this.toolbarPush,
        noWrap: !0,
        outline: this.toolbarOutline,
        push: this.toolbarPush,
        rounded: this.toolbarRounded,
        dense: !0,
        color: this.toolbarColor,
        disable: !this.editable,
        size: "sm"
      };
    },
    buttonDef: function buttonDef() {
      var t = this.$q.lang.editor,
          e = this.$q.iconSet.editor;
      return {
        bold: {
          cmd: "bold",
          icon: e.bold,
          tip: t.bold,
          key: 66
        },
        italic: {
          cmd: "italic",
          icon: e.italic,
          tip: t.italic,
          key: 73
        },
        strike: {
          cmd: "strikeThrough",
          icon: e.strikethrough,
          tip: t.strikethrough,
          key: 83
        },
        underline: {
          cmd: "underline",
          icon: e.underline,
          tip: t.underline,
          key: 85
        },
        unordered: {
          cmd: "insertUnorderedList",
          icon: e.unorderedList,
          tip: t.unorderedList
        },
        ordered: {
          cmd: "insertOrderedList",
          icon: e.orderedList,
          tip: t.orderedList
        },
        subscript: {
          cmd: "subscript",
          icon: e.subscript,
          tip: t.subscript,
          htmlTip: "x<subscript>2</subscript>"
        },
        superscript: {
          cmd: "superscript",
          icon: e.superscript,
          tip: t.superscript,
          htmlTip: "x<superscript>2</superscript>"
        },
        link: {
          cmd: "link",
          disable: function disable(t) {
            return t.caret && !t.caret.can("link");
          },
          icon: e.hyperlink,
          tip: t.hyperlink,
          key: 76
        },
        fullscreen: {
          cmd: "fullscreen",
          icon: e.toggleFullscreen,
          tip: t.toggleFullscreen,
          key: 70
        },
        viewsource: {
          cmd: "viewsource",
          icon: e.viewSource,
          tip: t.viewSource
        },
        quote: {
          cmd: "formatBlock",
          param: "BLOCKQUOTE",
          icon: e.quote,
          tip: t.quote,
          key: 81
        },
        left: {
          cmd: "justifyLeft",
          icon: e.left,
          tip: t.left
        },
        center: {
          cmd: "justifyCenter",
          icon: e.center,
          tip: t.center
        },
        right: {
          cmd: "justifyRight",
          icon: e.right,
          tip: t.right
        },
        justify: {
          cmd: "justifyFull",
          icon: e.justify,
          tip: t.justify
        },
        print: {
          type: "no-state",
          cmd: "print",
          icon: e.print,
          tip: t.print,
          key: 80
        },
        outdent: {
          type: "no-state",
          disable: function disable(t) {
            return t.caret && !t.caret.can("outdent");
          },
          cmd: "outdent",
          icon: e.outdent,
          tip: t.outdent
        },
        indent: {
          type: "no-state",
          disable: function disable(t) {
            return t.caret && !t.caret.can("indent");
          },
          cmd: "indent",
          icon: e.indent,
          tip: t.indent
        },
        removeFormat: {
          type: "no-state",
          cmd: "removeFormat",
          icon: e.removeFormat,
          tip: t.removeFormat
        },
        hr: {
          type: "no-state",
          cmd: "insertHorizontalRule",
          icon: e.hr,
          tip: t.hr
        },
        undo: {
          type: "no-state",
          cmd: "undo",
          icon: e.undo,
          tip: t.undo,
          key: 90
        },
        redo: {
          type: "no-state",
          cmd: "redo",
          icon: e.redo,
          tip: t.redo,
          key: 89
        },
        h1: {
          cmd: "formatBlock",
          param: "H1",
          icon: e.heading1 || e.heading,
          tip: t.heading1,
          htmlTip: '<h1 class="q-ma-none">' + t.heading1 + "</h1>"
        },
        h2: {
          cmd: "formatBlock",
          param: "H2",
          icon: e.heading2 || e.heading,
          tip: t.heading2,
          htmlTip: '<h2 class="q-ma-none">' + t.heading2 + "</h2>"
        },
        h3: {
          cmd: "formatBlock",
          param: "H3",
          icon: e.heading3 || e.heading,
          tip: t.heading3,
          htmlTip: '<h3 class="q-ma-none">' + t.heading3 + "</h3>"
        },
        h4: {
          cmd: "formatBlock",
          param: "H4",
          icon: e.heading4 || e.heading,
          tip: t.heading4,
          htmlTip: '<h4 class="q-ma-none">' + t.heading4 + "</h4>"
        },
        h5: {
          cmd: "formatBlock",
          param: "H5",
          icon: e.heading5 || e.heading,
          tip: t.heading5,
          htmlTip: '<h5 class="q-ma-none">' + t.heading5 + "</h5>"
        },
        h6: {
          cmd: "formatBlock",
          param: "H6",
          icon: e.heading6 || e.heading,
          tip: t.heading6,
          htmlTip: '<h6 class="q-ma-none">' + t.heading6 + "</h6>"
        },
        p: {
          cmd: "formatBlock",
          param: "DIV",
          icon: e.heading,
          tip: t.paragraph
        },
        code: {
          cmd: "formatBlock",
          param: "PRE",
          icon: e.code,
          htmlTip: "<code>" + t.code + "</code>"
        },
        "size-1": {
          cmd: "fontSize",
          param: "1",
          icon: e.size1 || e.size,
          tip: t.size1,
          htmlTip: '<font size="1">' + t.size1 + "</font>"
        },
        "size-2": {
          cmd: "fontSize",
          param: "2",
          icon: e.size2 || e.size,
          tip: t.size2,
          htmlTip: '<font size="2">' + t.size2 + "</font>"
        },
        "size-3": {
          cmd: "fontSize",
          param: "3",
          icon: e.size3 || e.size,
          tip: t.size3,
          htmlTip: '<font size="3">' + t.size3 + "</font>"
        },
        "size-4": {
          cmd: "fontSize",
          param: "4",
          icon: e.size4 || e.size,
          tip: t.size4,
          htmlTip: '<font size="4">' + t.size4 + "</font>"
        },
        "size-5": {
          cmd: "fontSize",
          param: "5",
          icon: e.size5 || e.size,
          tip: t.size5,
          htmlTip: '<font size="5">' + t.size5 + "</font>"
        },
        "size-6": {
          cmd: "fontSize",
          param: "6",
          icon: e.size6 || e.size,
          tip: t.size6,
          htmlTip: '<font size="6">' + t.size6 + "</font>"
        },
        "size-7": {
          cmd: "fontSize",
          param: "7",
          icon: e.size7 || e.size,
          tip: t.size7,
          htmlTip: '<font size="7">' + t.size7 + "</font>"
        }
      };
    },
    buttons: function buttons() {
      var t = this,
          e = this.definitions || {},
          i = this.definitions || this.fonts ? extend(!0, {}, this.buttonDef, e, getFonts(this.defaultFont, this.$q.lang.editor.defaultFont, this.$q.iconSet.editor.font, this.fonts)) : this.buttonDef;
      return this.toolbar.map(function (s) {
        return s.map(function (s) {
          if (s.options) return {
            type: "dropdown",
            icon: s.icon,
            label: s.label,
            size: "sm",
            dense: !0,
            fixedLabel: s.fixedLabel,
            fixedIcon: s.fixedIcon,
            highlight: s.highlight,
            list: s.list,
            options: s.options.map(function (t) {
              return i[t];
            })
          };
          var n = i[s];
          return n ? "no-state" === n.type || e[s] && (void 0 === n.cmd || t.buttonDef[n.cmd] && "no-state" === t.buttonDef[n.cmd].type) ? n : Object.assign({
            type: "toggle"
          }, n) : {
            type: "slot",
            slot: s
          };
        });
      });
    },
    keys: function keys() {
      var t = {},
          e = function e(_e2) {
        _e2.key && (t[_e2.key] = {
          cmd: _e2.cmd,
          param: _e2.param
        });
      };

      return this.buttons.forEach(function (t) {
        t.forEach(function (t) {
          t.options ? t.options.forEach(e) : e(t);
        });
      }), t;
    },
    innerStyle: function innerStyle() {
      return this.inFullscreen ? this.contentStyle : [{
        minHeight: this.minHeight,
        height: this.height,
        maxHeight: this.maxHeight
      }, this.contentStyle];
    },
    innerClass: function innerClass() {
      return [this.contentClass, {
        col: this.inFullscreen,
        "overflow-auto": this.inFullscreen || this.maxHeight
      }];
    },
    attrs: function attrs() {
      return !0 === this.disable ? {
        "aria-disabled": ""
      } : !0 === this.readonly ? {
        "aria-readonly": ""
      } : void 0;
    }
  },
  data: function data() {
    return {
      editWatcher: !0,
      editLinkUrl: null,
      isViewingSource: !1
    };
  },
  watch: {
    value: function value(t) {
      !0 === this.editWatcher ? this.__setContent(t) : this.editWatcher = !0;
    }
  },
  methods: {
    __onInput: function __onInput() {
      if (!0 === this.editWatcher && void 0 !== this.$refs.content) {
        var t = this.isViewingSource ? this.$refs.content.innerText : this.$refs.content.innerHTML;
        t !== this.value && (this.editWatcher = !1, this.$emit("input", t));
      }
    },
    __onKeydown: function __onKeydown(t) {
      if (this.$emit("keydown", t), !0 !== t.ctrlKey || !0 === shouldIgnoreKey(t)) return this.refreshToolbar(), void (this.$q.platform.is.ie && this.$nextTick(this.__onInput));
      var e = t.keyCode,
          i = this.keys[e];

      if (void 0 !== i) {
        var s = i.cmd,
            n = i.param;
        stopAndPrevent(t), this.runCmd(s, n, !1);
      }
    },
    __onClick: function __onClick(t) {
      this.refreshToolbar(), this.$emit("click", t);
    },
    __onBlur: function __onBlur() {
      if (void 0 !== this.$refs.content) {
        var t = this.$refs.content,
            e = t.scrollTop,
            i = t.scrollHeight;
        this.__offsetBottom = i - e;
      }

      !0 !== this.$q.platform.is.ie && this.caret.save(), this.$emit("blur");
    },
    __onFocus: function __onFocus() {
      var t = this;
      this.$nextTick(function () {
        void 0 !== t.$refs.content && void 0 !== t.__offsetBottom && (t.$refs.content.scrollTop = t.$refs.content.scrollHeight - t.__offsetBottom);
      });
    },
    __onMouseup: function __onMouseup(t) {
      this.caret.save(), void 0 !== this.qListeners.mouseup && this.$emit("mouseup", t);
    },
    __onKeyup: function __onKeyup(t) {
      this.caret.save(), void 0 !== this.qListeners.keyup && this.$emit("keyup", t);
    },
    __onTouchend: function __onTouchend(t) {
      this.caret.save(), void 0 !== this.qListeners.touchend && this.$emit("touchend", t);
    },
    runCmd: function runCmd(t, e, i) {
      var s = this;
      void 0 === i && (i = !0), this.focus(), this.caret.restore(), this.caret.apply(t, e, function () {
        s.focus(), s.caret.save(), !0 !== s.$q.platform.is.ie && !0 !== s.$q.platform.is.edge || s.$nextTick(s.__onInput), i && s.refreshToolbar();
      });
    },
    refreshToolbar: function refreshToolbar() {
      var t = this;
      setTimeout(function () {
        t.editLinkUrl = null, t.$forceUpdate();
      }, 1);
    },
    focus: function focus() {
      void 0 !== this.$refs.content && this.$refs.content.focus();
    },
    getContentEl: function getContentEl() {
      return this.$refs.content;
    },
    __setContent: function __setContent(t) {
      void 0 !== this.$refs.content && (this.isViewingSource ? this.$refs.content.innerText = t : this.$refs.content.innerHTML = t);
    }
  },
  created: function created() {
    !1 === isSSR && (document.execCommand("defaultParagraphSeparator", !1, "div"), this.defaultFont = window.getComputedStyle(document.body).fontFamily);
  },
  mounted: function mounted() {
    this.caret = new Caret(this.$refs.content, this), this.__setContent(this.value), this.refreshToolbar();
  },
  render: function render(t) {
    var e;

    if (this.hasToolbar) {
      var i = [];
      i.push(t("div", {
        key: "qedt_top",
        staticClass: "q-editor__toolbar row no-wrap scroll-x",
        class: this.toolbarBackgroundClass
      }, getToolbar(t, this))), null !== this.editLinkUrl && i.push(t("div", {
        key: "qedt_btm",
        staticClass: "q-editor__toolbar row no-wrap items-center scroll-x",
        class: this.toolbarBackgroundClass
      }, getLinkEditor(t, this, this.$q.platform.is.ie))), e = t("div", {
        key: "toolbar_ctainer",
        staticClass: "q-editor__toolbars-container"
      }, i);
    }

    var s = Object.assign({}, this.qListeners, {
      input: this.__onInput,
      keydown: this.__onKeydown,
      click: this.__onClick,
      blur: this.__onBlur,
      focus: this.__onFocus,
      mouseup: this.__onMouseup,
      keyup: this.__onKeyup,
      touchend: this.__onTouchend
    });
    return t("div", {
      staticClass: "q-editor",
      style: {
        height: !0 === this.inFullscreen ? "100vh" : null
      },
      class: {
        disabled: this.disable,
        "fullscreen column": this.inFullscreen,
        "q-editor--square no-border-radius": this.square,
        "q-editor--flat": this.flat,
        "q-editor--dense": this.dense,
        "q-editor--dark q-dark": this.isDark
      },
      attrs: this.attrs
    }, [e, t("div", {
      ref: "content",
      staticClass: "q-editor__content",
      style: this.innerStyle,
      class: this.innerClass,
      attrs: {
        contenteditable: this.editable,
        placeholder: this.placeholder
      },
      domProps: isSSR ? {
        innerHTML: this.value
      } : void 0,
      on: s
    })]);
  }
}),
    QItemLabel = vue_runtime_esm["a" /* default */].extend({
  name: "QItemLabel",
  mixins: [ListenersMixin],
  props: {
    overline: Boolean,
    caption: Boolean,
    header: Boolean,
    lines: [Number, String]
  },
  computed: {
    classes: function classes() {
      return {
        "q-item__label--overline text-overline": this.overline,
        "q-item__label--caption text-caption": this.caption,
        "q-item__label--header": this.header,
        ellipsis: 1 === parseInt(this.lines, 10)
      };
    },
    style: function style() {
      if (void 0 !== this.lines && parseInt(this.lines, 10) > 1) return {
        overflow: "hidden",
        display: "-webkit-box",
        "-webkit-box-orient": "vertical",
        "-webkit-line-clamp": this.lines
      };
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-item__label",
      style: this.style,
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QSlideTransition = vue_runtime_esm["a" /* default */].extend({
  name: "QSlideTransition",
  props: {
    appear: Boolean,
    duration: {
      type: Number,
      default: 300
    }
  },
  methods: {
    __begin: function __begin(t, e, i) {
      t.style.overflowY = "hidden", void 0 !== e && (t.style.height = e + "px"), t.style.transition = "height " + this.duration + "ms cubic-bezier(.25, .8, .50, 1)", this.animating = !0, this.done = i;
    },
    __end: function __end(t, e) {
      t.style.overflowY = null, t.style.height = null, t.style.transition = null, this.__cleanup(), e !== this.lastEvent && this.$emit(e);
    },
    __cleanup: function __cleanup() {
      this.done && this.done(), this.done = null, this.animating = !1, clearTimeout(this.timer), clearTimeout(this.timerFallback), void 0 !== this.el && this.el.removeEventListener("transitionend", this.animListener), this.animListener = null;
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.animating && this.__cleanup();
  },
  render: function render(t) {
    var e = this;
    return t("transition", {
      props: {
        css: !1,
        appear: this.appear
      },
      on: cache(this, "tr", {
        enter: function enter(t, i) {
          var s = 0;
          e.el = t, !0 === e.animating ? (e.__cleanup(), s = t.offsetHeight === t.scrollHeight ? 0 : void 0) : e.lastEvent = "hide", e.__begin(t, s, i), e.timer = setTimeout(function () {
            t.style.height = t.scrollHeight + "px", e.animListener = function (i) {
              Object(i) === i && i.target !== t || e.__end(t, "show");
            }, t.addEventListener("transitionend", e.animListener), e.timerFallback = setTimeout(e.animListener, 1.1 * e.duration);
          }, 100);
        },
        leave: function leave(t, i) {
          var s;
          e.el = t, !0 === e.animating ? e.__cleanup() : (e.lastEvent = "show", s = t.scrollHeight), e.__begin(t, s, i), e.timer = setTimeout(function () {
            t.style.height = 0, e.animListener = function (i) {
              Object(i) === i && i.target !== t || e.__end(t, "hide");
            }, t.addEventListener("transitionend", e.animListener), e.timerFallback = setTimeout(e.animListener, 1.1 * e.duration);
          }, 100);
        }
      })
    }, slot(this, "default"));
  }
}),
    QSeparator = vue_runtime_esm["a" /* default */].extend({
  name: "QSeparator",
  mixins: [DarkMixin, ListenersMixin],
  props: {
    spaced: Boolean,
    inset: [Boolean, String],
    vertical: Boolean,
    color: String
  },
  computed: {
    insetClass: function insetClass() {
      switch (this.inset) {
        case !0:
          return " q-separator--inset";

        case "item":
          return " q-separator--item-inset";

        case "item-thumbnail":
          return " q-separator--item-thumbnail-inset";

        default:
          return "";
      }
    },
    classes: function classes() {
      return "q-separator" + this.insetClass + " q-separator--" + (!0 === this.vertical ? "vertical self-stretch" : "horizontal col-grow") + (void 0 !== this.color ? " bg-" + this.color : "") + (!0 === this.isDark ? " q-separator--dark" : "") + (!0 === this.spaced ? " q-separator--spaced" : "");
    },
    attrs: function attrs() {
      return {
        role: "separator",
        "aria-orientation": !0 === this.vertical ? "vertical" : "horizontal"
      };
    }
  },
  render: function render(t) {
    return t("hr", {
      staticClass: "q-separator",
      class: this.classes,
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    });
  }
}),
    eventName = "q:expansion-item:close",
    QExpansionItem = vue_runtime_esm["a" /* default */].extend({
  name: "QExpansionItem",
  mixins: [DarkMixin, RouterLinkMixin, ModelToggleMixin],
  props: {
    icon: String,
    label: String,
    labelLines: [Number, String],
    caption: String,
    captionLines: [Number, String],
    dense: Boolean,
    expandIcon: String,
    expandedIcon: String,
    expandIconClass: [Array, String, Object],
    duration: Number,
    headerInsetLevel: Number,
    contentInsetLevel: Number,
    expandSeparator: Boolean,
    defaultOpened: Boolean,
    expandIconToggle: Boolean,
    switchToggleSide: Boolean,
    denseToggle: Boolean,
    group: String,
    popup: Boolean,
    headerStyle: [Array, String, Object],
    headerClass: [Array, String, Object]
  },
  data: function data() {
    return {
      showing: void 0 !== this.value ? this.value : this.defaultOpened
    };
  },
  watch: {
    showing: function showing(t) {
      !0 === t && void 0 !== this.group && this.$root.$emit(eventName, this);
    },
    group: function group(t, e) {
      void 0 !== t && void 0 === e ? this.$root.$on(eventName, this.__eventHandler) : void 0 === t && void 0 !== e && this.$root.$off(eventName, this.__eventHandler);
    }
  },
  computed: {
    classes: function classes() {
      return "q-expansion-item--" + (!0 === this.showing ? "expanded" : "collapsed") + " q-expansion-item--" + (!0 === this.popup ? "popup" : "standard");
    },
    contentStyle: function contentStyle() {
      var t;
      if (void 0 !== this.contentInsetLevel) return (t = {})["padding" + (!0 === this.$q.lang.rtl ? "Right" : "Left")] = 56 * this.contentInsetLevel + "px", t;
    },
    isClickable: function isClickable() {
      return !0 === this.hasRouterLink || !0 !== this.expandIconToggle;
    },
    expansionIcon: function expansionIcon() {
      return void 0 !== this.expandedIcon && !0 === this.showing ? this.expandedIcon : this.expandIcon || this.$q.iconSet.expansionItem[!0 === this.denseToggle ? "denseIcon" : "icon"];
    },
    activeToggleIcon: function activeToggleIcon() {
      return !0 !== this.disable && (!0 === this.hasRouterLink || !0 === this.expandIconToggle);
    }
  },
  methods: {
    __onHeaderClick: function __onHeaderClick(t) {
      !0 !== this.hasRouterLink && this.toggle(t), this.$emit("click", t);
    },
    __toggleIconKeyboard: function __toggleIconKeyboard(t) {
      13 === t.keyCode && this.__toggleIcon(t, !0);
    },
    __toggleIcon: function __toggleIcon(t, e) {
      !0 !== e && void 0 !== this.$refs.blurTarget && this.$refs.blurTarget.focus(), this.toggle(t), stopAndPrevent(t);
    },
    __eventHandler: function __eventHandler(t) {
      this !== t && this.group === t.group && this.hide();
    },
    __getToggleIcon: function __getToggleIcon(t) {
      var e = {
        staticClass: "q-focusable relative-position cursor-pointer" + (!0 === this.denseToggle && !0 === this.switchToggleSide ? " items-end" : ""),
        class: this.expandIconClass,
        props: {
          side: !0 !== this.switchToggleSide,
          avatar: this.switchToggleSide
        }
      },
          i = [t(QIcon, {
        staticClass: "q-expansion-item__toggle-icon",
        class: void 0 === this.expandedIcon && !0 === this.showing ? "q-expansion-item__toggle-icon--rotated" : void 0,
        props: {
          name: this.expansionIcon
        }
      })];
      return !0 === this.activeToggleIcon && (Object.assign(e, {
        attrs: {
          tabindex: 0
        },
        on: cache(this, "inpExt", {
          click: this.__toggleIcon,
          keyup: this.__toggleIconKeyboard
        })
      }), i.unshift(t("div", {
        ref: "blurTarget",
        staticClass: "q-expansion-item__toggle-focus q-icon q-focus-helper q-focus-helper--rounded",
        attrs: {
          tabindex: -1
        }
      }))), t(QItemSection, e, i);
    },
    __getHeader: function __getHeader(t) {
      var e;
      void 0 !== this.$scopedSlots.header ? e = this.$scopedSlots.header().slice() : (e = [t(QItemSection, [t(QItemLabel, {
        props: {
          lines: this.labelLines
        }
      }, [this.label || ""]), this.caption ? t(QItemLabel, {
        props: {
          lines: this.captionLines,
          caption: !0
        }
      }, [this.caption]) : null])], this.icon && e[!0 === this.switchToggleSide ? "push" : "unshift"](t(QItemSection, {
        props: {
          side: !0 === this.switchToggleSide,
          avatar: !0 !== this.switchToggleSide
        }
      }, [t(QIcon, {
        props: {
          name: this.icon
        }
      })]))), !0 !== this.disable && e[!0 === this.switchToggleSide ? "unshift" : "push"](this.__getToggleIcon(t));
      var i = {
        ref: "item",
        style: this.headerStyle,
        class: this.headerClass,
        props: {
          dark: this.isDark,
          disable: this.disable,
          dense: this.dense,
          insetLevel: this.headerInsetLevel
        }
      };

      if (!0 === this.isClickable) {
        var s = !0 === this.hasRouterLink ? "nativeOn" : "on";
        i.props.clickable = !0, i[s] = Object.assign({}, this.qListeners, {
          click: this.__onHeaderClick
        }), !0 === this.hasRouterLink && Object.assign(i.props, this.routerLinkProps);
      }

      return t(QItem, i, e);
    },
    __getContent: function __getContent(t) {
      var e = this,
          i = [this.__getHeader(t), t(QSlideTransition, {
        props: {
          duration: this.duration
        },
        on: cache(this, "slide", {
          show: function show() {
            e.$emit("after-show");
          },
          hide: function hide() {
            e.$emit("after-hide");
          }
        })
      }, [t("div", {
        staticClass: "q-expansion-item__content relative-position",
        style: this.contentStyle,
        directives: [{
          name: "show",
          value: this.showing
        }]
      }, slot(this, "default"))])];
      return this.expandSeparator && i.push(t(QSeparator, {
        staticClass: "q-expansion-item__border q-expansion-item__border--top absolute-top",
        props: {
          dark: this.isDark
        }
      }), t(QSeparator, {
        staticClass: "q-expansion-item__border q-expansion-item__border--bottom absolute-bottom",
        props: {
          dark: this.isDark
        }
      })), i;
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-expansion-item q-item-type",
      class: this.classes
    }, [t("div", {
      staticClass: "q-expansion-item__container relative-position"
    }, this.__getContent(t))]);
  },
  created: function created() {
    void 0 !== this.group && this.$root.$on(eventName, this.__eventHandler);
  },
  beforeDestroy: function beforeDestroy() {
    void 0 !== this.group && this.$root.$off(eventName, this.__eventHandler);
  }
}),
    labelPositions = ["top", "right", "bottom", "left"],
    FabMixin = {
  props: {
    type: {
      type: String,
      default: "a"
    },
    outline: Boolean,
    push: Boolean,
    flat: Boolean,
    unelevated: Boolean,
    color: String,
    textColor: String,
    glossy: Boolean,
    square: Boolean,
    padding: String,
    label: {
      type: [String, Number],
      default: ""
    },
    labelPosition: {
      type: String,
      default: "right",
      validator: function validator(t) {
        return labelPositions.includes(t);
      }
    },
    externalLabel: Boolean,
    hideLabel: {
      type: Boolean
    },
    labelClass: [Array, String, Object],
    labelStyle: [Array, String, Object],
    disable: Boolean
  },
  computed: {
    formClass: function formClass() {
      return "q-fab--form-" + (!0 === this.square ? "square" : "rounded");
    },
    stacked: function stacked() {
      return !1 === this.externalLabel && ["top", "bottom"].includes(this.labelPosition);
    },
    labelProps: function labelProps() {
      if (!0 === this.externalLabel) {
        var t = null === this.hideLabel ? !1 === this.showing : this.hideLabel;
        return {
          action: "push",
          data: {
            staticClass: "q-fab__label q-tooltip--style q-fab__label--external q-fab__label--external-" + this.labelPosition + (!0 === t ? " q-fab__label--external-hidden" : ""),
            style: this.labelStyle,
            class: this.labelClass
          }
        };
      }

      return {
        action: ["left", "top"].includes(this.labelPosition) ? "unshift" : "push",
        data: {
          staticClass: "q-fab__label q-fab__label--internal q-fab__label--internal-" + this.labelPosition + (!0 === this.hideLabel ? " q-fab__label--internal-hidden" : ""),
          style: this.labelStyle,
          class: this.labelClass
        }
      };
    }
  }
},
    directions$1 = ["up", "right", "down", "left"],
    alignValues$1 = ["left", "center", "right"],
    QFab = vue_runtime_esm["a" /* default */].extend({
  name: "QFab",
  mixins: [FabMixin, ModelToggleMixin],
  provide: function provide() {
    var t = this;
    return {
      __qFabClose: function __qFabClose(e) {
        t.hide(e), t.$refs.trigger && t.$refs.trigger.$el && t.$refs.trigger.$el.focus();
      }
    };
  },
  props: {
    icon: String,
    activeIcon: String,
    hideIcon: Boolean,
    hideLabel: {
      default: null
    },
    direction: {
      type: String,
      default: "right",
      validator: function validator(t) {
        return directions$1.includes(t);
      }
    },
    persistent: Boolean,
    verticalActionsAlign: {
      type: String,
      default: "center",
      validator: function validator(t) {
        return alignValues$1.includes(t);
      }
    }
  },
  data: function data() {
    return {
      showing: !0 === this.value
    };
  },
  computed: {
    hideOnRouteChange: function hideOnRouteChange() {
      return !0 !== this.persistent;
    },
    classes: function classes() {
      return "q-fab--align-" + this.verticalActionsAlign + " " + this.formClass + (!0 === this.showing ? " q-fab--opened" : "");
    }
  },
  render: function render(t) {
    var e = [];
    return !0 !== this.hideIcon && e.push(t("div", {
      staticClass: "q-fab__icon-holder"
    }, [t(QIcon, {
      staticClass: "q-fab__icon absolute-full",
      props: {
        name: this.icon || this.$q.iconSet.fab.icon
      }
    }), t(QIcon, {
      staticClass: "q-fab__active-icon absolute-full",
      props: {
        name: this.activeIcon || this.$q.iconSet.fab.activeIcon
      }
    })])), "" !== this.label && e[this.labelProps.action](t("div", this.labelProps.data, [this.label])), t("div", {
      staticClass: "q-fab z-fab row inline justify-center",
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, [t("div", {
      staticClass: "q-fab__actions flex no-wrap inline",
      class: "q-fab__actions--" + this.direction
    }, slot(this, "default")), t(QBtn, {
      ref: "trigger",
      class: this.formClass,
      props: Object.assign({}, this.$props, {
        noWrap: !0,
        stack: this.stacked,
        align: void 0,
        icon: void 0,
        label: void 0,
        noCaps: !0,
        fab: !0
      }),
      on: cache(this, "tog", {
        click: this.toggle
      })
    }, mergeSlot(e, this, "tooltip"))]);
  }
}),
    anchorMap = {
  start: "self-end",
  center: "self-center",
  end: "self-start"
},
    anchorValues = Object.keys(anchorMap),
    QFabAction = vue_runtime_esm["a" /* default */].extend({
  name: "QFabAction",
  mixins: [ListenersMixin, FabMixin],
  props: {
    icon: {
      type: String,
      default: ""
    },
    anchor: {
      type: String,
      validator: function validator(t) {
        return anchorValues.includes(t);
      }
    },
    to: [String, Object],
    replace: Boolean
  },
  inject: {
    __qFabClose: {
      default: function _default() {
        console.error("QFabAction needs to be child of QFab");
      }
    }
  },
  computed: {
    classes: function classes() {
      var t = anchorMap[this.anchor];
      return this.formClass + (void 0 !== t ? " " + t : "");
    },
    onEvents: function onEvents() {
      return Object.assign({}, this.qListeners, {
        click: this.click
      });
    }
  },
  methods: {
    click: function click(t) {
      this.__qFabClose(), this.$emit("click", t);
    }
  },
  render: function render(t) {
    var e = [];
    return "" !== this.icon && e.push(t(QIcon, {
      props: {
        name: this.icon
      }
    })), "" !== this.label && e[this.labelProps.action](t("div", this.labelProps.data, [this.label])), t(QBtn, {
      class: this.classes,
      props: Object.assign({}, this.$props, {
        noWrap: !0,
        stack: this.stacked,
        icon: void 0,
        label: void 0,
        noCaps: !0,
        fabMini: !0
      }),
      on: this.onEvents
    }, mergeSlot(e, this, "default"));
  }
}),
    QFile = vue_runtime_esm["a" /* default */].extend({
  name: "QFile",
  mixins: [QField, FileMixin, FormFieldMixin, FileValueMixin],
  props: {
    value: !0 === isSSR ? {} : [File, FileList, Array],
    append: Boolean,
    useChips: Boolean,
    displayValue: [String, Number],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    counterLabel: Function,
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  data: function data() {
    return {
      dnd: !1
    };
  },
  computed: {
    innerValue: function innerValue() {
      return Object(this.value) === this.value ? "length" in this.value ? Array.from(this.value) : [this.value] : [];
    },
    selectedString: function selectedString() {
      return this.innerValue.map(function (t) {
        return t.name;
      }).join(", ");
    },
    totalSize: function totalSize() {
      return humanStorageSize(this.innerValue.reduce(function (t, e) {
        return t + e.size;
      }, 0));
    },
    counterProps: function counterProps() {
      return {
        totalSize: this.totalSize,
        filesNumber: this.innerValue.length,
        maxFiles: this.maxFiles
      };
    },
    computedCounter: function computedCounter() {
      if (void 0 !== this.counterLabel) return this.counterLabel(this.counterProps);
      var t = this.maxFiles;
      return this.innerValue.length + (void 0 !== t ? " / " + t : "") + " (" + this.totalSize + ")";
    },
    inputAttrs: function inputAttrs() {
      return Object.assign({}, {
        tabindex: -1,
        type: "file",
        title: "",
        accept: this.accept,
        name: this.nameProp
      }, this.qAttrs, {
        id: this.targetUid,
        disabled: !0 !== this.editable
      });
    },
    isAppending: function isAppending() {
      return !0 === this.multiple && !0 === this.append;
    }
  },
  methods: {
    removeAtIndex: function removeAtIndex(t) {
      var e = this.innerValue.slice();
      e.splice(t, 1), this.__emitValue(e);
    },
    removeFile: function removeFile(t) {
      var e = this.innerValue.findIndex(t);
      e > -1 && this.removeAtIndex(e);
    },
    __emitValue: function __emitValue(t) {
      this.$emit("input", !0 === this.multiple ? t : t[0]);
    },
    __onKeyup: function __onKeyup(t) {
      13 === t.keyCode && this.pickFiles(t);
    },
    __getFileInput: function __getFileInput() {
      return this.$refs.input;
    },
    __addFiles: function __addFiles(t, e) {
      var i = this.__processFiles(t, e, this.innerValue, this.isAppending);

      void 0 !== i && this.__emitValue(!0 === this.isAppending ? this.innerValue.concat(i) : i);
    },
    __getControl: function __getControl(t) {
      var e = {
        ref: "target",
        staticClass: "q-field__native row items-center cursor-pointer",
        attrs: {
          tabindex: this.tabindex
        }
      };
      return !0 === this.editable && (e.on = cache(this, "native", {
        dragover: this.__onDragOver,
        keyup: this.__onKeyup
      })), t("div", e, [this.__getInput(t)].concat(this.__getSelection(t)));
    },
    __getControlChild: function __getControlChild(t) {
      return this.__getDnd(t, "file");
    },
    __getSelection: function __getSelection(t) {
      var e = this;
      return void 0 !== this.$scopedSlots.file ? this.innerValue.map(function (t, i) {
        return e.$scopedSlots.file({
          index: i,
          file: t,
          ref: e
        });
      }) : void 0 !== this.$scopedSlots.selected ? this.$scopedSlots.selected({
        files: this.innerValue,
        ref: this
      }) : !0 === this.useChips ? this.innerValue.map(function (i, s) {
        return t(QChip, {
          key: "file-" + s,
          props: {
            removable: e.editable,
            dense: !0,
            textColor: e.color,
            tabindex: e.tabindex
          },
          on: cache(e, "rem#" + s, {
            remove: function remove() {
              e.removeAtIndex(s);
            }
          })
        }, [t("span", {
          staticClass: "ellipsis",
          domProps: {
            textContent: i.name
          }
        })]);
      }) : [t("div", {
        style: this.inputStyle,
        class: this.inputClass,
        domProps: {
          textContent: void 0 !== this.displayValue ? this.displayValue : this.selectedString
        }
      })];
    },
    __getInput: function __getInput(t) {
      var e = {
        ref: "input",
        staticClass: "q-field__input fit absolute-full cursor-pointer",
        attrs: this.inputAttrs,
        domProps: this.formDomProps,
        on: cache(this, "input", {
          change: this.__addFiles
        })
      };
      return !0 === this.multiple && (e.attrs.multiple = !0), t("input", e);
    }
  },
  created: function created() {
    this.fieldClass = "q-file q-field--auto-height", this.type = "file";
  }
}),
    QFooter = vue_runtime_esm["a" /* default */].extend({
  name: "QFooter",
  mixins: [ListenersMixin],
  inject: {
    layout: {
      default: function _default() {
        console.error("QFooter needs to be child of QLayout");
      }
    }
  },
  props: {
    value: {
      type: Boolean,
      default: !0
    },
    reveal: Boolean,
    bordered: Boolean,
    elevated: Boolean,
    heightHint: {
      type: [String, Number],
      default: 50
    }
  },
  data: function data() {
    return {
      size: parseInt(this.heightHint, 10),
      revealed: !0,
      windowHeight: onSSR || this.layout.container ? 0 : window.innerHeight
    };
  },
  watch: {
    value: function value(t) {
      this.__update("space", t), this.__updateLocal("revealed", !0), this.layout.__animate();
    },
    offset: function offset(t) {
      this.__update("offset", t);
    },
    reveal: function reveal(t) {
      !1 === t && this.__updateLocal("revealed", this.value);
    },
    revealed: function revealed(t) {
      this.layout.__animate(), this.$emit("reveal", t);
    },
    "layout.scroll": function layoutScroll() {
      this.__updateRevealed();
    },
    "layout.height": function layoutHeight() {
      this.__updateRevealed();
    },
    size: function size() {
      this.__updateRevealed();
    },
    "$q.screen.height": function $qScreenHeight(t) {
      !0 !== this.layout.container && this.__updateLocal("windowHeight", t);
    }
  },
  computed: {
    fixed: function fixed() {
      return !0 === this.reveal || this.layout.view.indexOf("F") > -1 || !0 === this.layout.container;
    },
    containerHeight: function containerHeight() {
      return !0 === this.layout.container ? this.layout.containerHeight : this.windowHeight;
    },
    offset: function offset() {
      if (!0 !== this.value) return 0;
      if (!0 === this.fixed) return !0 === this.revealed ? this.size : 0;
      var t = this.layout.scroll.position + this.containerHeight + this.size - this.layout.height;
      return t > 0 ? t : 0;
    },
    hidden: function hidden() {
      return !0 !== this.value || !0 === this.fixed && !0 !== this.revealed;
    },
    revealOnFocus: function revealOnFocus() {
      return !0 === this.value && !0 === this.hidden && !0 === this.reveal;
    },
    classes: function classes() {
      return (!0 === this.fixed ? "fixed" : "absolute") + "-bottom" + (!0 === this.bordered ? " q-footer--bordered" : "") + (!0 === this.hidden ? " q-footer--hidden" : "") + (!0 !== this.value ? " q-layout--prevent-focus" : "") + (!0 !== this.value && !0 !== this.fixed ? " hidden" : "");
    },
    style: function style() {
      var t = this.layout.rows.bottom,
          e = {};
      return "l" === t[0] && !0 === this.layout.left.space && (e[!0 === this.$q.lang.rtl ? "right" : "left"] = this.layout.left.size + "px"), "r" === t[2] && !0 === this.layout.right.space && (e[!0 === this.$q.lang.rtl ? "left" : "right"] = this.layout.right.size + "px"), e;
    },
    onEvents: function onEvents() {
      return Object.assign({}, this.qListeners, {
        focusin: this.__onFocusin,
        input: stop
      });
    }
  },
  render: function render(t) {
    var e = mergeSlot([t(QResizeObserver, {
      props: {
        debounce: 0
      },
      on: cache(this, "resize", {
        resize: this.__onResize
      })
    })], this, "default");
    return !0 === this.elevated && e.push(t("div", {
      staticClass: "q-layout__shadow absolute-full overflow-hidden no-pointer-events"
    })), t("footer", {
      staticClass: "q-footer q-layout__section--marginal",
      class: this.classes,
      style: this.style,
      on: this.onEvents
    }, e);
  },
  created: function created() {
    this.layout.instances.footer = this, !0 === this.value && this.__update("size", this.size), this.__update("space", this.value), this.__update("offset", this.offset);
  },
  beforeDestroy: function beforeDestroy() {
    this.layout.instances.footer === this && (this.layout.instances.footer = void 0, this.__update("size", 0), this.__update("offset", 0), this.__update("space", !1));
  },
  methods: {
    __onResize: function __onResize(t) {
      var e = t.height;
      this.__updateLocal("size", e), this.__update("size", e);
    },
    __update: function __update(t, e) {
      this.layout.footer[t] !== e && (this.layout.footer[t] = e);
    },
    __updateLocal: function __updateLocal(t, e) {
      this[t] !== e && (this[t] = e);
    },
    __updateRevealed: function __updateRevealed() {
      if (!0 === this.reveal) {
        var t = this.layout.scroll,
            e = t.direction,
            i = t.position,
            s = t.inflexionPosition;

        this.__updateLocal("revealed", "up" === e || i - s < 100 || this.layout.height - this.containerHeight - i - this.size < 300);
      }
    },
    __onFocusin: function __onFocusin(t) {
      !0 === this.revealOnFocus && this.__updateLocal("revealed", !0), this.$emit("focusin", t);
    }
  }
}),
    QForm = vue_runtime_esm["a" /* default */].extend({
  name: "QForm",
  mixins: [ListenersMixin],
  props: {
    autofocus: Boolean,
    noErrorFocus: Boolean,
    noResetFocus: Boolean,
    greedy: Boolean
  },
  computed: {
    onEvents: function onEvents() {
      return Object.assign({}, this.qListeners, {
        submit: this.submit,
        reset: this.reset
      });
    }
  },
  mounted: function mounted() {
    this.validateIndex = 0, !0 === this.autofocus && this.focus();
  },
  methods: {
    validate: function validate(t) {
      var e = this,
          i = [],
          s = "boolean" == typeof t ? t : !0 !== this.noErrorFocus;
      this.validateIndex++;

      for (var n = this.getValidationComponents(), o = function o(t, i) {
        e.$emit("validation-" + (!0 === t ? "success" : "error"), i);
      }, r = function r(t) {
        var r = n[t],
            a = r.validate();
        if ("function" == typeof a.then) i.push(a.then(function (t) {
          return {
            valid: t,
            comp: r
          };
        }, function (t) {
          return {
            valid: !1,
            comp: r,
            error: t
          };
        }));else if (!0 !== a) {
          if (!1 === e.greedy) return o(!1, r), !0 === s && "function" == typeof r.focus && r.focus(), {
            v: Promise.resolve(!1)
          };
          i.push({
            valid: !1,
            comp: r
          });
        }
      }, a = 0; a < n.length; a++) {
        var l = r(a);
        if (l) return l.v;
      }

      if (0 === i.length) return o(!0), Promise.resolve(!0);
      var c = this.validateIndex;
      return Promise.all(i).then(function (t) {
        if (c === e.validateIndex) {
          var i = t.filter(function (t) {
            return !0 !== t.valid;
          });
          if (0 === i.length) return o(!0), !0;
          var n = i[0],
              r = n.valid,
              a = n.comp;
          return o(!1, a), !0 === s && !0 !== r && "function" == typeof a.focus && a.focus(), !1;
        }
      });
    },
    resetValidation: function resetValidation() {
      this.validateIndex++, this.getValidationComponents().forEach(function (t) {
        t.resetValidation();
      });
    },
    submit: function submit(t) {
      var e = this;
      void 0 !== t && stopAndPrevent(t), this.validate().then(function (i) {
        !0 === i && (void 0 !== e.qListeners.submit ? e.$emit("submit", t) : void 0 !== t && void 0 !== t.target && "function" == typeof t.target.submit && t.target.submit());
      });
    },
    reset: function reset(t) {
      var e = this;
      void 0 !== t && stopAndPrevent(t), this.$emit("reset"), this.$nextTick(function () {
        e.resetValidation(), !0 === e.autofocus && !0 !== e.noResetFocus && e.focus();
      });
    },
    focus: function focus() {
      var t = this.$el.querySelector("[autofocus], [data-autofocus]") || Array.prototype.find.call(this.$el.querySelectorAll("[tabindex]"), function (t) {
        return t.tabIndex > -1;
      });
      null !== t && void 0 !== t && t.focus();
    },
    getValidationComponents: function getValidationComponents() {
      return Array.prototype.map.call(this.$el.getElementsByClassName("q-field"), function (t) {
        return t.__vue__;
      }).filter(function (t) {
        return void 0 !== t && "function" == typeof t.validate;
      });
    }
  },
  render: function render(t) {
    return t("form", {
      staticClass: "q-form",
      on: this.onEvents
    }, slot(this, "default"));
  }
}),
    QHeader = vue_runtime_esm["a" /* default */].extend({
  name: "QHeader",
  mixins: [ListenersMixin],
  inject: {
    layout: {
      default: function _default() {
        console.error("QHeader needs to be child of QLayout");
      }
    }
  },
  props: {
    value: {
      type: Boolean,
      default: !0
    },
    reveal: Boolean,
    revealOffset: {
      type: Number,
      default: 250
    },
    bordered: Boolean,
    elevated: Boolean,
    heightHint: {
      type: [String, Number],
      default: 50
    }
  },
  data: function data() {
    return {
      size: parseInt(this.heightHint, 10),
      revealed: !0
    };
  },
  watch: {
    value: function value(t) {
      this.__update("space", t), this.__updateLocal("revealed", !0), this.layout.__animate();
    },
    offset: function offset(t) {
      this.__update("offset", t);
    },
    reveal: function reveal(t) {
      !1 === t && this.__updateLocal("revealed", this.value);
    },
    revealed: function revealed(t) {
      this.layout.__animate(), this.$emit("reveal", t);
    },
    "layout.scroll": function layoutScroll(t) {
      !0 === this.reveal && this.__updateLocal("revealed", "up" === t.direction || t.position <= this.revealOffset || t.position - t.inflexionPosition < 100);
    }
  },
  computed: {
    fixed: function fixed() {
      return !0 === this.reveal || this.layout.view.indexOf("H") > -1 || !0 === this.layout.container;
    },
    offset: function offset() {
      if (!0 !== this.value) return 0;
      if (!0 === this.fixed) return !0 === this.revealed ? this.size : 0;
      var t = this.size - this.layout.scroll.position;
      return t > 0 ? t : 0;
    },
    hidden: function hidden() {
      return !0 !== this.value || !0 === this.fixed && !0 !== this.revealed;
    },
    revealOnFocus: function revealOnFocus() {
      return !0 === this.value && !0 === this.hidden && !0 === this.reveal;
    },
    classes: function classes() {
      return (!0 === this.fixed ? "fixed" : "absolute") + "-top" + (!0 === this.bordered ? " q-header--bordered" : "") + (!0 === this.hidden ? " q-header--hidden" : "") + (!0 !== this.value ? " q-layout--prevent-focus" : "");
    },
    style: function style() {
      var t = this.layout.rows.top,
          e = {};
      return "l" === t[0] && !0 === this.layout.left.space && (e[!0 === this.$q.lang.rtl ? "right" : "left"] = this.layout.left.size + "px"), "r" === t[2] && !0 === this.layout.right.space && (e[!0 === this.$q.lang.rtl ? "left" : "right"] = this.layout.right.size + "px"), e;
    },
    onEvents: function onEvents() {
      return Object.assign({}, this.qListeners, {
        focusin: this.__onFocusin,
        input: stop
      });
    }
  },
  render: function render(t) {
    var e = uniqueSlot(this, "default", []);
    return !0 === this.elevated && e.push(t("div", {
      staticClass: "q-layout__shadow absolute-full overflow-hidden no-pointer-events"
    })), e.push(t(QResizeObserver, {
      props: {
        debounce: 0
      },
      on: cache(this, "resize", {
        resize: this.__onResize
      })
    })), t("header", {
      staticClass: "q-header q-layout__section--marginal",
      class: this.classes,
      style: this.style,
      on: this.onEvents
    }, e);
  },
  created: function created() {
    this.layout.instances.header = this, !0 === this.value && this.__update("size", this.size), this.__update("space", this.value), this.__update("offset", this.offset);
  },
  beforeDestroy: function beforeDestroy() {
    this.layout.instances.header === this && (this.layout.instances.header = void 0, this.__update("size", 0), this.__update("offset", 0), this.__update("space", !1));
  },
  methods: {
    __onResize: function __onResize(t) {
      var e = t.height;
      this.__updateLocal("size", e), this.__update("size", e);
    },
    __update: function __update(t, e) {
      this.layout.header[t] !== e && (this.layout.header[t] = e);
    },
    __updateLocal: function __updateLocal(t, e) {
      this[t] !== e && (this[t] = e);
    },
    __onFocusin: function __onFocusin(t) {
      !0 === this.revealOnFocus && this.__updateLocal("revealed", !0), this.$emit("focusin", t);
    }
  }
}),
    RatioMixin = {
  props: {
    ratio: [String, Number]
  },
  computed: {
    ratioStyle: function ratioStyle() {
      var t = this.ratio || this.naturalRatio;
      if (void 0 !== t) return {
        paddingBottom: 100 / t + "%"
      };
    }
  }
},
    QImg = vue_runtime_esm["a" /* default */].extend({
  name: "QImg",
  mixins: [ListenersMixin, RatioMixin],
  props: {
    src: String,
    srcset: String,
    sizes: String,
    alt: String,
    width: String,
    height: String,
    placeholderSrc: String,
    basic: Boolean,
    contain: Boolean,
    position: {
      type: String,
      default: "50% 50%"
    },
    transition: {
      type: String,
      default: "fade"
    },
    imgClass: [Array, String, Object],
    imgStyle: Object,
    nativeContextMenu: Boolean,
    noDefaultSpinner: Boolean,
    spinnerColor: String,
    spinnerSize: String
  },
  data: function data() {
    return {
      currentSrc: "",
      image: null,
      isLoading: !!this.src,
      hasError: !1,
      naturalRatio: void 0
    };
  },
  watch: {
    src: function src() {
      this.__load();
    },
    srcset: function srcset(t) {
      this.__updateWatcher(t);
    }
  },
  computed: {
    url: function url() {
      return this.currentSrc || this.placeholderSrc || void 0;
    },
    attrs: function attrs() {
      var t = {
        role: "img"
      };
      return void 0 !== this.alt && (t["aria-label"] = this.alt), t;
    },
    imgContainerStyle: function imgContainerStyle() {
      return Object.assign({
        backgroundSize: !0 === this.contain ? "contain" : "cover",
        backgroundPosition: this.position
      }, this.imgStyle, {
        backgroundImage: 'url("' + this.url + '")'
      });
    },
    style: function style() {
      return {
        width: this.width,
        height: this.height
      };
    },
    classes: function classes() {
      return "q-img overflow-hidden" + (!0 === this.nativeContextMenu ? " q-img--menu" : "");
    }
  },
  methods: {
    __onLoad: function __onLoad(t) {
      this.isLoading = !1, this.hasError = !1, this.__computeRatio(t), this.__updateSrc(), this.__updateWatcher(this.srcset), this.$emit("load", this.currentSrc);
    },
    __onError: function __onError(t) {
      clearTimeout(this.ratioTimer), this.isLoading = !1, this.hasError = !0, this.currentSrc = "", this.$emit("error", t);
    },
    __updateSrc: function __updateSrc() {
      if (void 0 !== this.image && !1 === this.isLoading) {
        var t = this.image.currentSrc || this.image.src;
        this.currentSrc !== t && (this.currentSrc = t);
      }
    },
    __updateWatcher: function __updateWatcher(t) {
      t ? void 0 === this.unwatch && (this.unwatch = this.$watch("$q.screen.width", this.__updateSrc)) : void 0 !== this.unwatch && (this.unwatch(), this.unwatch = void 0);
    },
    __load: function __load() {
      var t = this;
      if (clearTimeout(this.ratioTimer), this.hasError = !1, !this.src) return this.isLoading = !1, this.image = void 0, void (this.currentSrc = "");
      this.isLoading = !0;
      var e = new Image();
      this.image = e, e.onerror = function (i) {
        t.image === e && !0 !== t.destroyed && t.__onError(i);
      }, e.onload = function () {
        !0 !== t.destroyed && t.image === e && (void 0 !== e.decode ? e.decode().catch(function (i) {
          t.image === e && !0 !== t.destroyed && t.__onError(i);
        }).then(function () {
          t.image === e && !0 !== t.destroyed && t.__onLoad(e);
        }) : t.__onLoad(e));
      }, e.src = this.src, this.srcset && (e.srcset = this.srcset), void 0 !== this.sizes ? e.sizes = this.sizes : Object.assign(e, {
        height: this.height,
        width: this.width
      });
    },
    __computeRatio: function __computeRatio(t) {
      var e = this,
          i = t.naturalHeight,
          s = t.naturalWidth;
      i || s ? this.naturalRatio = 0 === i ? 1 : s / i : this.ratioTimer = setTimeout(function () {
        e.image === t && !0 !== e.destroyed && e.__computeRatio(t);
      }, 100);
    },
    __getImage: function __getImage(t) {
      var e = !0 === this.nativeContextMenu ? [t("img", {
        staticClass: "absolute-full fit",
        attrs: {
          src: this.url,
          "aria-hidden": "true"
        }
      })] : void 0,
          i = void 0 !== this.url ? t("div", {
        key: this.url,
        staticClass: "q-img__image absolute-full",
        class: this.imgClass,
        style: this.imgContainerStyle
      }, e) : null;
      return !0 === this.basic ? i : t("transition", {
        props: {
          name: "q-transition--" + this.transition
        }
      }, [i]);
    },
    __getContent: function __getContent(t) {
      var e = slot(this, !0 === this.hasError ? "error" : "default");
      return !0 === this.basic ? t("div", {
        key: "content",
        staticClass: "q-img__content absolute-full"
      }, e) : t("transition", {
        props: {
          name: "q-transition--fade"
        }
      }, [!0 === this.isLoading ? t("div", {
        key: "placeholder",
        staticClass: "q-img__loading absolute-full flex flex-center"
      }, void 0 !== this.$scopedSlots.loading ? this.$scopedSlots.loading() : !1 === this.noDefaultSpinner ? [t(QSpinner, {
        props: {
          color: this.spinnerColor,
          size: this.spinnerSize
        }
      })] : void 0) : t("div", {
        key: "content",
        staticClass: "q-img__content absolute-full"
      }, e)]);
    }
  },
  render: function render(t) {
    return t("div", {
      class: this.classes,
      style: this.style,
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    }, [t("div", {
      style: this.ratioStyle
    }), this.__getImage(t), this.__getContent(t)]);
  },
  beforeMount: function beforeMount() {
    if (void 0 !== this.placeholderSrc && void 0 === this.ratio) {
      var t = new Image();
      t.src = this.placeholderSrc, this.__computeRatio(t);
    }

    !0 === this.isLoading && this.__load();
  },
  beforeDestroy: function beforeDestroy() {
    this.destroyed = !0, clearTimeout(this.ratioTimer), void 0 !== this.unwatch && this.unwatch();
  }
}),
    QInfiniteScroll = vue_runtime_esm["a" /* default */].extend({
  name: "QInfiniteScroll",
  mixins: [ListenersMixin],
  props: {
    offset: {
      type: Number,
      default: 500
    },
    debounce: {
      type: [String, Number],
      default: 100
    },
    scrollTarget: {
      default: void 0
    },
    disable: Boolean,
    reverse: Boolean
  },
  data: function data() {
    return {
      index: 0,
      fetching: !1,
      working: !0
    };
  },
  watch: {
    disable: function disable(t) {
      !0 === t ? this.stop() : this.resume();
    },
    scrollTarget: function scrollTarget() {
      this.updateScrollTarget();
    },
    debounce: function debounce(t) {
      this.__setDebounce(t);
    }
  },
  methods: {
    poll: function poll() {
      if (!0 !== this.disable && !0 !== this.fetching && !1 !== this.working) {
        var t = getScrollHeight(this.scrollContainer),
            e = getScrollPosition(this.scrollContainer),
            i = height(this.scrollContainer);
        !1 === this.reverse ? e + i + this.offset >= t && this.trigger() : e < this.offset && this.trigger();
      }
    },
    trigger: function trigger() {
      var t = this;

      if (!0 !== this.disable && !0 !== this.fetching && !1 !== this.working) {
        this.index++, this.fetching = !0;
        var e = getScrollHeight(this.scrollContainer);
        this.$emit("load", this.index, function (i) {
          !0 === t.working && (t.fetching = !1, t.$nextTick(function () {
            if (!0 === t.reverse) {
              var s = getScrollHeight(t.scrollContainer),
                  n = getScrollPosition(t.scrollContainer),
                  o = s - e;

              _setScrollPosition(t.scrollContainer, n + o);
            }

            !0 === i ? t.stop() : t.$el.closest("body") && t.poll();
          }));
        });
      }
    },
    reset: function reset() {
      this.index = 0;
    },
    resume: function resume() {
      !1 === this.working && (this.working = !0, this.scrollContainer.addEventListener("scroll", this.poll, listenOpts.passive)), this.immediatePoll();
    },
    stop: function stop() {
      !0 === this.working && (this.working = !1, this.fetching = !1, this.scrollContainer.removeEventListener("scroll", this.poll, listenOpts.passive));
    },
    updateScrollTarget: function updateScrollTarget() {
      this.scrollContainer && !0 === this.working && this.scrollContainer.removeEventListener("scroll", this.poll, listenOpts.passive), this.scrollContainer = getScrollTarget(this.$el, this.scrollTarget), !0 === this.working && this.scrollContainer.addEventListener("scroll", this.poll, listenOpts.passive);
    },
    __setDebounce: function __setDebounce(t) {
      t = parseInt(t, 10), this.poll = t <= 0 ? this.immediatePoll : debounce(this.immediatePoll, !0 === isNaN(t) ? 100 : t);
    }
  },
  mounted: function mounted() {
    if (this.immediatePoll = this.poll, this.__setDebounce(this.debounce), this.updateScrollTarget(), this.immediatePoll(), !0 === this.reverse) {
      var t = getScrollHeight(this.scrollContainer),
          e = height(this.scrollContainer);

      _setScrollPosition(this.scrollContainer, t - e);
    }
  },
  beforeDestroy: function beforeDestroy() {
    !0 === this.working && this.scrollContainer.removeEventListener("scroll", this.poll, listenOpts.passive);
  },
  render: function render(t) {
    var e = uniqueSlot(this, "default", []);
    return !0 !== this.disable && !0 === this.working && e[!1 === this.reverse ? "push" : "unshift"](t("div", {
      staticClass: "q-infinite-scroll__loading",
      class: !0 === this.fetching ? "" : "invisible"
    }, slot(this, "loading"))), t("div", {
      staticClass: "q-infinite-scroll",
      on: Object.assign({}, this.qListeners)
    }, e);
  }
}),
    QInnerLoading = vue_runtime_esm["a" /* default */].extend({
  name: "QInnerLoading",
  mixins: [ListenersMixin, DarkMixin, TransitionMixin],
  props: {
    showing: Boolean,
    color: String,
    size: {
      type: [String, Number],
      default: 42
    }
  },
  render: function render(t) {
    var e = !0 === this.showing ? [t("div", {
      staticClass: "q-inner-loading absolute-full column flex-center",
      class: !0 === this.isDark ? "q-inner-loading--dark" : null,
      on: Object.assign({}, this.qListeners)
    }, void 0 !== this.$scopedSlots.default ? this.$scopedSlots.default() : [t(QSpinner, {
      props: {
        size: this.size,
        color: this.color
      }
    })])] : void 0;
    return t("transition", {
      props: {
        name: this.transition,
        appear: !0
      }
    }, e);
  }
}),
    defaultCfg = {
  threshold: 0,
  root: null,
  rootMargin: "0px"
};

function _update(t, e, i) {
  var s,
      n,
      o,
      r = i.modifiers,
      a = i.value;
  e.once = r.once, "function" == typeof a ? (s = a, n = defaultCfg, o = void 0 === e.cfg) : (s = a.handler, n = Object.assign({}, defaultCfg, a.cfg), o = void 0 === e.cfg || !1 === isDeepEqual(e.cfg, n)), e.handler !== s && (e.handler = s), !0 === o && (e.cfg = n, void 0 !== e.observer && e.observer.unobserve(t), e.observer = new IntersectionObserver(function (i) {
    var s = i[0];

    if ("function" == typeof e.handler) {
      if (null === s.rootBounds && (void 0 !== t.__vue__ ? !0 !== t.__vue__._inactive : !0 === document.body.contains(t))) return e.observer.unobserve(t), void e.observer.observe(t);
      (!1 === e.handler(s, e.observer) || !0 === e.once && !0 === s.isIntersecting) && destroy(t);
    }
  }, n), e.observer.observe(t));
}

function destroy(t) {
  var e = t.__qvisible;
  void 0 !== e && (void 0 !== e.observer && e.observer.unobserve(t), delete t.__qvisible);
}

var Intersection = {
  name: "intersection",
  inserted: function inserted(t, e) {
    var i = {};
    _update(t, i, e), t.__qvisible = i;
  },
  update: function update(t, e) {
    var i = t.__qvisible;
    void 0 !== i && _update(t, i, e);
  },
  unbind: destroy
},
    QIntersection = vue_runtime_esm["a" /* default */].extend({
  name: "QIntersection",
  mixins: [TagMixin, ListenersMixin],
  directives: {
    Intersection: Intersection
  },
  props: {
    once: Boolean,
    transition: String,
    ssrPrerender: Boolean,
    margin: String,
    threshold: [Number, Array],
    disable: Boolean
  },
  data: function data() {
    return {
      showing: !0 === onSSR && this.ssrPrerender
    };
  },
  computed: {
    value: function value() {
      return void 0 !== this.margin || void 0 !== this.threshold ? {
        handler: this.__trigger,
        cfg: {
          rootMargin: this.margin,
          threshold: this.threshold
        }
      } : this.__trigger;
    },
    directives: function directives() {
      if (!0 !== this.disable && (!0 !== onSSR || !0 !== this.once || !0 !== this.ssrPrerender)) return [{
        name: "intersection",
        value: this.value,
        modifiers: {
          once: this.once
        }
      }];
    }
  },
  methods: {
    __trigger: function __trigger(t) {
      this.showing !== t.isIntersecting && (this.showing = t.isIntersecting, void 0 !== this.qListeners.visibility && this.$emit("visibility", this.showing));
    }
  },
  render: function render(t) {
    var e = !0 === this.showing ? [t("div", {
      key: "content"
    }, slot(this, "default"))] : void 0;
    return t(this.tag, {
      staticClass: "q-intersection",
      on: Object.assign({}, this.qListeners),
      directives: this.directives
    }, this.transition ? [t("transition", {
      props: {
        name: "q-transition--" + this.transition
      }
    }, e)] : e);
  }
}),
    keyCodes$1 = [34, 37, 40, 33, 39, 38],
    QKnob = vue_runtime_esm["a" /* default */].extend({
  name: "QKnob",
  mixins: [{
    props: QCircularProgress.options.props
  }, FormMixin],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    step: {
      type: Number,
      default: 1,
      validator: function validator(t) {
        return t >= 0;
      }
    },
    tabindex: {
      type: [Number, String],
      default: 0
    },
    disable: Boolean,
    readonly: Boolean
  },
  data: function data() {
    return {
      model: this.value,
      dragging: !1
    };
  },
  watch: {
    value: function value(t) {
      if (t < this.min) this.model = this.min;else {
        if (!(t > this.max)) return void (t !== this.model && (this.model = t));
        this.model = this.max;
      }
      this.model !== this.value && (this.$emit("input", this.model), this.$emit("change", this.model));
    }
  },
  computed: {
    classes: function classes() {
      return "q-knob non-selectable" + (!0 === this.editable ? " q-knob--editable" : !0 === this.disable ? " disabled" : "");
    },
    editable: function editable() {
      return !1 === this.disable && !1 === this.readonly;
    },
    decimals: function decimals() {
      return (String(this.step).trim("0").split(".")[1] || "").length;
    },
    computedStep: function computedStep() {
      return 0 === this.step ? 1 : this.step;
    },
    computedInstantFeedback: function computedInstantFeedback() {
      return !0 === this.instantFeedback || !0 === this.dragging;
    },
    onEvents: function onEvents() {
      return !0 === this.$q.platform.is.mobile ? {
        click: this.__click
      } : {
        mousedown: this.__activate,
        click: this.__click,
        keydown: this.__keydown,
        keyup: this.__keyup
      };
    },
    attrs: function attrs() {
      var t = {
        role: "slider",
        "aria-valuemin": this.min,
        "aria-valuemax": this.max,
        "aria-valuenow": this.value
      };
      return !0 === this.editable ? t.tabindex = this.tabindex : t["aria-" + (!0 === this.disable ? "disabled" : "readonly")] = "", t;
    }
  },
  methods: {
    __updateCenterPosition: function __updateCenterPosition() {
      var t = this.$el.getBoundingClientRect(),
          e = t.top,
          i = t.left,
          s = t.width,
          n = t.height;
      this.centerPosition = {
        top: e + n / 2,
        left: i + s / 2
      };
    },
    __pan: function __pan(t) {
      t.isFinal ? (this.__updatePosition(t.evt, !0), this.dragging = !1) : t.isFirst ? (this.__updateCenterPosition(), this.dragging = !0, this.__updatePosition(t.evt)) : this.__updatePosition(t.evt);
    },
    __click: function __click(t) {
      this.__updateCenterPosition(), this.__updatePosition(t, !0);
    },
    __keydown: function __keydown(t) {
      if (keyCodes$1.includes(t.keyCode)) {
        stopAndPrevent(t);
        var e = ([34, 33].includes(t.keyCode) ? 10 : 1) * this.computedStep,
            i = [34, 37, 40].includes(t.keyCode) ? -e : e;
        this.model = between(parseFloat((this.model + i).toFixed(this.decimals)), this.min, this.max), this.__updateValue();
      }
    },
    __keyup: function __keyup(t) {
      keyCodes$1.includes(t.keyCode) && this.__updateValue(!0);
    },
    __activate: function __activate(t) {
      this.__updateCenterPosition(), this.__updatePosition(t);
    },
    __updatePosition: function __updatePosition(t, e) {
      var i = this.centerPosition,
          s = position(t),
          n = Math.abs(s.top - i.top),
          o = Math.sqrt(Math.pow(n, 2) + Math.pow(Math.abs(s.left - i.left), 2)),
          r = Math.asin(n / o) * (180 / Math.PI);
      r = s.top < i.top ? i.left < s.left ? 90 - r : 270 + r : i.left < s.left ? r + 90 : 270 - r, this.angle && (r = normalizeToInterval(r - this.angle, 0, 360)), !0 === this.$q.lang.rtl && (r = 360 - r);
      var a = this.min + r / 360 * (this.max - this.min);

      if (0 !== this.step) {
        var l = this.computedStep,
            c = a % l;
        a = a - c + (Math.abs(c) >= l / 2 ? (c < 0 ? -1 : 1) * l : 0), a = parseFloat(a.toFixed(this.decimals));
      }

      a = between(a, this.min, this.max), this.$emit("drag-value", a), this.model !== a && (this.model = a), this.__updateValue(e);
    },
    __updateValue: function __updateValue(t) {
      this.value !== this.model && this.$emit("input", this.model), !0 === t && this.$emit("change", this.model);
    },
    __getNameInput: function __getNameInput() {
      return this.$createElement("input", {
        attrs: this.formAttrs
      });
    }
  },
  render: function render(t) {
    var e = {
      class: this.classes,
      attrs: this.attrs,
      props: Object.assign({}, this.$props, {
        value: this.model,
        instantFeedback: this.computedInstantFeedback
      })
    };
    return !0 === this.editable && (e.on = this.onEvents, e.directives = cache(this, "dir", [{
      name: "touch-pan",
      value: this.__pan,
      modifiers: {
        prevent: !0,
        stop: !0,
        mouse: !0
      }
    }]), void 0 !== this.name && (e.scopedSlots = {
      internal: this.__getNameInput
    })), t(QCircularProgress, e, slot(this, "default"));
  }
}),
    passive$1 = listenOpts.passive,
    QScrollObserver = vue_runtime_esm["a" /* default */].extend({
  name: "QScrollObserver",
  props: {
    debounce: [String, Number],
    horizontal: Boolean,
    scrollTarget: {
      default: void 0
    }
  },
  render: noop,
  data: function data() {
    return {
      pos: 0,
      dir: !0 === this.horizontal ? "right" : "down",
      dirChanged: !1,
      dirChangePos: 0
    };
  },
  watch: {
    scrollTarget: function scrollTarget() {
      this.__unconfigureScrollTarget(), this.__configureScrollTarget();
    }
  },
  methods: {
    getPosition: function getPosition() {
      return {
        position: this.pos,
        direction: this.dir,
        directionChanged: this.dirChanged,
        inflexionPosition: this.dirChangePos
      };
    },
    trigger: function trigger(t) {
      !0 === t || 0 === this.debounce || "0" === this.debounce ? this.__emit() : this.timer || (this.timer = this.debounce ? setTimeout(this.__emit, this.debounce) : requestAnimationFrame(this.__emit));
    },
    __emit: function __emit() {
      var t = !0 === this.horizontal ? getHorizontalScrollPosition : getScrollPosition,
          e = Math.max(0, t(this.__scrollTarget)),
          i = e - this.pos,
          s = !0 === this.horizontal ? i < 0 ? "left" : "right" : i < 0 ? "up" : "down";
      this.dirChanged = this.dir !== s, this.dirChanged && (this.dir = s, this.dirChangePos = this.pos), this.timer = null, this.pos = e, this.$emit("scroll", this.getPosition());
    },
    __configureScrollTarget: function __configureScrollTarget() {
      this.__scrollTarget = getScrollTarget(this.$el.parentNode, this.scrollTarget), this.__scrollTarget.addEventListener("scroll", this.trigger, passive$1), this.trigger(!0);
    },
    __unconfigureScrollTarget: function __unconfigureScrollTarget() {
      void 0 !== this.__scrollTarget && (this.__scrollTarget.removeEventListener("scroll", this.trigger, passive$1), this.__scrollTarget = void 0);
    }
  },
  mounted: function mounted() {
    this.__configureScrollTarget();
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.timer), cancelAnimationFrame(this.timer), this.__unconfigureScrollTarget();
  }
}),
    QLayout = vue_runtime_esm["a" /* default */].extend({
  name: "QLayout",
  mixins: [ListenersMixin],
  provide: function provide() {
    return {
      layout: this
    };
  },
  props: {
    container: Boolean,
    view: {
      type: String,
      default: "hhh lpr fff",
      validator: function validator(t) {
        return /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(t.toLowerCase());
      }
    }
  },
  data: function data() {
    return {
      height: this.$q.screen.height,
      width: !0 === this.container ? 0 : this.$q.screen.width,
      containerHeight: 0,
      scrollbarWidth: !0 === onSSR ? 0 : getScrollbarWidth(),
      header: {
        size: 0,
        offset: 0,
        space: !1
      },
      right: {
        size: 300,
        offset: 0,
        space: !1
      },
      footer: {
        size: 0,
        offset: 0,
        space: !1
      },
      left: {
        size: 300,
        offset: 0,
        space: !1
      },
      scroll: {
        position: 0,
        direction: "down"
      }
    };
  },
  computed: {
    rows: function rows() {
      var t = this.view.toLowerCase().split(" ");
      return {
        top: t[0].split(""),
        middle: t[1].split(""),
        bottom: t[2].split("")
      };
    },
    style: function style() {
      return !0 === this.container ? null : {
        minHeight: this.$q.screen.height + "px"
      };
    },
    targetStyle: function targetStyle() {
      var t;
      if (0 !== this.scrollbarWidth) return (t = {})[!0 === this.$q.lang.rtl ? "left" : "right"] = this.scrollbarWidth + "px", t;
    },
    targetChildStyle: function targetChildStyle() {
      var t;
      if (0 !== this.scrollbarWidth) return (t = {})[!0 === this.$q.lang.rtl ? "right" : "left"] = 0, t[!0 === this.$q.lang.rtl ? "left" : "right"] = "-" + this.scrollbarWidth + "px", t.width = "calc(100% + " + this.scrollbarWidth + "px)", t;
    },
    totalWidth: function totalWidth() {
      return this.width + this.scrollbarWidth;
    },
    classes: function classes() {
      return "q-layout q-layout--" + (!0 === this.container ? "containerized" : "standard");
    }
  },
  created: function created() {
    this.instances = {};
  },
  render: function render(t) {
    var e = t("div", {
      class: this.classes,
      style: this.style,
      on: Object.assign({}, this.qListeners)
    }, mergeSlot([t(QScrollObserver, {
      on: cache(this, "scroll", {
        scroll: this.__onPageScroll
      })
    }), t(QResizeObserver, {
      on: cache(this, "resizeOut", {
        resize: this.__onPageResize
      })
    })], this, "default"));
    return !0 === this.container ? t("div", {
      staticClass: "q-layout-container overflow-hidden"
    }, [t(QResizeObserver, {
      on: cache(this, "resizeIn", {
        resize: this.__onContainerResize
      })
    }), t("div", {
      staticClass: "absolute-full",
      style: this.targetStyle
    }, [t("div", {
      staticClass: "scroll",
      style: this.targetChildStyle
    }, [e])])]) : e;
  },
  methods: {
    __animate: function __animate() {
      var t = this;
      void 0 !== this.timer ? clearTimeout(this.timer) : document.body.classList.add("q-body--layout-animate"), this.timer = setTimeout(function () {
        document.body.classList.remove("q-body--layout-animate"), t.timer = void 0;
      }, 150);
    },
    __onPageScroll: function __onPageScroll(t) {
      !0 !== this.container && !0 === document.qScrollPrevented || (this.scroll = t), void 0 !== this.qListeners.scroll && this.$emit("scroll", t);
    },
    __onPageResize: function __onPageResize(t) {
      var e = t.height,
          i = t.width,
          s = !1;
      this.height !== e && (s = !0, this.height = e, void 0 !== this.qListeners["scroll-height"] && this.$emit("scroll-height", e), this.__updateScrollbarWidth()), this.width !== i && (s = !0, this.width = i), !0 === s && void 0 !== this.qListeners.resize && this.$emit("resize", {
        height: e,
        width: i
      });
    },
    __onContainerResize: function __onContainerResize(t) {
      var e = t.height;
      this.containerHeight !== e && (this.containerHeight = e, this.__updateScrollbarWidth());
    },
    __updateScrollbarWidth: function __updateScrollbarWidth() {
      if (!0 === this.container) {
        var t = this.height > this.containerHeight ? getScrollbarWidth() : 0;
        this.scrollbarWidth !== t && (this.scrollbarWidth = t);
      }
    }
  }
}),
    QMarkupTable = vue_runtime_esm["a" /* default */].extend({
  name: "QMarkupTable",
  mixins: [DarkMixin, ListenersMixin],
  props: {
    dense: Boolean,
    flat: Boolean,
    bordered: Boolean,
    square: Boolean,
    separator: {
      type: String,
      default: "horizontal",
      validator: function validator(t) {
        return ["horizontal", "vertical", "cell", "none"].includes(t);
      }
    },
    wrapCells: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-table--" + this.separator + "-separator" + (!0 === this.isDark ? " q-table--dark q-table__card--dark q-dark" : "") + (!0 === this.dense ? " q-table--dense" : "") + (!0 === this.flat ? " q-table--flat" : "") + (!0 === this.bordered ? " q-table--bordered" : "") + (!0 === this.square ? " q-table--square" : "") + (!1 === this.wrapCells ? " q-table--no-wrap" : "");
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-markup-table q-table__container q-table__card",
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, [t("table", {
      staticClass: "q-table"
    }, slot(this, "default"))]);
  }
}),
    QNoSsr = vue_runtime_esm["a" /* default */].extend({
  name: "QNoSsr",
  mixins: [CanRenderMixin, TagMixin, ListenersMixin],
  props: {
    placeholder: String
  },
  render: function render(t) {
    var e = {
      on: Object.assign({}, this.qListeners)
    };

    if (!0 === this.canRender) {
      var i = slot(this, "default");
      return void 0 === i ? i : i.length > 1 ? t(this.tag, e, i) : i[0];
    }

    e.staticClass = "q-no-ssr-placeholder";
    var s = slot(this, "placeholder");
    return void 0 !== s ? s.length > 1 ? t(this.tag, e, s) : s[0] : void 0 !== this.placeholder ? t(this.tag, e, [this.placeholder]) : void 0;
  }
}),
    QRadio = vue_runtime_esm["a" /* default */].extend({
  name: "QRadio",
  mixins: [DarkMixin, OptionSizeMixin, FormMixin, RefocusTargetMixin],
  props: {
    value: {
      required: !0
    },
    val: {
      required: !0
    },
    label: String,
    leftLabel: Boolean,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  computed: {
    isTrue: function isTrue() {
      return this.value === this.val;
    },
    classes: function classes() {
      return "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (!0 === this.disable ? " disabled" : "") + (!0 === this.isDark ? " q-radio--dark" : "") + (!0 === this.dense ? " q-radio--dense" : "") + (!0 === this.leftLabel ? " reverse" : "");
    },
    innerClass: function innerClass() {
      var t = void 0 === this.color || !0 !== this.keepColor && !0 !== this.isTrue ? "" : " text-" + this.color;
      return "q-radio__inner--" + (!0 === this.isTrue ? "truthy" : "falsy") + t;
    },
    computedTabindex: function computedTabindex() {
      return !0 === this.disable ? -1 : this.tabindex || 0;
    },
    formAttrs: function formAttrs() {
      var t = {
        type: "radio"
      };
      return void 0 !== this.name && Object.assign(t, {
        name: this.name,
        value: this.val
      }), t;
    },
    formDomProps: function formDomProps() {
      if (void 0 !== this.name && !0 === this.isTrue) return {
        checked: !0
      };
    },
    attrs: function attrs() {
      var t = {
        tabindex: this.computedTabindex,
        role: "radio",
        "aria-label": this.label,
        "aria-checked": !0 === this.isTrue ? "true" : "false"
      };
      return !0 === this.disable && (t["aria-disabled"] = ""), t;
    }
  },
  methods: {
    set: function set(t) {
      void 0 !== t && (stopAndPrevent(t), this.__refocusTarget(t)), !0 !== this.disable && !0 !== this.isTrue && this.$emit("input", this.val, t);
    }
  },
  render: function render(t) {
    var e = this,
        i = [t("svg", {
      staticClass: "q-radio__bg absolute",
      attrs: {
        focusable: "false",
        viewBox: "0 0 24 24"
      }
    }, [t("path", {
      attrs: {
        d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12"
      }
    }), t("path", {
      staticClass: "q-radio__check",
      attrs: {
        d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6"
      }
    })])];
    !0 !== this.disable && this.__injectFormInput(i, "unshift", "q-radio__native q-ma-none q-pa-none invisible");
    var s = [t("div", {
      staticClass: "q-radio__inner relative-position no-pointer-events",
      class: this.innerClass,
      style: this.sizeStyle
    }, i)];
    void 0 !== this.__refocusTargetEl && s.push(this.__refocusTargetEl);
    var n = void 0 !== this.label ? mergeSlot([this.label], this, "default") : slot(this, "default");
    return void 0 !== n && s.push(t("div", {
      staticClass: "q-radio__label q-anchor--skip"
    }, n)), t("div", {
      class: this.classes,
      attrs: this.attrs,
      on: cache(this, "inpExt", {
        click: this.set,
        keydown: function keydown(t) {
          13 !== t.keyCode && 32 !== t.keyCode || stopAndPrevent(t);
        },
        keyup: function keyup(t) {
          13 !== t.keyCode && 32 !== t.keyCode || e.set(t);
        }
      })
    }, s);
  }
}),
    QToggle = vue_runtime_esm["a" /* default */].extend({
  name: "QToggle",
  mixins: [CheckboxMixin],
  props: {
    icon: String,
    checkedIcon: String,
    uncheckedIcon: String,
    indeterminateIcon: String,
    iconColor: String
  },
  computed: {
    computedIcon: function computedIcon() {
      return (!0 === this.isTrue ? this.checkedIcon : !0 === this.isIndeterminate ? this.indeterminateIcon : this.uncheckedIcon) || this.icon;
    },
    computedIconColor: function computedIconColor() {
      if (!0 === this.isTrue) return this.iconColor;
    }
  },
  methods: {
    __getInner: function __getInner(t) {
      return [t("div", {
        staticClass: "q-toggle__track"
      }), t("div", {
        staticClass: "q-toggle__thumb absolute flex flex-center no-wrap"
      }, void 0 !== this.computedIcon ? [t(QIcon, {
        props: {
          name: this.computedIcon,
          color: this.computedIconColor
        }
      })] : void 0)];
    }
  },
  created: function created() {
    this.type = "toggle";
  }
}),
    components = {
  radio: QRadio,
  checkbox: QCheckbox,
  toggle: QToggle
},
    typeValues = Object.keys(components),
    QOptionGroup = vue_runtime_esm["a" /* default */].extend({
  name: "QOptionGroup",
  mixins: [DarkMixin, ListenersMixin],
  props: {
    value: {
      required: !0
    },
    options: {
      type: Array,
      validator: function validator(t) {
        return t.every(function (t) {
          return "value" in t && "label" in t;
        });
      }
    },
    name: String,
    type: {
      default: "radio",
      validator: function validator(t) {
        return typeValues.includes(t);
      }
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  computed: {
    component: function component() {
      return components[this.type];
    },
    model: function model() {
      return Array.isArray(this.value) ? this.value.slice() : this.value;
    },
    classes: function classes() {
      return "q-option-group q-gutter-x-sm" + (!0 === this.inline ? " q-option-group--inline" : "");
    },
    attrs: function attrs() {
      if ("radio" === this.type) {
        var t = {
          role: "radiogroup"
        };
        return !0 === this.disable && (t["aria-disabled"] = ""), t;
      }
    }
  },
  methods: {
    __update: function __update(t) {
      this.$emit("input", t);
    }
  },
  created: function created() {
    var t = Array.isArray(this.value);
    "radio" === this.type ? t && console.error("q-option-group: model should not be array") : !1 === t && console.error("q-option-group: model should be array in your case");
  },
  render: function render(t) {
    var e = this;
    return t("div", {
      class: this.classes,
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    }, this.options.map(function (i) {
      return t("div", [t(e.component, {
        props: {
          value: e.value,
          val: i.value,
          name: e.name || i.name,
          disable: e.disable || i.disable,
          label: i.label,
          leftLabel: e.leftLabel || i.leftLabel,
          color: i.color || e.color,
          checkedIcon: i.checkedIcon,
          uncheckedIcon: i.uncheckedIcon,
          dark: i.dark || e.isDark,
          size: i.size || e.size,
          dense: e.dense,
          keepColor: i.keepColor || e.keepColor
        },
        on: cache(e, "inp", {
          input: e.__update
        })
      })]);
    }));
  }
}),
    QPage = vue_runtime_esm["a" /* default */].extend({
  name: "QPage",
  mixins: [ListenersMixin],
  inject: {
    pageContainer: {
      default: function _default() {
        console.error("QPage needs to be child of QPageContainer");
      }
    },
    layout: {}
  },
  props: {
    padding: Boolean,
    styleFn: Function
  },
  computed: {
    style: function style() {
      var t = (!0 === this.layout.header.space ? this.layout.header.size : 0) + (!0 === this.layout.footer.space ? this.layout.footer.size : 0);

      if ("function" == typeof this.styleFn) {
        var e = !0 === this.layout.container ? this.layout.containerHeight : this.$q.screen.height;
        return this.styleFn(t, e);
      }

      return {
        minHeight: !0 === this.layout.container ? this.layout.containerHeight - t + "px" : 0 === this.$q.screen.height ? "calc(100vh - " + t + "px)" : this.$q.screen.height - t + "px"
      };
    },
    classes: function classes() {
      if (!0 === this.padding) return "q-layout-padding";
    }
  },
  render: function render(t) {
    return t("main", {
      staticClass: "q-page",
      style: this.style,
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QPageContainer = vue_runtime_esm["a" /* default */].extend({
  name: "QPageContainer",
  mixins: [ListenersMixin],
  inject: {
    layout: {
      default: function _default() {
        console.error("QPageContainer needs to be child of QLayout");
      }
    }
  },
  provide: {
    pageContainer: !0
  },
  computed: {
    style: function style() {
      var t = {};
      return !0 === this.layout.header.space && (t.paddingTop = this.layout.header.size + "px"), !0 === this.layout.right.space && (t["padding" + (!0 === this.$q.lang.rtl ? "Left" : "Right")] = this.layout.right.size + "px"), !0 === this.layout.footer.space && (t.paddingBottom = this.layout.footer.size + "px"), !0 === this.layout.left.space && (t["padding" + (!0 === this.$q.lang.rtl ? "Right" : "Left")] = this.layout.left.size + "px"), t;
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-page-container",
      style: this.style,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QPageSticky = vue_runtime_esm["a" /* default */].extend({
  name: "QPageSticky",
  mixins: [ListenersMixin],
  inject: {
    layout: {
      default: function _default() {
        console.error("QPageSticky needs to be child of QLayout");
      }
    }
  },
  props: {
    position: {
      type: String,
      default: "bottom-right",
      validator: function validator(t) {
        return ["top-right", "top-left", "bottom-right", "bottom-left", "top", "right", "bottom", "left"].includes(t);
      }
    },
    offset: {
      type: Array,
      validator: function validator(t) {
        return 2 === t.length;
      }
    },
    expand: Boolean
  },
  computed: {
    attach: function attach() {
      var t = this.position;
      return {
        top: t.indexOf("top") > -1,
        right: t.indexOf("right") > -1,
        bottom: t.indexOf("bottom") > -1,
        left: t.indexOf("left") > -1,
        vertical: "top" === t || "bottom" === t,
        horizontal: "left" === t || "right" === t
      };
    },
    top: function top() {
      return this.layout.header.offset;
    },
    right: function right() {
      return this.layout.right.offset;
    },
    bottom: function bottom() {
      return this.layout.footer.offset;
    },
    left: function left() {
      return this.layout.left.offset;
    },
    style: function style() {
      var t = 0,
          e = 0,
          i = this.attach,
          s = !0 === this.$q.lang.rtl ? -1 : 1;
      !0 === i.top && 0 !== this.top ? e = this.top + "px" : !0 === i.bottom && 0 !== this.bottom && (e = -this.bottom + "px"), !0 === i.left && 0 !== this.left ? t = s * this.left + "px" : !0 === i.right && 0 !== this.right && (t = -s * this.right + "px");
      var n = {
        transform: "translate(" + t + ", " + e + ")"
      };
      return this.offset && (n.margin = this.offset[1] + "px " + this.offset[0] + "px"), !0 === i.vertical ? (0 !== this.left && (n[!0 === this.$q.lang.rtl ? "right" : "left"] = this.left + "px"), 0 !== this.right && (n[!0 === this.$q.lang.rtl ? "left" : "right"] = this.right + "px")) : !0 === i.horizontal && (0 !== this.top && (n.top = this.top + "px"), 0 !== this.bottom && (n.bottom = this.bottom + "px")), n;
    },
    classes: function classes() {
      return "fixed-" + this.position + " q-page-sticky--" + (!0 === this.expand ? "expand" : "shrink");
    }
  },
  render: function render(t) {
    var e = slot(this, "default");
    return t("div", {
      staticClass: "q-page-sticky row flex-center",
      class: this.classes,
      style: this.style,
      on: Object.assign({}, this.qListeners)
    }, !0 === this.expand ? e : [t("div", e)]);
  }
}),
    QPageScroller = vue_runtime_esm["a" /* default */].extend({
  name: "QPageScroller",
  mixins: [QPageSticky],
  props: {
    scrollOffset: {
      type: Number,
      default: 1e3
    },
    reverse: Boolean,
    duration: {
      type: Number,
      default: 300
    },
    offset: {
      default: function _default() {
        return [18, 18];
      }
    }
  },
  inject: {
    layout: {
      default: function _default() {
        console.error("QPageScroller needs to be used within a QLayout");
      }
    }
  },
  data: function data() {
    return {
      showing: this.__isVisible()
    };
  },
  computed: {
    height: function height() {
      return !0 === this.layout.container ? this.layout.containerHeight : this.layout.height;
    },
    onEvents: function onEvents() {
      return Object.assign({}, this.qListeners, {
        click: this.__onClick
      });
    }
  },
  watch: {
    "layout.scroll.position": function layoutScrollPosition() {
      this.__updateVisibility();
    },
    reverse: {
      handler: function handler(t) {
        !0 === t ? void 0 === this.heightWatcher && (this.heightWatcher = this.$watch("height", this.__updateVisibility)) : void 0 !== this.heightWatcher && this.__cleanup();
      },
      immediate: !0
    }
  },
  methods: {
    __isVisible: function __isVisible() {
      return !0 === this.reverse ? this.height - this.layout.scroll.position > this.scrollOffset : this.layout.scroll.position > this.scrollOffset;
    },
    __onClick: function __onClick(t) {
      _setScrollPosition(!0 === this.layout.container ? getScrollTarget(this.$el) : getScrollTarget(this.layout.$el), !0 === this.reverse ? this.layout.height : 0, this.duration), this.$emit("click", t);
    },
    __updateVisibility: function __updateVisibility() {
      var t = this.__isVisible();

      this.showing !== t && (this.showing = t);
    },
    __cleanup: function __cleanup() {
      this.heightWatcher(), this.heightWatcher = void 0;
    }
  },
  render: function render(t) {
    return t("transition", {
      props: {
        name: "q-transition--fade"
      }
    }, !0 === this.showing ? [t("div", {
      staticClass: "q-page-scroller",
      on: this.onEvents
    }, [QPageSticky.options.render.call(this, t)])] : null);
  },
  beforeDestroy: function beforeDestroy() {
    void 0 !== this.heightWatcher && this.__cleanup();
  }
}),
    QPagination = vue_runtime_esm["a" /* default */].extend({
  name: "QPagination",
  mixins: [DarkMixin, ListenersMixin],
  props: {
    value: {
      type: Number,
      required: !0
    },
    min: {
      type: Number,
      default: 1
    },
    max: {
      type: Number,
      required: !0
    },
    color: {
      type: String,
      default: "primary"
    },
    textColor: String,
    inputStyle: [Array, String, Object],
    inputClass: [Array, String, Object],
    size: String,
    disable: Boolean,
    input: Boolean,
    iconPrev: String,
    iconNext: String,
    iconFirst: String,
    iconLast: String,
    toFn: Function,
    boundaryLinks: {
      type: Boolean,
      default: null
    },
    boundaryNumbers: {
      type: Boolean,
      default: null
    },
    directionLinks: {
      type: Boolean,
      default: null
    },
    ellipses: {
      type: Boolean,
      default: null
    },
    maxPages: {
      type: Number,
      default: 0,
      validator: function validator(t) {
        return t >= 0;
      }
    },
    ripple: {
      type: [Boolean, Object],
      default: null
    }
  },
  data: function data() {
    return {
      newPage: null
    };
  },
  watch: {
    min: function min() {
      this.model = this.value;
    },
    max: function max() {
      this.model = this.value;
    }
  },
  computed: {
    model: {
      get: function get() {
        return this.value;
      },
      set: function set(t) {
        if (t = parseInt(t, 10), !this.disable && !isNaN(t) && 0 !== t) {
          var e = between(t, this.min, this.max);
          this.$emit("input", e);
        }
      }
    },
    inputPlaceholder: function inputPlaceholder() {
      return this.model + " / " + this.max;
    },
    __boundaryLinks: function __boundaryLinks() {
      return this.__getBool(this.boundaryLinks, this.input);
    },
    __boundaryNumbers: function __boundaryNumbers() {
      return this.__getBool(this.boundaryNumbers, !this.input);
    },
    __directionLinks: function __directionLinks() {
      return this.__getBool(this.directionLinks, this.input);
    },
    __ellipses: function __ellipses() {
      return this.__getBool(this.ellipses, !this.input);
    },
    icons: function icons() {
      var t = [this.iconFirst || this.$q.iconSet.pagination.first, this.iconPrev || this.$q.iconSet.pagination.prev, this.iconNext || this.$q.iconSet.pagination.next, this.iconLast || this.$q.iconSet.pagination.last];
      return !0 === this.$q.lang.rtl ? t.reverse() : t;
    },
    attrs: function attrs() {
      if (!0 === this.disable) return {
        "aria-disabled": ""
      };
    },
    btnProps: function btnProps() {
      return {
        color: this.color,
        flat: !0,
        size: this.size,
        ripple: null === this.ripple || this.ripple
      };
    }
  },
  methods: {
    set: function set(t) {
      this.model = t;
    },
    setByOffset: function setByOffset(t) {
      this.model = this.model + t;
    },
    __update: function __update() {
      this.model = this.newPage, this.newPage = null;
    },
    __getBool: function __getBool(t, e) {
      return [!0, !1].includes(t) ? t : e;
    },
    __getBtn: function __getBtn(t, e, i, s) {
      var n = this;
      return e.props = Object.assign({}, this.btnProps, i), void 0 !== s && (void 0 !== this.toFn ? e.props.to = this.toFn(s) : e.on = {
        click: function click() {
          return n.set(s);
        }
      }), t(QBtn, e);
    }
  },
  render: function render(t) {
    var e = this,
        i = [],
        s = [],
        n = [];
    if (this.__boundaryLinks && (i.push(this.__getBtn(t, {
      key: "bls"
    }, {
      disable: this.disable || this.value <= this.min,
      icon: this.icons[0]
    }, this.min)), s.unshift(this.__getBtn(t, {
      key: "ble"
    }, {
      disable: this.disable || this.value >= this.max,
      icon: this.icons[3]
    }, this.max))), this.__directionLinks && (i.push(this.__getBtn(t, {
      key: "bdp"
    }, {
      disable: this.disable || this.value <= this.min,
      icon: this.icons[1]
    }, this.value - 1)), s.unshift(this.__getBtn(t, {
      key: "bdn"
    }, {
      disable: this.disable || this.value >= this.max,
      icon: this.icons[2]
    }, this.value + 1))), !0 === this.input) n.push(t(QInput, {
      staticClass: "inline",
      style: {
        width: this.inputPlaceholder.length / 1.5 + "em"
      },
      props: {
        type: "number",
        dense: !0,
        value: this.newPage,
        disable: this.disable,
        dark: this.isDark,
        borderless: !0,
        inputClass: this.inputClass,
        inputStyle: this.inputStyle
      },
      attrs: {
        placeholder: this.inputPlaceholder,
        min: this.min,
        max: this.max
      },
      on: cache(this, "inp", {
        input: function input(t) {
          e.newPage = t;
        },
        keyup: function keyup(t) {
          !0 === isKeyCode(t, 13) && e.__update();
        },
        blur: this.__update
      })
    }));else {
      var o = Math.max(this.maxPages, 1 + (this.__ellipses ? 2 : 0) + (this.__boundaryNumbers ? 2 : 0)),
          r = this.min,
          a = this.max,
          l = !1,
          c = !1,
          u = !1,
          h = !1;
      this.maxPages && o < this.max - this.min + 1 && (o = 1 + 2 * Math.floor(o / 2), r = Math.max(this.min, Math.min(this.max - o + 1, this.value - Math.floor(o / 2))), a = Math.min(this.max, r + o - 1), this.__boundaryNumbers && (u = !0, r += 1), this.__ellipses && r > this.min + (this.__boundaryNumbers ? 1 : 0) && (l = !0, r += 1), this.__boundaryNumbers && (h = !0, a -= 1), this.__ellipses && a < this.max - (this.__boundaryNumbers ? 1 : 0) && (c = !0, a -= 1));
      var d = {
        minWidth: Math.max(2, String(this.max).length) + "em"
      };

      if (u) {
        var p = this.min === this.value;
        i.push(this.__getBtn(t, {
          key: "bns",
          style: d
        }, {
          disable: this.disable,
          flat: !p,
          textColor: p ? this.textColor : null,
          label: this.min
        }, this.min));
      }

      if (h) {
        var f = this.max === this.value;
        s.unshift(this.__getBtn(t, {
          key: "bne",
          style: d
        }, {
          disable: this.disable,
          flat: !f,
          textColor: f ? this.textColor : null,
          label: this.max
        }, this.max));
      }

      l && i.push(this.__getBtn(t, {
        key: "bes",
        style: d
      }, {
        disable: this.disable,
        label: "…",
        ripple: !1
      }, r - 1)), c && s.unshift(this.__getBtn(t, {
        key: "bee",
        style: d
      }, {
        disable: this.disable,
        label: "…",
        ripple: !1
      }, a + 1));

      for (var m = r; m <= a; m++) {
        var v = m === this.value;
        n.push(this.__getBtn(t, {
          key: "bpg" + m,
          style: d
        }, {
          disable: this.disable,
          flat: !v,
          textColor: v ? this.textColor : null,
          label: m
        }, m));
      }
    }
    return t("div", {
      staticClass: "q-pagination row no-wrap items-center",
      class: {
        disabled: this.disable
      },
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    }, [i, t("div", {
      staticClass: "row justify-center",
      on: !0 === this.input ? cache(this, "stop", {
        input: stop
      }) : null
    }, [n]), s]);
  }
});

function frameDebounce(t) {
  var e,
      i,
      s = !1;

  function n() {
    var n = this;
    i = arguments, !0 !== s && (s = !0, e = requestAnimationFrame(function () {
      t.apply(n, i), i = void 0, s = !1;
    }));
  }

  return n.cancel = function () {
    window.cancelAnimationFrame(e), s = !1;
  }, n;
}

var QParallax = vue_runtime_esm["a" /* default */].extend({
  name: "QParallax",
  mixins: [ListenersMixin],
  props: {
    src: String,
    height: {
      type: Number,
      default: 500
    },
    speed: {
      type: Number,
      default: 1,
      validator: function validator(t) {
        return t >= 0 && t <= 1;
      }
    },
    scrollTarget: {
      default: void 0
    }
  },
  data: function data() {
    return {
      scrolling: !1,
      percentScrolled: 0
    };
  },
  watch: {
    height: function height() {
      this.__updatePos();
    },
    scrollTarget: function scrollTarget() {
      this.__unconfigureScrollTarget(), this.__configureScrollTarget();
    }
  },
  methods: {
    __update: function __update(t) {
      this.percentScrolled = t, void 0 !== this.qListeners.scroll && this.$emit("scroll", t);
    },
    __onResize: function __onResize() {
      this.__scrollTarget && (this.mediaHeight = this.media.naturalHeight || this.media.videoHeight || height(this.media), this.__updatePos());
    },
    __updatePos: function __updatePos() {
      var t, e, i, s;

      if (this.__scrollTarget === window ? (t = 0, i = e = window.innerHeight) : i = (t = offset(this.__scrollTarget).top) + (e = height(this.__scrollTarget)), (s = offset(this.$el).top) + this.height > t && s < i) {
        var n = (i - s) / (this.height + e);
        this.__setPos((this.mediaHeight - this.height) * n * this.speed), this.__update(n);
      }
    },
    __setPos: function __setPos(t) {
      this.media.style.transform = "translate3D(-50%," + Math.round(t) + "px, 0)";
    },
    __configureScrollTarget: function __configureScrollTarget() {
      this.__scrollTarget = getScrollTarget(this.$el, this.scrollTarget), this.__scrollTarget.addEventListener("scroll", this.__updatePos, listenOpts.passive), this.__onResize();
    },
    __unconfigureScrollTarget: function __unconfigureScrollTarget() {
      void 0 !== this.__scrollTarget && (this.__scrollTarget.removeEventListener("scroll", this.__updatePos, listenOpts.passive), this.__scrollTarget = void 0);
    }
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-parallax",
      style: {
        height: this.height + "px"
      },
      on: Object.assign({}, this.qListeners)
    }, [t("div", {
      ref: "mediaParent",
      staticClass: "q-parallax__media absolute-full"
    }, void 0 !== this.$scopedSlots.media ? this.$scopedSlots.media() : [t("img", {
      ref: "media",
      attrs: {
        src: this.src
      }
    })]), t("div", {
      staticClass: "q-parallax__content absolute-full column flex-center"
    }, void 0 !== this.$scopedSlots.content ? this.$scopedSlots.content({
      percentScrolled: this.percentScrolled
    }) : slot(this, "default"))]);
  },
  beforeMount: function beforeMount() {
    this.__setPos = frameDebounce(this.__setPos);
  },
  mounted: function mounted() {
    this.__update = frameDebounce(this.__update), this.resizeHandler = frameDebounce(this.__onResize), this.media = void 0 !== this.$scopedSlots.media ? this.$refs.mediaParent.children[0] : this.$refs.media, this.media.onload = this.media.onloadstart = this.media.loadedmetadata = this.__onResize, window.addEventListener("resize", this.resizeHandler, listenOpts.passive), this.__configureScrollTarget();
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener("resize", this.resizeHandler, listenOpts.passive), this.__unconfigureScrollTarget(), this.media.onload = this.media.onloadstart = this.media.loadedmetadata = null;
  }
});

function clone$1(t) {
  var e = JSON.stringify(t);
  if (e) return JSON.parse(e);
}

var QPopupEdit = vue_runtime_esm["a" /* default */].extend({
  name: "QPopupEdit",
  mixins: [AttrsMixin],
  props: {
    value: {
      required: !0
    },
    title: String,
    buttons: Boolean,
    labelSet: String,
    labelCancel: String,
    color: {
      type: String,
      default: "primary"
    },
    validate: {
      type: Function,
      default: function _default() {
        return !0;
      }
    },
    autoSave: Boolean,
    cover: {
      type: Boolean,
      default: !0
    },
    contentClass: String,
    disable: Boolean
  },
  data: function data() {
    return {
      initialValue: ""
    };
  },
  computed: {
    classes: function classes() {
      return "q-popup-edit" + (void 0 !== this.contentClass ? " " + this.contentClass : "");
    },
    defaultSlotScope: function defaultSlotScope() {
      return {
        initialValue: this.initialValue,
        value: this.value,
        emitValue: this.__emitValue,
        validate: this.validate,
        set: this.set,
        cancel: this.cancel
      };
    },
    menuProps: function menuProps() {
      return Object.assign({}, this.qAttrs, {
        cover: this.cover,
        contentClass: this.classes
      });
    }
  },
  methods: {
    set: function set() {
      if (!0 === this.__hasChanged()) {
        if (!1 === this.validate(this.value)) return;
        this.$emit("save", this.value, this.initialValue);
      }

      this.__close();
    },
    cancel: function cancel() {
      !0 === this.__hasChanged() && (this.$emit("input", this.initialValue), this.$emit("cancel", this.value, this.initialValue)), this.__close();
    },
    __hasChanged: function __hasChanged() {
      return !1 === isDeepEqual(this.value, this.initialValue);
    },
    __emitValue: function __emitValue(t) {
      !0 !== this.disable && this.$emit("input", t);
    },
    __close: function __close() {
      this.validated = !0, !0 === this.$refs.menu.showing && this.$refs.menu.hide();
    },
    __reposition: function __reposition() {
      var t = this;
      this.$nextTick(function () {
        t.$refs.menu.updatePosition();
      });
    },
    __getContent: function __getContent(t) {
      var e = slot(this, "title", this.title),
          i = void 0 === this.$scopedSlots.default ? [] : this.$scopedSlots.default(this.defaultSlotScope).slice();
      return e && i.unshift(t("div", {
        staticClass: "q-dialog__title q-mt-sm q-mb-sm"
      }, [e])), !0 === this.buttons && i.push(t("div", {
        staticClass: "q-popup-edit__buttons row justify-center no-wrap"
      }, [t(QBtn, {
        props: {
          flat: !0,
          color: this.color,
          label: this.labelCancel || this.$q.lang.label.cancel
        },
        on: cache(this, "cancel", {
          click: this.cancel
        })
      }), t(QBtn, {
        props: {
          flat: !0,
          color: this.color,
          label: this.labelSet || this.$q.lang.label.set
        },
        on: cache(this, "ok", {
          click: this.set
        })
      })])), i;
    }
  },
  render: function render(t) {
    var e = this;
    if (!0 !== this.disable) return t(QMenu, {
      ref: "menu",
      props: this.menuProps,
      on: cache(this, "menu", {
        "before-show": function beforeShow() {
          e.validated = !1, e.initialValue = clone$1(e.value), e.watcher = e.$watch("value", e.__reposition), e.$emit("before-show");
        },
        show: function show() {
          e.$emit("show");
        },
        "escape-key": this.cancel,
        "before-hide": function beforeHide() {
          e.watcher(), !1 === e.validated && !0 === e.__hasChanged() && (!0 === e.autoSave && !0 === e.validate(e.value) ? e.$emit("save", e.value, e.initialValue) : (e.$emit("cancel", e.value, e.initialValue), e.$emit("input", e.initialValue))), e.$emit("before-hide");
        },
        hide: function hide() {
          e.$emit("hide");
        },
        keyup: function keyup(t) {
          !0 === isKeyCode(t, 13) && e.set();
        }
      })
    }, this.__getContent(t));
  }
}),
    QPopupProxy = vue_runtime_esm["a" /* default */].extend({
  name: "QPopupProxy",
  mixins: [AttrsMixin, ListenersMixin, AnchorMixin],
  props: {
    breakpoint: {
      type: [String, Number],
      default: 450
    }
  },
  data: function data() {
    var t = parseInt(this.breakpoint, 10);
    return {
      type: this.$q.screen.width < t || this.$q.screen.height < t ? "dialog" : "menu"
    };
  },
  computed: {
    parsedBreakpoint: function parsedBreakpoint() {
      return parseInt(this.breakpoint, 10);
    },
    onEvents: function onEvents() {
      return Object.assign({}, this.qListeners, {
        hide: this.__onHide
      });
    }
  },
  watch: {
    "$q.screen.width": function $qScreenWidth(t) {
      !0 !== this.$refs.popup.showing && this.__updateType(t, this.$q.screen.height, this.parsedBreakpoint);
    },
    "$q.screen.height": function $qScreenHeight(t) {
      !0 !== this.$refs.popup.showing && this.__updateType(this.$q.screen.width, t, this.parsedBreakpoint);
    },
    breakpoint: function breakpoint(t) {
      !0 !== this.$refs.popup.showing && this.__updateType(this.$q.screen.width, this.$q.screen.height, parseInt(t, 10));
    }
  },
  methods: {
    toggle: function toggle(t) {
      this.$refs.popup.toggle(t);
    },
    show: function show(t) {
      this.$refs.popup.show(t);
    },
    hide: function hide(t) {
      this.$refs.popup.hide(t);
    },
    __onHide: function __onHide(t) {
      this.__updateType(this.$q.screen.width, this.$q.screen.height, this.parsedBreakpoint), this.$emit("hide", t);
    },
    __updateType: function __updateType(t, e, i) {
      var s = t < i || e < i ? "dialog" : "menu";
      this.type !== s && (this.type = s);
    }
  },
  render: function render(t) {
    var e,
        i = slot(this, "default"),
        s = "menu" === this.type && void 0 !== i && void 0 !== i[0] && void 0 !== i[0].componentOptions && void 0 !== i[0].componentOptions.Ctor && void 0 !== i[0].componentOptions.Ctor.sealedOptions && ["QDate", "QTime", "QCarousel", "QColor"].includes(i[0].componentOptions.Ctor.sealedOptions.name) ? {
      cover: !0,
      maxHeight: "99vh"
    } : {},
        n = {
      ref: "popup",
      props: Object.assign(s, this.qAttrs),
      on: this.onEvents
    };
    return "dialog" === this.type ? e = QDialog : (e = QMenu, n.props.target = this.target, n.props.contextMenu = this.contextMenu, n.props.noParentEvent = !0, n.props.separateClosePopup = !0), t(e, n, i);
  }
});

function width$1(t) {
  return {
    transform: "scale3d(" + t + ",1,1)"
  };
}

var QLinearProgress = vue_runtime_esm["a" /* default */].extend({
  name: "QLinearProgress",
  mixins: [ListenersMixin, DarkMixin, getSizeMixin({
    xs: 2,
    sm: 4,
    md: 6,
    lg: 10,
    xl: 14
  })],
  props: {
    value: {
      type: Number,
      default: 0
    },
    buffer: Number,
    color: String,
    trackColor: String,
    reverse: Boolean,
    stripe: Boolean,
    indeterminate: Boolean,
    query: Boolean,
    rounded: Boolean,
    instantFeedback: Boolean
  },
  computed: {
    motion: function motion() {
      return !0 === this.indeterminate || !0 === this.query;
    },
    classes: function classes() {
      return "q-linear-progress" + (void 0 !== this.color ? " text-" + this.color : "") + (!0 === this.reverse || !0 === this.query ? " q-linear-progress--reverse" : "") + (!0 === this.rounded ? " rounded-borders" : "");
    },
    trackStyle: function trackStyle() {
      return width$1(void 0 !== this.buffer ? this.buffer : 1);
    },
    trackClass: function trackClass() {
      return "q-linear-progress__track--with" + (!0 === this.instantFeedback ? "out" : "") + "-transition q-linear-progress__track--" + (!0 === this.isDark ? "dark" : "light") + (void 0 !== this.trackColor ? " bg-" + this.trackColor : "");
    },
    modelStyle: function modelStyle() {
      return width$1(!0 === this.motion ? 1 : this.value);
    },
    modelClasses: function modelClasses() {
      return "q-linear-progress__model--with" + (!0 === this.instantFeedback ? "out" : "") + "-transition q-linear-progress__model--" + (!0 === this.motion ? "in" : "") + "determinate";
    },
    stripeStyle: function stripeStyle() {
      return {
        width: 100 * this.value + "%"
      };
    },
    attrs: function attrs() {
      return {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 1,
        "aria-valuenow": !0 === this.indeterminate ? void 0 : this.value
      };
    }
  },
  render: function render(t) {
    var e = [t("div", {
      staticClass: "q-linear-progress__track absolute-full",
      style: this.trackStyle,
      class: this.trackClass
    }), t("div", {
      staticClass: "q-linear-progress__model absolute-full",
      style: this.modelStyle,
      class: this.modelClasses
    })];
    return !0 === this.stripe && !1 === this.motion && e.push(t("div", {
      staticClass: "q-linear-progress__stripe absolute-full",
      style: this.stripeStyle
    })), t("div", {
      style: this.sizeStyle,
      class: this.classes,
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    }, mergeSlot(e, this, "default"));
  }
}),
    PULLER_HEIGHT = 40,
    OFFSET_TOP = 20,
    QPullToRefresh = vue_runtime_esm["a" /* default */].extend({
  name: "QPullToRefresh",
  mixins: [ListenersMixin],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    color: String,
    bgColor: String,
    icon: String,
    noMouse: Boolean,
    disable: Boolean,
    scrollTarget: {
      default: void 0
    }
  },
  data: function data() {
    return {
      state: "pull",
      pullRatio: 0,
      pulling: !1,
      pullPosition: -PULLER_HEIGHT,
      animating: !1,
      positionCSS: {}
    };
  },
  computed: {
    style: function style() {
      return {
        opacity: this.pullRatio,
        transform: "translateY(" + this.pullPosition + "px) rotate(" + 360 * this.pullRatio + "deg)"
      };
    },
    classes: function classes() {
      return "q-pull-to-refresh__puller row flex-center" + (!0 === this.animating ? " q-pull-to-refresh__puller--animating" : "") + (void 0 !== this.bgColor ? " bg-" + this.bgColor : "");
    }
  },
  watch: {
    scrollTarget: function scrollTarget() {
      this.updateScrollTarget();
    }
  },
  methods: {
    trigger: function trigger() {
      var t = this;
      this.$emit("refresh", function () {
        t.__animateTo({
          pos: -PULLER_HEIGHT,
          ratio: 0
        }, function () {
          t.state = "pull";
        });
      });
    },
    updateScrollTarget: function updateScrollTarget() {
      this.scrollContainer = getScrollTarget(this.$el, this.scrollTarget);
    },
    __pull: function __pull(t) {
      if (!0 !== t.isFinal) {
        if (!0 === this.animating || "refreshing" === this.state) return !1;

        if (!0 === t.isFirst) {
          if (0 !== getScrollPosition(this.scrollContainer)) return this.pulling && (this.pulling = !1, this.state = "pull", this.__animateTo({
            pos: -PULLER_HEIGHT,
            ratio: 0
          })), !1;
          this.pulling = !0;
          var e = this.$el.getBoundingClientRect(),
              i = e.top,
              s = e.left;
          this.positionCSS = {
            top: i + "px",
            left: s + "px",
            width: window.getComputedStyle(this.$el).getPropertyValue("width")
          };
        }

        prevent(t.evt);
        var n = Math.min(140, Math.max(0, t.distance.y));
        this.pullPosition = n - PULLER_HEIGHT, this.pullRatio = between(n / (OFFSET_TOP + PULLER_HEIGHT), 0, 1);
        var o = this.pullPosition > OFFSET_TOP ? "pulled" : "pull";
        this.state !== o && (this.state = o);
      } else !0 === this.pulling && (this.pulling = !1, "pulled" === this.state ? (this.state = "refreshing", this.__animateTo({
        pos: OFFSET_TOP
      }), this.trigger()) : "pull" === this.state && this.__animateTo({
        pos: -PULLER_HEIGHT,
        ratio: 0
      }));
    },
    __animateTo: function __animateTo(t, e) {
      var i = this,
          s = t.pos,
          n = t.ratio;
      this.animating = !0, this.pullPosition = s, void 0 !== n && (this.pullRatio = n), clearTimeout(this.timer), this.timer = setTimeout(function () {
        i.animating = !1, e && e();
      }, 300);
    }
  },
  mounted: function mounted() {
    this.updateScrollTarget();
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.timer);
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-pull-to-refresh overflow-hidden",
      on: Object.assign({}, this.qListeners),
      directives: !0 === this.disable ? null : cache(this, "dir#" + this.noMouse, [{
        name: "touch-pan",
        modifiers: {
          down: !0,
          mightPrevent: !0,
          mouse: !0 !== this.noMouse
        },
        value: this.__pull
      }])
    }, [t("div", {
      staticClass: "q-pull-to-refresh__content",
      class: !0 === this.pulling ? "no-pointer-events" : ""
    }, slot(this, "default")), t("div", {
      staticClass: "q-pull-to-refresh__puller-container fixed row flex-center no-pointer-events z-top",
      style: this.positionCSS
    }, [t("div", {
      style: this.style,
      class: this.classes
    }, ["refreshing" !== this.state ? t(QIcon, {
      props: {
        name: this.icon || this.$q.iconSet.pullToRefresh.icon,
        color: this.color,
        size: "32px"
      }
    }) : t(QSpinner, {
      props: {
        size: "24px",
        color: this.color
      }
    })])])]);
  }
}),
    dragType = {
  MIN: 0,
  RANGE: 1,
  MAX: 2
},
    QRange = vue_runtime_esm["a" /* default */].extend({
  name: "QRange",
  mixins: [SliderMixin],
  props: {
    value: {
      type: Object,
      default: function _default() {
        return {
          min: null,
          max: null
        };
      },
      validator: function validator(t) {
        return "min" in t && "max" in t;
      }
    },
    name: String,
    dragRange: Boolean,
    dragOnlyRange: Boolean,
    leftLabelColor: String,
    leftLabelTextColor: String,
    rightLabelColor: String,
    rightLabelTextColor: String,
    leftLabelValue: [String, Number],
    rightLabelValue: [String, Number]
  },
  data: function data() {
    return {
      model: {
        min: null === this.value.min ? this.min : this.value.min,
        max: null === this.value.max ? this.max : this.value.max
      },
      curMinRatio: 0,
      curMaxRatio: 0
    };
  },
  watch: {
    "value.min": function valueMin(t) {
      this.model.min = null === t ? this.min : t;
    },
    "value.max": function valueMax(t) {
      this.model.max = null === t ? this.max : t;
    },
    min: function min(t) {
      this.model.min < t && (this.model.min = t), this.model.max < t && (this.model.max = t);
    },
    max: function max(t) {
      this.model.min > t && (this.model.min = t), this.model.max > t && (this.model.max = t);
    }
  },
  computed: {
    ratioMin: function ratioMin() {
      return !0 === this.active ? this.curMinRatio : this.modelMinRatio;
    },
    ratioMax: function ratioMax() {
      return !0 === this.active ? this.curMaxRatio : this.modelMaxRatio;
    },
    modelMinRatio: function modelMinRatio() {
      return (this.model.min - this.min) / (this.max - this.min);
    },
    modelMaxRatio: function modelMaxRatio() {
      return (this.model.max - this.min) / (this.max - this.min);
    },
    trackStyle: function trackStyle() {
      var t;
      return (t = {})[this.positionProp] = 100 * this.ratioMin + "%", t[this.sizeProp] = 100 * (this.ratioMax - this.ratioMin) + "%", t;
    },
    minThumbStyle: function minThumbStyle() {
      var t;
      return (t = {})[this.positionProp] = 100 * this.ratioMin + "%", t["z-index"] = "min" === this.__nextFocus ? 2 : void 0, t;
    },
    maxThumbStyle: function maxThumbStyle() {
      var t;
      return (t = {})[this.positionProp] = 100 * this.ratioMax + "%", t;
    },
    minThumbClass: function minThumbClass() {
      if (!1 === this.preventFocus && "min" === this.focus) return "q-slider--focus";
    },
    maxThumbClass: function maxThumbClass() {
      if (!1 === this.preventFocus && "max" === this.focus) return "q-slider--focus";
    },
    events: function events() {
      var t = this;

      if (!0 === this.editable) {
        if (!0 === this.$q.platform.is.mobile) return {
          click: this.__mobileClick
        };
        var e = {
          mousedown: this.__activate
        };
        return !0 === this.dragOnlyRange && Object.assign(e, {
          focus: function focus() {
            t.__focus("both");
          },
          blur: this.__blur,
          keydown: this.__keydown,
          keyup: this.__keyup
        }), e;
      }
    },
    minEvents: function minEvents() {
      var t = this;
      if (!0 === this.editable && !0 !== this.$q.platform.is.mobile && !0 !== this.dragOnlyRange) return {
        focus: function focus() {
          t.__focus("min");
        },
        blur: this.__blur,
        keydown: this.__keydown,
        keyup: this.__keyup
      };
    },
    maxEvents: function maxEvents() {
      var t = this;
      if (!0 === this.editable && !0 !== this.$q.platform.is.mobile && !0 !== this.dragOnlyRange) return {
        focus: function focus() {
          t.__focus("max");
        },
        blur: this.__blur,
        keydown: this.__keydown,
        keyup: this.__keyup
      };
    },
    minPinClass: function minPinClass() {
      var t = this.leftLabelColor || this.labelColor;
      if (t) return "text-" + t;
    },
    minPinTextClass: function minPinTextClass() {
      var t = this.leftLabelTextColor || this.labelTextColor;
      if (t) return "text-" + t;
    },
    maxPinClass: function maxPinClass() {
      var t = this.rightLabelColor || this.labelColor;
      if (t) return "text-" + t;
    },
    maxPinTextClass: function maxPinTextClass() {
      var t = this.rightLabelTextColor || this.labelTextColor;
      if (t) return "text-" + t;
    },
    minLabel: function minLabel() {
      return void 0 !== this.leftLabelValue ? this.leftLabelValue : this.model.min;
    },
    maxLabel: function maxLabel() {
      return void 0 !== this.rightLabelValue ? this.rightLabelValue : this.model.max;
    },
    minPinStyle: function minPinStyle() {
      var t = !0 === this.reverse ? -this.ratioMin : this.ratioMin - 1;
      return this.__getPinStyle(t, this.ratioMin);
    },
    maxPinStyle: function maxPinStyle() {
      var t = !0 === this.reverse ? -this.ratioMax : this.ratioMax - 1;
      return this.__getPinStyle(t, this.ratioMax);
    },
    formAttrs: function formAttrs() {
      return {
        type: "hidden",
        name: this.name,
        value: this.value.min + "|" + this.value.max
      };
    }
  },
  methods: {
    __updateValue: function __updateValue(t) {
      this.model.min === this.value.min && this.model.max === this.value.max || this.$emit("input", this.model), !0 === t && this.$emit("change", this.model);
    },
    __getDragging: function __getDragging(t) {
      var e,
          i = this.$el.getBoundingClientRect(),
          s = i.left,
          n = i.top,
          o = i.width,
          r = i.height,
          a = !0 === this.dragOnlyRange ? 0 : !0 === this.vertical ? this.$refs.minThumb.offsetHeight / (2 * r) : this.$refs.minThumb.offsetWidth / (2 * o),
          l = this.max - this.min,
          c = {
        left: s,
        top: n,
        width: o,
        height: r,
        valueMin: this.model.min,
        valueMax: this.model.max,
        ratioMin: (this.model.min - this.min) / l,
        ratioMax: (this.model.max - this.min) / l
      },
          u = getRatio(t, c, this.isReversed, this.vertical);
      return !0 !== this.dragOnlyRange && u < c.ratioMin + a ? e = dragType.MIN : !0 === this.dragOnlyRange || u < c.ratioMax - a ? !0 === this.dragRange || !0 === this.dragOnlyRange ? (e = dragType.RANGE, Object.assign(c, {
        offsetRatio: u,
        offsetModel: getModel(u, this.min, this.max, this.step, this.decimals),
        rangeValue: c.valueMax - c.valueMin,
        rangeRatio: c.ratioMax - c.ratioMin
      })) : e = c.ratioMax - u < u - c.ratioMin ? dragType.MAX : dragType.MIN : e = dragType.MAX, c.type = e, this.__nextFocus = void 0, c;
    },
    __updatePosition: function __updatePosition(t, e) {
      void 0 === e && (e = this.dragging);
      var i,
          s = getRatio(t, e, this.isReversed, this.vertical),
          n = getModel(s, this.min, this.max, this.step, this.decimals);

      switch (e.type) {
        case dragType.MIN:
          s <= e.ratioMax ? (i = {
            minR: s,
            maxR: e.ratioMax,
            min: n,
            max: e.valueMax
          }, this.__nextFocus = "min") : (i = {
            minR: e.ratioMax,
            maxR: s,
            min: e.valueMax,
            max: n
          }, this.__nextFocus = "max");
          break;

        case dragType.MAX:
          s >= e.ratioMin ? (i = {
            minR: e.ratioMin,
            maxR: s,
            min: e.valueMin,
            max: n
          }, this.__nextFocus = "max") : (i = {
            minR: s,
            maxR: e.ratioMin,
            min: n,
            max: e.valueMin
          }, this.__nextFocus = "min");
          break;

        case dragType.RANGE:
          var o = s - e.offsetRatio,
              r = between(e.ratioMin + o, 0, 1 - e.rangeRatio),
              a = n - e.offsetModel,
              l = between(e.valueMin + a, this.min, this.max - e.rangeValue);
          i = {
            minR: r,
            maxR: r + e.rangeRatio,
            min: parseFloat(l.toFixed(this.decimals)),
            max: parseFloat((l + e.rangeValue).toFixed(this.decimals))
          };
      }

      if (this.model = {
        min: i.min,
        max: i.max
      }, null !== this.model.min && null !== this.model.max || (this.model.min = i.min || this.min, this.model.max = i.max || this.max), !0 !== this.snap || 0 === this.step) this.curMinRatio = i.minR, this.curMaxRatio = i.maxR;else {
        var c = this.max - this.min;
        this.curMinRatio = (this.model.min - this.min) / c, this.curMaxRatio = (this.model.max - this.min) / c;
      }
    },
    __focus: function __focus(t) {
      this.focus = t;
    },
    __keydown: function __keydown(t) {
      var e;

      if (keyCodes.includes(t.keyCode)) {
        stopAndPrevent(t);
        var i = ([34, 33].includes(t.keyCode) ? 10 : 1) * this.computedStep,
            s = [34, 37, 40].includes(t.keyCode) ? -i : i;

        if (this.dragOnlyRange) {
          var n = this.dragOnlyRange ? this.model.max - this.model.min : 0,
              o = between(parseFloat((this.model.min + s).toFixed(this.decimals)), this.min, this.max - n);
          this.model = {
            min: o,
            max: parseFloat((o + n).toFixed(this.decimals))
          };
        } else {
          if (!1 === this.focus) return;
          var r = this.focus;
          this.model = Object.assign({}, this.model, ((e = {})[r] = between(parseFloat((this.model[r] + s).toFixed(this.decimals)), "min" === r ? this.min : this.model.min, "max" === r ? this.max : this.model.max), e));
        }

        this.__updateValue();
      }
    },
    __getThumb: function __getThumb(t, e) {
      var i = [this.__getThumbSvg(t), t("div", {
        staticClass: "q-slider__focus-ring"
      })];
      return !0 !== this.label && !0 !== this.labelAlways || i.push(t("div", {
        staticClass: "q-slider__pin q-slider__pin" + this.axis + " absolute",
        style: this[e + "PinStyle"].pin,
        class: this[e + "PinClass"]
      }, [t("div", {
        staticClass: "q-slider__pin-text-container q-slider__pin-text-container" + this.axis,
        style: this[e + "PinStyle"].pinTextContainer
      }, [t("span", {
        staticClass: "q-slider__pin-text",
        class: this[e + "PinTextClass"]
      }, [this[e + "Label"]])])]), t("div", {
        staticClass: "q-slider__arrow q-slider__arrow" + this.axis,
        class: this[e + "PinClass"]
      })), t("div", {
        ref: e + "Thumb",
        staticClass: "q-slider__thumb-container q-slider__thumb-container" + this.axis + " absolute non-selectable",
        style: this[e + "ThumbStyle"],
        class: this[e + "ThumbClass"],
        on: this[e + "Events"],
        attrs: {
          tabindex: !0 !== this.dragOnlyRange ? this.computedTabindex : null
        }
      }, i);
    }
  },
  render: function render(t) {
    var e = [t("div", {
      staticClass: "q-slider__track q-slider__track" + this.axis + " absolute",
      style: this.trackStyle
    })];
    !0 === this.markers && e.push(t("div", {
      staticClass: "q-slider__track-markers q-slider__track-markers" + this.axis + " absolute-full fit",
      style: this.markerStyle
    }));
    var i = [t("div", {
      staticClass: "q-slider__track-container q-slider__track-container" + this.axis + " absolute"
    }, e), this.__getThumb(t, "min"), this.__getThumb(t, "max")];
    return void 0 !== this.name && !0 !== this.disable && this.__injectFormInput(i, "push"), t("div", {
      staticClass: null === this.value.min || null === this.value.max ? "q-slider--no-value" : void 0,
      attrs: Object.assign({}, this.attrs, {
        "aria-valuenow": this.value.min + "|" + this.value.max,
        tabindex: !0 === this.dragOnlyRange && !0 !== this.$q.platform.is.mobile ? this.computedTabindex : null
      }),
      class: this.classes,
      on: this.events,
      directives: this.panDirectives
    }, i);
  }
}),
    QRating = vue_runtime_esm["a" /* default */].extend({
  name: "QRating",
  mixins: [SizeMixin, FormMixin, ListenersMixin],
  props: {
    value: {
      type: Number,
      required: !0
    },
    max: {
      type: [String, Number],
      default: 5
    },
    icon: [String, Array],
    iconHalf: [String, Array],
    iconSelected: [String, Array],
    color: [String, Array],
    colorHalf: [String, Array],
    colorSelected: [String, Array],
    noReset: Boolean,
    noDimming: Boolean,
    readonly: Boolean,
    disable: Boolean
  },
  data: function data() {
    return {
      mouseModel: 0
    };
  },
  computed: {
    editable: function editable() {
      return !0 !== this.readonly && !0 !== this.disable;
    },
    classes: function classes() {
      return "q-rating--" + (!0 === this.editable ? "" : "non-") + "editable" + (!0 === this.noDimming ? " q-rating--no-dimming" : "") + (!0 === this.disable ? " disabled" : "") + (void 0 !== this.color && !1 === Array.isArray(this.color) ? " text-" + this.color : "");
    },
    iconData: function iconData() {
      var t = !0 === Array.isArray(this.icon) ? this.icon.length : 0,
          e = !0 === Array.isArray(this.iconSelected) ? this.iconSelected.length : 0,
          i = !0 === Array.isArray(this.iconHalf) ? this.iconHalf.length : 0,
          s = !0 === Array.isArray(this.color) ? this.color.length : 0,
          n = !0 === Array.isArray(this.colorSelected) ? this.colorSelected.length : 0,
          o = !0 === Array.isArray(this.colorHalf) ? this.colorHalf.length : 0;
      return {
        iconLen: t,
        icon: t > 0 ? this.icon[t - 1] : this.icon,
        selIconLen: e,
        selIcon: e > 0 ? this.iconSelected[e - 1] : this.iconSelected,
        halfIconLen: i,
        halfIcon: i > 0 ? this.iconHalf[e - 1] : this.iconHalf,
        colorLen: s,
        color: s > 0 ? this.color[s - 1] : this.color,
        selColorLen: n,
        selColor: n > 0 ? this.colorSelected[n - 1] : this.colorSelected,
        halfColorLen: o,
        halfColor: o > 0 ? this.colorHalf[o - 1] : this.colorHalf
      };
    },
    attrs: function attrs() {
      return !0 === this.disable ? {
        "aria-disabled": ""
      } : !0 === this.readonly ? {
        "aria-readonly": ""
      } : void 0;
    }
  },
  methods: {
    __set: function __set(t) {
      if (!0 === this.editable) {
        var e = between(parseInt(t, 10), 1, parseInt(this.max, 10)),
            i = !0 !== this.noReset && this.value === e ? 0 : e;
        i !== this.value && this.$emit("input", i), this.mouseModel = 0;
      }
    },
    __setHoverValue: function __setHoverValue(t) {
      !0 === this.editable && (this.mouseModel = t);
    },
    __keyup: function __keyup(t, e) {
      switch (t.keyCode) {
        case 13:
        case 32:
          return this.__set(e), stopAndPrevent(t);

        case 37:
        case 40:
          return this.$refs["rt" + (e - 1)] && this.$refs["rt" + (e - 1)].focus(), stopAndPrevent(t);

        case 39:
        case 38:
          return this.$refs["rt" + (e + 1)] && this.$refs["rt" + (e + 1)].focus(), stopAndPrevent(t);
      }
    }
  },
  render: function render(t) {
    for (var e, i = this, s = [], n = !0 === this.editable ? 0 : null, o = this.iconData, r = Math.ceil(this.value), a = void 0 === this.iconHalf || r === this.value ? -1 : r, l = function l(_l) {
      var c = 0 === i.mouseModel && i.value >= _l || i.mouseModel > 0 && i.mouseModel >= _l,
          u = a === _l && i.mouseModel < _l,
          h = i.mouseModel > 0 && (!0 === u ? r : i.value) >= _l && i.mouseModel < _l,
          d = !0 === u ? _l <= o.halfIconLen ? i.iconHalf[_l - 1] : o.halfIcon : void 0 === o.selIcon || !0 !== c && !0 !== h ? _l <= o.iconLen ? i.icon[_l - 1] : o.icon : _l <= o.selIconLen ? i.iconSelected[_l - 1] : o.selIcon,
          p = !0 === u ? _l <= o.halfColorLen ? i.colorHalf[_l - 1] : o.halfColor : void 0 !== o.selColor && !0 === c ? _l <= o.selColorLen ? i.colorSelected[_l - 1] : o.selColor : _l <= o.colorLen ? i.color[_l - 1] : o.color;
      s.push(t(QIcon, {
        key: _l,
        ref: "rt" + _l,
        staticClass: "q-rating__icon",
        class: (e = {
          "q-rating__icon--active": !0 === c || !0 === u,
          "q-rating__icon--exselected": h,
          "q-rating__icon--hovered": i.mouseModel === _l
        }, e["text-" + p] = void 0 !== p, e),
        props: {
          name: d || i.$q.iconSet.rating.icon
        },
        attrs: {
          tabindex: n
        },
        on: cache(i, "i#" + _l, {
          click: function click() {
            i.__set(_l);
          },
          mouseover: function mouseover() {
            i.__setHoverValue(_l);
          },
          mouseout: function mouseout() {
            i.mouseModel = 0;
          },
          focus: function focus() {
            i.__setHoverValue(_l);
          },
          blur: function blur() {
            i.mouseModel = 0;
          },
          keyup: function keyup(t) {
            i.__keyup(t, _l);
          }
        })
      }, slot(i, "tip-" + _l)));
    }, c = 1; c <= i.max; c++) {
      l(c);
    }

    return void 0 !== this.name && !0 !== this.disable && this.__injectFormInput(s, "push"), t("div", {
      staticClass: "q-rating row inline items-center",
      class: this.classes,
      style: this.sizeStyle,
      attrs: this.attrs,
      on: Object.assign({}, this.qListeners)
    }, s);
  }
}),
    QResponsive = vue_runtime_esm["a" /* default */].extend({
  name: "QResponsive",
  mixins: [RatioMixin, ListenersMixin],
  render: function render(t) {
    return t("div", {
      staticClass: "q-responsive",
      on: Object.assign({}, this.qListeners)
    }, [t("div", {
      staticClass: "q-responsive__filler overflow-hidden"
    }, [t("div", {
      style: this.ratioStyle
    })]), t("div", {
      staticClass: "q-responsive__content absolute-full fit"
    }, slot(this, "default"))]);
  }
}),
    QScrollArea = vue_runtime_esm["a" /* default */].extend({
  name: "QScrollArea",
  mixins: [DarkMixin],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    barStyle: [Array, String, Object],
    thumbStyle: Object,
    contentStyle: [Array, String, Object],
    contentActiveStyle: [Array, String, Object],
    delay: {
      type: [String, Number],
      default: 1e3
    },
    visible: {
      type: Boolean,
      default: null
    },
    horizontal: Boolean
  },
  data: function data() {
    return {
      tempShowing: !1,
      panning: !1,
      hover: !1,
      containerWidth: 0,
      containerHeight: 0,
      scrollPosition: 0,
      scrollSize: 0
    };
  },
  computed: {
    classes: function classes() {
      return "q-scrollarea" + (!0 === this.isDark ? " q-scrollarea--dark" : "");
    },
    thumbHidden: function thumbHidden() {
      return !0 !== (null === this.visible ? this.hover : this.visible) && !1 === this.tempShowing && !1 === this.panning || this.scrollSize <= this.containerSize;
    },
    thumbSize: function thumbSize() {
      return Math.round(between(this.containerSize * this.containerSize / this.scrollSize, 50, this.containerSize));
    },
    style: function style() {
      var t = this.scrollPercentage * (this.containerSize - this.thumbSize);
      return Object.assign({}, this.thumbStyle, !0 === this.horizontal ? {
        left: t + "px",
        width: this.thumbSize + "px"
      } : {
        top: t + "px",
        height: this.thumbSize + "px"
      });
    },
    mainStyle: function mainStyle() {
      return !0 === this.thumbHidden ? this.contentStyle : this.contentActiveStyle;
    },
    scrollPercentage: function scrollPercentage() {
      var t = between(this.scrollPosition / (this.scrollSize - this.containerSize), 0, 1);
      return Math.round(1e4 * t) / 1e4;
    },
    containerSize: function containerSize() {
      return this["container" + this.dirProps.suffix];
    },
    dirProps: function dirProps() {
      return !0 === this.horizontal ? {
        prefix: "horizontal",
        suffix: "Width",
        scroll: "scrollLeft",
        classSuffix: "h absolute-bottom",
        dir: "right",
        dist: "x"
      } : {
        prefix: "vertical",
        suffix: "Height",
        scroll: "scrollTop",
        classSuffix: "v absolute-right",
        dir: "down",
        dist: "y"
      };
    },
    thumbClass: function thumbClass() {
      return "q-scrollarea__thumb--" + this.dirProps.classSuffix + (!0 === this.thumbHidden ? " q-scrollarea__thumb--invisible" : "");
    },
    barClass: function barClass() {
      return "q-scrollarea__bar--" + this.dirProps.classSuffix + (!0 === this.thumbHidden ? " q-scrollarea__bar--invisible" : "");
    }
  },
  methods: {
    getScrollTarget: function getScrollTarget() {
      return this.$refs.target;
    },
    getScrollPosition: function getScrollPosition() {
      return this.scrollPosition;
    },
    setScrollPosition: function setScrollPosition(t, e) {
      (!0 === this.horizontal ? setHorizontalScrollPosition : _setScrollPosition)(this.$refs.target, t, e);
    },
    __updateContainer: function __updateContainer(t) {
      var e = t.height,
          i = t.width,
          s = !1;
      this.containerWidth !== i && (this.containerWidth = i, s = !0), this.containerHeight !== e && (this.containerHeight = e, s = !0), !0 === s && this.__startTimer();
    },
    __updateScroll: function __updateScroll(t) {
      this.scrollPosition !== t.position && (this.scrollPosition = t.position, this.__startTimer());
    },
    __updateScrollSize: function __updateScrollSize(t) {
      var e = t.height,
          i = t.width;
      !0 === this.horizontal ? this.scrollSize !== i && (this.scrollSize = i, this.__startTimer()) : this.scrollSize !== e && (this.scrollSize = e, this.__startTimer());
    },
    __panThumb: function __panThumb(t) {
      if (!0 === t.isFirst) {
        if (!0 === this.thumbHidden) return;
        this.refPos = this.scrollPosition, this.panning = !0;
      } else if (!0 !== this.panning) return;

      !0 === t.isFinal && (this.panning = !1);
      var e = (this.scrollSize - this.containerSize) / (this.containerSize - this.thumbSize),
          i = t.distance[this.dirProps.dist],
          s = this.refPos + (t.direction === this.dirProps.dir ? 1 : -1) * i * e;

      this.__setScroll(s);
    },
    __mouseDown: function __mouseDown(t) {
      if (!0 !== this.thumbHidden) {
        var e = t["offset" + (!0 === this.horizontal ? "X" : "Y")] - this.thumbSize / 2;
        this.__setScroll(e / this.containerSize * this.scrollSize), void 0 !== this.$refs.thumb && this.$refs.thumb.dispatchEvent(new MouseEvent(t.type, t));
      }
    },
    __startTimer: function __startTimer() {
      var t = this;
      !0 === this.tempShowing ? clearTimeout(this.timer) : this.tempShowing = !0, this.timer = setTimeout(function () {
        t.tempShowing = !1;
      }, this.delay), this.__emitScroll();
    },
    __setScroll: function __setScroll(t) {
      this.$refs.target[this.dirProps.scroll] = t;
    }
  },
  render: function render(t) {
    var e = this;
    return t("div", {
      class: this.classes,
      on: cache(this, "desk", {
        mouseenter: function mouseenter() {
          e.hover = !0;
        },
        mouseleave: function mouseleave() {
          e.hover = !1;
        }
      })
    }, [t("div", {
      ref: "target",
      staticClass: "scroll relative-position fit hide-scrollbar"
    }, [t("div", {
      staticClass: "absolute",
      style: this.mainStyle,
      class: "full-" + (!0 === this.horizontal ? "height" : "width")
    }, mergeSlot([t(QResizeObserver, {
      on: cache(this, "resizeIn", {
        resize: this.__updateScrollSize
      })
    })], this, "default")), t(QScrollObserver, {
      props: {
        horizontal: this.horizontal
      },
      on: cache(this, "scroll", {
        scroll: this.__updateScroll
      })
    })]), t(QResizeObserver, {
      on: cache(this, "resizeOut", {
        resize: this.__updateContainer
      })
    }), t("div", {
      staticClass: "q-scrollarea__bar",
      style: this.barStyle,
      class: this.barClass,
      on: cache(this, "bar", {
        mousedown: this.__mouseDown
      })
    }), t("div", {
      ref: "thumb",
      staticClass: "q-scrollarea__thumb",
      style: this.style,
      class: this.thumbClass,
      directives: cache(this, "thumb#" + this.horizontal, [{
        name: "touch-pan",
        modifiers: {
          vertical: !0 !== this.horizontal,
          horizontal: this.horizontal,
          prevent: !0,
          mouse: !0,
          mouseAllDir: !0
        },
        value: this.__panThumb
      }])
    })]);
  },
  created: function created() {
    var t = this;
    this.__emitScroll = debounce(function () {
      if (void 0 !== t.$listeners.scroll) {
        var e = {
          ref: t
        },
            i = t.dirProps.prefix;
        e[i + "Position"] = t.scrollPosition, e[i + "Percentage"] = t.scrollPercentage, e[i + "Size"] = t.scrollSize, e[i + "ContainerSize"] = t.containerSize, t.$emit("scroll", e);
      }
    }, 0);
  }
}),
    aggBucketSize = 1e3,
    slice = Array.prototype.slice;

function sumFn(t, e) {
  return t + e;
}

function getScrollDetails(t, e, i, s, n, o, r) {
  var a = t === window ? document.scrollingElement || document.documentElement : t,
      l = !0 === n ? "offsetWidth" : "offsetHeight",
      c = {
    scrollStart: 0,
    scrollViewSize: -o - r,
    scrollMaxSize: 0,
    offsetStart: -o,
    offsetEnd: -r
  };
  if (!0 === n ? (t === window ? (c.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, c.scrollViewSize += window.innerWidth) : (c.scrollStart = a.scrollLeft, c.scrollViewSize += a.clientWidth), c.scrollMaxSize = a.scrollWidth) : (t === window ? (c.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0, c.scrollViewSize += window.innerHeight) : (c.scrollStart = a.scrollTop, c.scrollViewSize += a.clientHeight), c.scrollMaxSize = a.scrollHeight), void 0 !== i) for (var u = i.previousElementSibling; null !== u; u = u.previousElementSibling) {
    c.offsetStart += u[l];
  }
  if (void 0 !== s) for (var h = s.nextElementSibling; null !== h; h = h.nextElementSibling) {
    c.offsetEnd += h[l];
  }

  if (e !== t) {
    var d = a.getBoundingClientRect(),
        p = e.getBoundingClientRect();
    !0 === n ? (c.offsetStart += p.left - d.left, c.offsetEnd -= p.width) : (c.offsetStart += p.top - d.top, c.offsetEnd -= p.height), t !== window && (c.offsetStart += c.scrollStart), c.offsetEnd += c.scrollMaxSize - c.offsetStart;
  }

  return c;
}

function setScroll$1(t, e, i) {
  t === window ? !0 === i ? window.scrollTo(e, window.pageYOffset || window.scrollY || document.body.scrollTop || 0) : window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, e) : t[!0 === i ? "scrollLeft" : "scrollTop"] = e;
}

function sumSize(t, e, i, s) {
  if (i >= s) return 0;
  var n = e.length,
      o = Math.floor(i / aggBucketSize),
      r = Math.floor((s - 1) / aggBucketSize) + 1,
      a = t.slice(o, r).reduce(sumFn, 0);
  return i % aggBucketSize != 0 && (a -= e.slice(o * aggBucketSize, i).reduce(sumFn, 0)), s % aggBucketSize != 0 && s !== n && (a -= e.slice(s, r * aggBucketSize).reduce(sumFn, 0)), a;
}

var commonVirtScrollProps = {
  virtualScrollSliceSize: {
    type: Number,
    default: 30
  },
  virtualScrollItemSize: {
    type: Number,
    default: 24
  },
  virtualScrollStickySizeStart: {
    type: Number,
    default: 0
  },
  virtualScrollStickySizeEnd: {
    type: Number,
    default: 0
  }
},
    commonVirtPropsList = Object.keys(commonVirtScrollProps),
    VirtualScroll = {
  props: Object.assign({}, {
    virtualScrollHorizontal: Boolean
  }, commonVirtScrollProps),
  data: function data() {
    return {
      virtualScrollSliceRange: {
        from: 0,
        to: 0
      }
    };
  },
  watch: {
    virtualScrollHorizontal: function virtualScrollHorizontal() {
      this.__setVirtualScrollSize();
    },
    needsReset: function needsReset() {
      this.reset();
    }
  },
  computed: {
    needsReset: function needsReset() {
      var t = this;
      return ["virtualScrollItemSize", "virtualScrollHorizontal"].map(function (e) {
        return t[e];
      }).join(";");
    }
  },
  methods: {
    reset: function reset() {
      this.__resetVirtualScroll(this.prevToIndex, !0);
    },
    refresh: function refresh(t) {
      this.__resetVirtualScroll(void 0 === t ? this.prevToIndex : t);
    },
    scrollTo: function scrollTo(t) {
      var e = this.__getVirtualScrollTarget();

      void 0 !== e && null !== e && 8 !== e.nodeType && this.__setVirtualScrollSliceRange(e, getScrollDetails(e, this.__getVirtualScrollEl(), this.$refs.before, this.$refs.after, this.virtualScrollHorizontal, this.virtualScrollStickySizeStart, this.virtualScrollStickySizeEnd), Math.min(this.virtualScrollLength - 1, Math.max(0, parseInt(t, 10) || 0)), 0, this.prevToIndex > -1 && t > this.prevToIndex ? "end" : "start");
    },
    __onVirtualScrollEvt: function __onVirtualScrollEvt() {
      var t = this.__getVirtualScrollTarget();

      if (void 0 !== t && null !== t && 8 !== t.nodeType) {
        var e = getScrollDetails(t, this.__getVirtualScrollEl(), this.$refs.before, this.$refs.after, this.virtualScrollHorizontal, this.virtualScrollStickySizeStart, this.virtualScrollStickySizeEnd),
            i = e.scrollMaxSize - Math.max(e.scrollViewSize, e.offsetEnd),
            s = this.virtualScrollLength - 1;
        if (this.prevScrollStart !== e.scrollStart) if (this.prevScrollStart = void 0, this.__updateVirtualScrollSizes(this.virtualScrollSliceRange.from), i > 0 && e.scrollStart >= i) this.__setVirtualScrollSliceRange(t, e, this.virtualScrollLength - 1, e.scrollMaxSize - e.offsetEnd - this.virtualScrollSizesAgg.reduce(sumFn, 0));else {
          for (var n = 0, o = e.scrollStart - e.offsetStart, r = o, a = 0; o >= this.virtualScrollSizesAgg[a] && n < s; a++) {
            o -= this.virtualScrollSizesAgg[a], n += aggBucketSize;
          }

          for (; o > 0 && n < s;) {
            (o -= this.virtualScrollSizes[n]) > -e.scrollViewSize ? (n++, r = o) : r = this.virtualScrollSizes[n] + o;
          }

          this.__setVirtualScrollSliceRange(t, e, n, r);
        }
      }
    },
    __setVirtualScrollSliceRange: function __setVirtualScrollSliceRange(t, e, i, s, n) {
      var o = this,
          r = Math.max(0, Math.ceil(i - (void 0 === n ? 3 : 2) * this.virtualScrollSliceSizeComputed / 6)),
          a = r + this.virtualScrollSliceSizeComputed;
      a > this.virtualScrollLength && (a = this.virtualScrollLength, r = Math.max(0, a - this.virtualScrollSliceSizeComputed));
      var l = r !== this.virtualScrollSliceRange.from || a !== this.virtualScrollSliceRange.to;
      !1 !== l || void 0 !== n ? (!0 === l && (this.virtualScrollSliceRange = {
        from: r,
        to: a
      }, this.virtualScrollPaddingBefore = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, 0, r), this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, a, this.virtualScrollLength)), this.$nextTick(function () {
        !0 === l && o.__updateVirtualScrollSizes(r);
        var a = o.virtualScrollSizes.slice(r, i).reduce(sumFn, e.offsetStart + o.virtualScrollPaddingBefore),
            c = a + o.virtualScrollSizes[i],
            u = a + s;
        void 0 !== n && (u = e.scrollStart < a && c < e.scrollStart + e.scrollViewSize ? e.scrollStart : "end" === n ? c - e.scrollViewSize : a), o.prevScrollStart = u, o.__setScroll(t, u, o.virtualScrollHorizontal), o.__emitScroll(i);
      })) : this.__emitScroll(i);
    },
    __updateVirtualScrollSizes: function __updateVirtualScrollSizes(t) {
      var e = this.$refs.content;
      if (void 0 !== e) for (var i, s, n = slice.call(e.children).filter(function (t) {
        return !1 === t.classList.contains("q-virtual-scroll--skip");
      }), o = n.length, r = !0 === this.virtualScrollHorizontal ? "offsetWidth" : "offsetHeight", a = t, l = 0; l < o;) {
        for (i = n[l][r], l++; l < o && !0 === n[l].classList.contains("q-virtual-scroll--with-prev");) {
          i += n[l][r], l++;
        }

        0 !== (s = i - this.virtualScrollSizes[a]) && (this.virtualScrollSizes[a] += s, this.virtualScrollSizesAgg[Math.floor(a / aggBucketSize)] += s), a++;
      }
    },
    __resetVirtualScroll: function __resetVirtualScroll(t, e) {
      var i = this,
          s = this.virtualScrollItemSize;
      !0 !== e && !1 !== Array.isArray(this.virtualScrollSizes) || (this.virtualScrollSizes = []);
      var n = this.virtualScrollSizes.length;
      this.virtualScrollSizes.length = this.virtualScrollLength;

      for (var o = this.virtualScrollLength - 1; o >= n; o--) {
        this.virtualScrollSizes[o] = s;
      }

      var r = Math.floor((this.virtualScrollLength - 1) / aggBucketSize);
      this.virtualScrollSizesAgg = [];

      for (var a = 0; a <= r; a++) {
        for (var l = 0, c = Math.min((a + 1) * aggBucketSize, this.virtualScrollLength), u = a * aggBucketSize; u < c; u++) {
          l += this.virtualScrollSizes[u];
        }

        this.virtualScrollSizesAgg.push(l);
      }

      this.prevToIndex = -1, this.prevScrollStart = void 0, t >= 0 ? (this.__updateVirtualScrollSizes(this.virtualScrollSliceRange.from), this.$nextTick(function () {
        i.scrollTo(t);
      })) : (this.virtualScrollPaddingBefore = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, 0, this.virtualScrollSliceRange.from), this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, this.virtualScrollSliceRange.to, this.virtualScrollLength), this.__onVirtualScrollEvt());
    },
    __setVirtualScrollSize: function __setVirtualScrollSize() {
      !0 === this.virtualScrollHorizontal ? this.virtualScrollSliceSizeComputed = "undefined" == typeof window ? this.virtualScrollSliceSize : Math.max(this.virtualScrollSliceSize, Math.ceil(window.innerWidth / this.virtualScrollItemSize * 2)) : this.virtualScrollSliceSizeComputed = "undefined" == typeof window ? this.virtualScrollSliceSize : Math.max(this.virtualScrollSliceSize, Math.ceil(window.innerHeight / this.virtualScrollItemSize * 2));
    },
    __padVirtualScroll: function __padVirtualScroll(t, e, i) {
      var s,
          n,
          o,
          r,
          a = !0 === this.virtualScrollHorizontal ? "width" : "height";
      return ["tbody" === e ? t(e, {
        staticClass: "q-virtual-scroll__padding",
        key: "before",
        ref: "before"
      }, [t("tr", [t("td", {
        style: (s = {}, s[a] = this.virtualScrollPaddingBefore + "px", s),
        attrs: {
          colspan: "100%"
        }
      })])]) : t(e, {
        staticClass: "q-virtual-scroll__padding",
        key: "before",
        ref: "before",
        style: (n = {}, n[a] = this.virtualScrollPaddingBefore + "px", n)
      }), t(e, {
        staticClass: "q-virtual-scroll__content",
        key: "content",
        ref: "content"
      }, i), "tbody" === e ? t(e, {
        staticClass: "q-virtual-scroll__padding",
        key: "after",
        ref: "after"
      }, [t("tr", [t("td", {
        style: (o = {}, o[a] = this.virtualScrollPaddingAfter + "px", o),
        attrs: {
          colspan: "100%"
        }
      })])]) : t(e, {
        staticClass: "q-virtual-scroll__padding",
        key: "after",
        ref: "after",
        style: (r = {}, r[a] = this.virtualScrollPaddingAfter + "px", r)
      })];
    },
    __emitScroll: function __emitScroll(t) {
      this.prevToIndex !== t && (void 0 !== this.qListeners["virtual-scroll"] && this.$emit("virtual-scroll", {
        index: t,
        from: this.virtualScrollSliceRange.from,
        to: this.virtualScrollSliceRange.to - 1,
        direction: t < this.prevToIndex ? "decrease" : "increase",
        ref: this
      }), this.prevToIndex = t);
    }
  },
  created: function created() {
    this.__setVirtualScrollSize();
  },
  beforeMount: function beforeMount() {
    this.__onVirtualScrollEvt = debounce(this.__onVirtualScrollEvt, 70), this.__setScroll = frameDebounce(setScroll$1), this.__setVirtualScrollSize();
  }
},
    validateNewValueMode = function validateNewValueMode(t) {
  return ["add", "add-unique", "toggle"].includes(t);
},
    QSelect = vue_runtime_esm["a" /* default */].extend({
  name: "QSelect",
  mixins: [QField, VirtualScroll, CompositionMixin, FormFieldMixin, ListenersMixin],
  props: {
    value: {
      required: !0
    },
    multiple: Boolean,
    displayValue: [String, Number],
    displayValueSanitize: Boolean,
    dropdownIcon: String,
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    hideSelected: Boolean,
    hideDropdownIcon: Boolean,
    fillInput: Boolean,
    maxValues: [Number, String],
    optionsDense: Boolean,
    optionsDark: {
      type: Boolean,
      default: null
    },
    optionsSelectedClass: String,
    optionsSanitize: Boolean,
    optionsCover: Boolean,
    menuShrink: Boolean,
    menuAnchor: String,
    menuSelf: String,
    menuOffset: Array,
    popupContentClass: String,
    popupContentStyle: [String, Array, Object],
    useInput: Boolean,
    useChips: Boolean,
    newValueMode: {
      type: String,
      validator: validateNewValueMode
    },
    mapOptions: Boolean,
    emitValue: Boolean,
    inputDebounce: {
      type: [Number, String],
      default: 500
    },
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    transitionShow: String,
    transitionHide: String,
    behavior: {
      type: String,
      validator: function validator(t) {
        return ["default", "menu", "dialog"].includes(t);
      },
      default: "default"
    }
  },
  data: function data() {
    return {
      menu: !1,
      dialog: !1,
      optionIndex: -1,
      inputValue: "",
      dialogFieldFocused: !1
    };
  },
  watch: {
    innerValue: {
      handler: function handler(t) {
        this.innerValueCache = t, !0 === this.useInput && !0 === this.fillInput && !0 !== this.multiple && !0 !== this.innerLoading && (!0 !== this.dialog && !0 !== this.menu || !0 !== this.hasValue) && (!0 !== this.userInputValue && this.__resetInputValue(), !0 !== this.dialog && !0 !== this.menu || this.filter(""));
      },
      immediate: !0
    },
    fillInput: function fillInput() {
      this.__resetInputValue();
    },
    menu: function menu(t) {
      this.__updateMenu(t);
    }
  },
  computed: {
    isOptionsDark: function isOptionsDark() {
      return null === this.optionsDark ? this.isDark : this.optionsDark;
    },
    virtualScrollLength: function virtualScrollLength() {
      return Array.isArray(this.options) ? this.options.length : 0;
    },
    fieldClass: function fieldClass() {
      return "q-select q-field--auto-height q-select--with" + (!0 !== this.useInput ? "out" : "") + "-input q-select--with" + (!0 !== this.useChips ? "out" : "") + "-chips";
    },
    computedInputClass: function computedInputClass() {
      return !0 === this.hideSelected || 0 === this.innerValue.length ? this.inputClass : void 0 === this.inputClass ? "q-field__input--padding" : [this.inputClass, "q-field__input--padding"];
    },
    menuContentClass: function menuContentClass() {
      return (!0 === this.virtualScrollHorizontal ? "q-virtual-scroll--horizontal" : "") + (this.popupContentClass ? " " + this.popupContentClass : "");
    },
    innerValue: function innerValue() {
      var t = this,
          e = !0 === this.mapOptions && !0 !== this.multiple,
          i = void 0 === this.value || null === this.value && !0 !== e ? [] : !0 === this.multiple && Array.isArray(this.value) ? this.value : [this.value];

      if (!0 === this.mapOptions && !0 === Array.isArray(this.options)) {
        var s = !0 === this.mapOptions && void 0 !== this.innerValueCache ? this.innerValueCache : [],
            n = i.map(function (e) {
          return t.__getOption(e, s);
        });
        return null === this.value && !0 === e ? n.filter(function (t) {
          return null !== t;
        }) : n;
      }

      return i;
    },
    noOptions: function noOptions() {
      return 0 === this.virtualScrollLength;
    },
    selectedString: function selectedString() {
      var t = this;
      return this.innerValue.map(function (e) {
        return t.getOptionLabel(e);
      }).join(", ");
    },
    sanitizeFn: function sanitizeFn() {
      return !0 === this.optionsSanitize ? function () {
        return !0;
      } : function (t) {
        return void 0 !== t && null !== t && !0 === t.sanitize;
      };
    },
    displayAsText: function displayAsText() {
      return !0 === this.displayValueSanitize || void 0 === this.displayValue && (!0 === this.optionsSanitize || this.innerValue.some(this.sanitizeFn));
    },
    computedTabindex: function computedTabindex() {
      return !0 === this.focused ? this.tabindex : -1;
    },
    selectedScope: function selectedScope() {
      var t = this;
      return this.innerValue.map(function (e, i) {
        return {
          index: i,
          opt: e,
          sanitize: t.sanitizeFn(e),
          selected: !0,
          removeAtIndex: t.__removeAtIndexAndFocus,
          toggleOption: t.toggleOption,
          tabindex: t.computedTabindex
        };
      });
    },
    optionScope: function optionScope() {
      var t = this;
      if (0 === this.virtualScrollLength) return [];
      var e = this.virtualScrollSliceRange,
          i = e.from,
          s = e.to;
      return this.options.slice(i, s).map(function (e, s) {
        var n = !0 === t.isOptionDisabled(e),
            o = i + s,
            r = {
          clickable: !0,
          active: !1,
          activeClass: t.computedOptionsSelectedClass,
          manualFocus: !0,
          focused: !1,
          disable: n,
          tabindex: -1,
          dense: t.optionsDense,
          dark: t.isOptionsDark
        };
        !0 !== n && (!0 === t.isOptionSelected(e) && (r.active = !0), t.optionIndex === o && (r.focused = !0));
        var a = {
          click: function click() {
            t.toggleOption(e);
          }
        };
        return !0 === t.$q.platform.is.desktop && (a.mousemove = function () {
          t.setOptionIndex(o);
        }), {
          index: o,
          opt: e,
          sanitize: t.sanitizeFn(e),
          selected: r.active,
          focused: r.focused,
          toggleOption: t.toggleOption,
          setOptionIndex: t.setOptionIndex,
          itemProps: r,
          itemEvents: a
        };
      });
    },
    dropdownArrowIcon: function dropdownArrowIcon() {
      return void 0 !== this.dropdownIcon ? this.dropdownIcon : this.$q.iconSet.arrow.dropdown;
    },
    squaredMenu: function squaredMenu() {
      return !1 === this.optionsCover && !0 !== this.outlined && !0 !== this.standout && !0 !== this.borderless && !0 !== this.rounded;
    },
    computedOptionsSelectedClass: function computedOptionsSelectedClass() {
      return void 0 !== this.optionsSelectedClass ? this.optionsSelectedClass : void 0 !== this.color ? "text-" + this.color : "";
    },
    innerOptionsValue: function innerOptionsValue() {
      var t = this;
      return this.innerValue.map(function (e) {
        return t.getOptionValue(e);
      });
    },
    getOptionValue: function getOptionValue() {
      return this.__getPropValueFn("optionValue", "value");
    },
    getOptionLabel: function getOptionLabel() {
      return this.__getPropValueFn("optionLabel", "label");
    },
    isOptionDisabled: function isOptionDisabled() {
      return this.__getPropValueFn("optionDisable", "disable");
    },
    autocompleteControlEvents: function autocompleteControlEvents() {
      var t = this,
          e = {
        keydown: this.__onTargetKeydown,
        keyup: this.__onTargetAutocomplete,
        keypress: this.__onTargetKeypress
      };
      return !0 === this.$q.platform.is.mobile && (e.focus = function (e) {
        !0 === t.dialog && e.target.blur();
      }), e;
    },
    inputControlEvents: function inputControlEvents() {
      var t = {
        input: this.__onInput,
        change: this.__onChange,
        keydown: this.__onTargetKeydown,
        keyup: this.__onTargetKeyup,
        keypress: this.__onTargetKeypress,
        focus: this.__selectInputText
      };
      return t.compositionstart = t.compositionupdate = t.compositionend = this.__onComposition, !0 === this.hasDialog && (t.click = stop), t;
    }
  },
  methods: {
    getEmittingOptionValue: function getEmittingOptionValue(t) {
      return !0 === this.emitValue ? this.getOptionValue(t) : t;
    },
    removeAtIndex: function removeAtIndex(t) {
      if (t > -1 && t < this.innerValue.length) if (!0 === this.multiple) {
        var e = this.value.slice();
        this.$emit("remove", {
          index: t,
          value: e.splice(t, 1)[0]
        }), this.$emit("input", e);
      } else this.$emit("input", null);
    },
    __removeAtIndexAndFocus: function __removeAtIndexAndFocus(t) {
      this.removeAtIndex(t), this.__focus();
    },
    add: function add(t, e) {
      var i = this.getEmittingOptionValue(t);
      if (!0 !== this.multiple) return !0 === this.fillInput && this.updateInputValue(this.getOptionLabel(t), !0, !0), void this.$emit("input", i);
      if (0 === this.innerValue.length) return this.$emit("add", {
        index: 0,
        value: i
      }), void this.$emit("input", !0 === this.multiple ? [i] : i);

      if (!(!0 === e && !0 === this.isOptionSelected(t) || void 0 !== this.maxValues && this.value.length >= this.maxValues)) {
        var s = this.value.slice();
        this.$emit("add", {
          index: s.length,
          value: i
        }), s.push(i), this.$emit("input", s);
      }
    },
    toggleOption: function toggleOption(t, e) {
      if (!0 === this.editable && void 0 !== t && !0 !== this.isOptionDisabled(t)) {
        var i = this.getOptionValue(t);
        if (!0 !== this.multiple) return void 0 !== this.$refs.target && this.$refs.target.focus(), !0 !== e && (this.updateInputValue(!0 === this.fillInput ? this.getOptionLabel(t) : "", !0, !0), this.hidePopup()), void (!0 !== isDeepEqual(this.getOptionValue(this.innerValue[0]), i) && this.$emit("input", !0 === this.emitValue ? i : t));

        if ((!0 !== this.hasDialog || !0 === this.dialogFieldFocused) && this.__focus(), this.__selectInputText(), 0 === this.innerValue.length) {
          var s = !0 === this.emitValue ? i : t;
          return this.$emit("add", {
            index: 0,
            value: s
          }), void this.$emit("input", !0 === this.multiple ? [s] : s);
        }

        var n = this.value.slice(),
            o = this.innerOptionsValue.findIndex(function (t) {
          return isDeepEqual(t, i);
        });
        if (o > -1) this.$emit("remove", {
          index: o,
          value: n.splice(o, 1)[0]
        });else {
          if (void 0 !== this.maxValues && n.length >= this.maxValues) return;
          var r = !0 === this.emitValue ? i : t;
          this.$emit("add", {
            index: n.length,
            value: r
          }), n.push(r);
        }
        this.$emit("input", n);
      }
    },
    setOptionIndex: function setOptionIndex(t) {
      if (!0 === this.$q.platform.is.desktop) {
        var e = t > -1 && t < this.virtualScrollLength ? t : -1;
        this.optionIndex !== e && (this.optionIndex = e);
      }
    },
    moveOptionSelection: function moveOptionSelection(t, e) {
      if (void 0 === t && (t = 1), !0 === this.menu) {
        var i = this.optionIndex;

        do {
          i = normalizeToInterval(i + t, -1, this.virtualScrollLength - 1);
        } while (-1 !== i && i !== this.optionIndex && !0 === this.isOptionDisabled(this.options[i]));

        this.optionIndex !== i && (this.setOptionIndex(i), this.scrollTo(i), !0 !== e && !0 === this.useInput && !0 === this.fillInput && this.__setInputValue(i >= 0 ? this.getOptionLabel(this.options[i]) : this.defaultInputValue));
      }
    },
    __getOption: function __getOption(t, e) {
      var i = this,
          s = function s(e) {
        return isDeepEqual(i.getOptionValue(e), t);
      };

      return this.options.find(s) || e.find(s) || t;
    },
    __getPropValueFn: function __getPropValueFn(t, e) {
      var i = void 0 !== this[t] ? this[t] : e;
      return "function" == typeof i ? i : function (t) {
        return Object(t) === t && i in t ? t[i] : t;
      };
    },
    isOptionSelected: function isOptionSelected(t) {
      var e = this.getOptionValue(t);
      return void 0 !== this.innerOptionsValue.find(function (t) {
        return isDeepEqual(t, e);
      });
    },
    __selectInputText: function __selectInputText() {
      !0 === this.useInput && void 0 !== this.$refs.target && this.$refs.target.select();
    },
    __onTargetKeyup: function __onTargetKeyup(t) {
      !0 === isKeyCode(t, 27) && !0 === this.menu && (stop(t), this.hidePopup(), this.__resetInputValue()), this.$emit("keyup", t);
    },
    __onTargetAutocomplete: function __onTargetAutocomplete(t) {
      var e = this,
          i = t.target.value;

      if (t.target.value = "", void 0 === t.keyCode) {
        if ("string" == typeof i && i.length > 0) {
          var s = i.toLocaleLowerCase(),
              n = function n(t) {
            return e.getOptionValue(t).toLocaleLowerCase() === s;
          },
              o = this.options.find(n);

          null !== o ? -1 === this.innerValue.indexOf(o) && this.toggleOption(o) : (n = function n(t) {
            return e.getOptionLabel(t).toLocaleLowerCase() === s;
          }, null !== (o = this.options.find(n)) && -1 === this.innerValue.indexOf(o) && this.toggleOption(o));
        }
      } else this.__onTargetKeyup(t);
    },
    __onTargetKeypress: function __onTargetKeypress(t) {
      this.$emit("keypress", t);
    },
    __onTargetKeydown: function __onTargetKeydown(t) {
      var e = this;

      if (this.$emit("keydown", t), !0 !== shouldIgnoreKey(t)) {
        var i = this.inputValue.length > 0 && (void 0 !== this.newValueMode || void 0 !== this.qListeners["new-value"]),
            s = !0 !== t.shiftKey && !0 !== this.multiple && (this.optionIndex > -1 || !0 === i);
        if (27 !== t.keyCode) {
          if (9 !== t.keyCode || !1 !== s) {
            if (void 0 !== t.target && t.target.id === this.targetUid) {
              if (40 === t.keyCode && !0 !== this.innerLoading && !1 === this.menu) return stopAndPrevent(t), void this.showPopup();
              if (8 === t.keyCode && !0 === this.multiple && !0 !== this.hideSelected && 0 === this.inputValue.length && Array.isArray(this.value)) this.removeAtIndex(this.value.length - 1);else {
                38 !== t.keyCode && 40 !== t.keyCode || (stopAndPrevent(t), this.moveOptionSelection(38 === t.keyCode ? -1 : 1, this.multiple));
                var n = this.virtualScrollLength;

                if (n > 0 && !0 !== this.useInput && t.keyCode >= 48 && t.keyCode <= 90) {
                  !0 !== this.menu && this.showPopup(t), (void 0 === this.searchBuffer || this.searchBufferExp < Date.now()) && (this.searchBuffer = "");
                  var o = String.fromCharCode(t.keyCode).toLocaleLowerCase(),
                      r = 1 === this.searchBuffer.length && this.searchBuffer[0] === o;
                  this.searchBufferExp = Date.now() + 1500, !1 === r && (this.searchBuffer += o);
                  var a = new RegExp("^" + this.searchBuffer.split("").join(".*"), "i"),
                      l = this.optionIndex;
                  if (!0 === r || !0 !== a.test(this.getOptionLabel(this.options[l]))) do {
                    l = normalizeToInterval(l + 1, -1, n - 1);
                  } while (l !== this.optionIndex && (!0 === this.isOptionDisabled(this.options[l]) || !0 !== a.test(this.getOptionLabel(this.options[l]))));
                  this.optionIndex !== l && this.$nextTick(function () {
                    e.setOptionIndex(l), e.scrollTo(l), l >= 0 && !0 === e.useInput && !0 === e.fillInput && e.__setInputValue(e.getOptionLabel(e.options[l]));
                  });
                } else if (13 === t.keyCode || !0 !== this.useInput && 32 === t.keyCode || !1 !== s && 9 === t.keyCode) if (9 !== t.keyCode && stopAndPrevent(t), this.optionIndex > -1 && this.optionIndex < n) this.toggleOption(this.options[this.optionIndex]);else {
                  if (!0 === i) {
                    var c = function c(t, i) {
                      if (i) {
                        if (!0 !== validateNewValueMode(i)) return;
                      } else i = e.newValueMode;

                      void 0 !== t && null !== t && (e.updateInputValue("", !0 !== e.multiple, !0), e["toggle" === i ? "toggleOption" : "add"](t, "add-unique" === i), !0 !== e.multiple && (void 0 !== e.$refs.target && e.$refs.target.focus(), e.hidePopup()));
                    };

                    if (void 0 !== this.qListeners["new-value"] ? this.$emit("new-value", this.inputValue, c) : c(this.inputValue), !0 !== this.multiple) return;
                  }

                  !0 === this.menu ? this.__closeMenu() : !0 !== this.innerLoading && this.showPopup();
                }
              }
            }
          } else this.__closeMenu();
        } else prevent(t);
      }
    },
    __getVirtualScrollEl: function __getVirtualScrollEl() {
      return !0 === this.hasDialog ? this.$refs.menuContent : void 0 !== this.$refs.menu && void 0 !== this.$refs.menu.__portal ? this.$refs.menu.__portal.$el : void 0;
    },
    __getVirtualScrollTarget: function __getVirtualScrollTarget() {
      return this.__getVirtualScrollEl();
    },
    __getSelection: function __getSelection(t, e) {
      var i,
          s = this;
      return !0 === this.hideSelected ? !0 === e || !0 !== this.dialog || !0 !== this.hasDialog ? [] : [t("span", {
        domProps: {
          textContent: this.inputValue
        }
      })] : void 0 !== this.$scopedSlots["selected-item"] ? this.selectedScope.map(function (t) {
        return s.$scopedSlots["selected-item"](t);
      }).slice() : void 0 !== this.$scopedSlots.selected ? this.$scopedSlots.selected().slice() : !0 === this.useChips ? this.selectedScope.map(function (e, i) {
        var n;
        return t(QChip, {
          key: "option-" + i,
          props: {
            removable: !0 === s.editable && !0 !== s.isOptionDisabled(e.opt),
            dense: !0,
            textColor: s.color,
            tabindex: s.computedTabindex
          },
          on: cache(s, "rem#" + i, {
            remove: function remove() {
              e.removeAtIndex(i);
            }
          })
        }, [t("span", {
          staticClass: "ellipsis",
          domProps: (n = {}, n[!0 === e.sanitize ? "textContent" : "innerHTML"] = s.getOptionLabel(e.opt), n)
        })]);
      }) : [t("span", {
        domProps: (i = {}, i[this.displayAsText ? "textContent" : "innerHTML"] = void 0 !== this.displayValue ? this.displayValue : this.selectedString, i)
      })];
    },
    __getControl: function __getControl(t, e) {
      var i = this.__getSelection(t, e),
          s = !0 === e || !0 !== this.dialog || !0 !== this.hasDialog;

      if (!0 === s && !0 === this.useInput) i.push(this.__getInput(t, e));else if (!0 === this.editable) {
        var n = {
          staticClass: "q-select__autocomplete-input no-outline",
          attrs: {
            autocomplete: this.qAttrs.autocomplete,
            tabindex: this.tabindex
          },
          on: this.autocompleteControlEvents
        };
        !0 === s && (n.ref = "target", n.attrs.id = this.targetUid), i.push(t("input", n));
      }

      if (void 0 !== this.nameProp && !0 !== this.disable && this.innerOptionsValue.length > 0) {
        var o = this.innerOptionsValue.map(function (e) {
          return t("option", {
            attrs: {
              value: e,
              selected: !0
            }
          });
        });
        i.push(t("select", {
          staticClass: "hidden",
          attrs: {
            name: this.nameProp,
            multiple: this.multiple
          }
        }, o));
      }

      return t("div", {
        staticClass: "q-field__native row items-center",
        attrs: this.qAttrs
      }, i);
    },
    __getOptions: function __getOptions(t) {
      var e = this;

      if (!0 === this.menu) {
        var i = void 0 !== this.$scopedSlots.option ? this.$scopedSlots.option : function (i) {
          var s;
          return t(QItem, {
            key: i.index,
            props: i.itemProps,
            on: i.itemEvents
          }, [t(QItemSection, [t(QItemLabel, {
            domProps: (s = {}, s[!0 === i.sanitize ? "textContent" : "innerHTML"] = e.getOptionLabel(i.opt), s)
          })])]);
        },
            s = this.__padVirtualScroll(t, "div", this.optionScope.map(i));

        return void 0 !== this.$scopedSlots["before-options"] && (s = this.$scopedSlots["before-options"]().concat(s)), mergeSlot(s, this, "after-options");
      }
    },
    __getInnerAppend: function __getInnerAppend(t) {
      return !0 !== this.loading && !0 !== this.innerLoading && !0 !== this.hideDropdownIcon ? [t(QIcon, {
        staticClass: "q-select__dropdown-icon",
        props: {
          name: this.dropdownArrowIcon
        }
      })] : null;
    },
    __getInput: function __getInput(t, e) {
      var i = {
        ref: "target",
        staticClass: "q-field__input q-placeholder col",
        style: this.inputStyle,
        class: this.computedInputClass,
        domProps: {
          value: void 0 !== this.inputValue ? this.inputValue : ""
        },
        attrs: Object.assign({}, {
          type: "search"
        }, this.qAttrs, {
          id: this.targetUid,
          maxlength: this.maxlength,
          tabindex: this.tabindex,
          "data-autofocus": !0 !== e && this.autofocus,
          disabled: !0 === this.disable,
          readonly: !0 === this.readonly
        }),
        on: this.inputControlEvents
      };
      return !0 !== e && !0 === this.hasDialog && (i.staticClass += " no-pointer-events", i.attrs.readonly = !0), t("input", i);
    },
    __onChange: function __onChange(t) {
      this.__onComposition(t);
    },
    __onInput: function __onInput(t) {
      var e = this;
      clearTimeout(this.inputTimer), t && t.target && !0 === t.target.composing || (this.__setInputValue(t.target.value || ""), this.userInputValue = !0, this.defaultInputValue = this.inputValue, !0 === this.focused || !0 === this.hasDialog && !0 !== this.dialogFieldFocused || this.__focus(), void 0 !== this.qListeners.filter && (this.inputTimer = setTimeout(function () {
        e.filter(e.inputValue);
      }, this.inputDebounce)));
    },
    __setInputValue: function __setInputValue(t) {
      this.inputValue !== t && (this.inputValue = t, this.$emit("input-value", t));
    },
    updateInputValue: function updateInputValue(t, e, i) {
      this.userInputValue = !0 !== i, !0 === this.useInput && (this.__setInputValue(t), !0 !== e && !0 === i || (this.defaultInputValue = t), !0 !== e && this.filter(t));
    },
    filter: function filter(t) {
      var e = this;

      if (void 0 !== this.qListeners.filter && !0 === this.focused) {
        !0 === this.innerLoading ? this.$emit("filter-abort") : this.innerLoading = !0, "" !== t && !0 !== this.multiple && this.innerValue.length > 0 && !0 !== this.userInputValue && t === this.getOptionLabel(this.innerValue[0]) && (t = "");
        var i = setTimeout(function () {
          !0 === e.menu && (e.menu = !1);
        }, 10);
        clearTimeout(this.filterId), this.filterId = i, this.$emit("filter", t, function (t, s) {
          !0 === e.focused && e.filterId === i && (clearTimeout(e.filterId), "function" == typeof t && t(), e.$nextTick(function () {
            e.innerLoading = !1, !0 === e.menu ? e.__updateMenu(!0) : e.menu = !0, "function" == typeof s && e.$nextTick(function () {
              s(e);
            });
          }));
        }, function () {
          !0 === e.focused && e.filterId === i && (clearTimeout(e.filterId), e.innerLoading = !1), !0 === e.menu && (e.menu = !1);
        });
      }
    },
    __getControlEvents: function __getControlEvents() {
      var t = this,
          e = function e(_e3) {
        t.__onControlFocusout(_e3, function () {
          t.__resetInputValue(), t.__closeMenu();
        });
      };

      return {
        focusin: this.__onControlFocusin,
        focusout: e,
        "popup-show": this.__onControlPopupShow,
        "popup-hide": function popupHide(i) {
          void 0 !== i && stop(i), t.$emit("popup-hide", i), t.hasPopupOpen = !1, e(i);
        },
        click: function click(e) {
          if (!0 !== t.hasDialog) {
            if (!0 === t.useInput && !0 !== e.target.classList.contains("q-field__input") || !0 !== t.useInput && !0 === e.target.classList.contains("no-outline")) return;
            if (!0 === t.menu) return t.__closeMenu(), void (void 0 !== t.$refs.target && t.$refs.target.focus());
          }

          t.showPopup(e);
        }
      };
    },
    __getControlChild: function __getControlChild(t) {
      if (!1 !== this.editable && (!0 === this.dialog || !0 !== this.noOptions || void 0 !== this.$scopedSlots["no-option"])) return this["__get" + (!0 === this.hasDialog ? "Dialog" : "Menu")](t);
    },
    __getMenu: function __getMenu(t) {
      var e = !0 === this.noOptions ? void 0 !== this.$scopedSlots["no-option"] ? this.$scopedSlots["no-option"]({
        inputValue: this.inputValue
      }) : null : this.__getOptions(t);
      return t(QMenu, {
        ref: "menu",
        props: {
          value: this.menu,
          fit: !0 !== this.menuShrink,
          cover: !0 === this.optionsCover && !0 !== this.noOptions && !0 !== this.useInput,
          anchor: this.menuAnchor,
          self: this.menuSelf,
          offset: this.menuOffset,
          contentClass: this.menuContentClass,
          contentStyle: this.popupContentStyle,
          dark: this.isOptionsDark,
          noParentEvent: !0,
          noRefocus: !0,
          noFocus: !0,
          square: this.squaredMenu,
          transitionShow: this.transitionShow,
          transitionHide: this.transitionHide,
          separateClosePopup: !0
        },
        on: cache(this, "menu", {
          "&scroll": this.__onVirtualScrollEvt,
          "before-hide": this.__closeMenu
        })
      }, e);
    },
    __onDialogFieldFocus: function __onDialogFieldFocus(t) {
      stop(t), void 0 !== this.$refs.target && this.$refs.target.focus(), this.dialogFieldFocused = !0, window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
    },
    __onDialogFieldBlur: function __onDialogFieldBlur(t) {
      var e = this;
      stop(t), this.$nextTick(function () {
        e.dialogFieldFocused = !1;
      });
    },
    __getDialog: function __getDialog(t) {
      var e = this,
          i = [t(QField, {
        staticClass: "col-auto " + this.fieldClass,
        props: Object.assign({}, this.$props, {
          for: this.targetUid,
          dark: this.isOptionsDark,
          square: !0,
          loading: this.innerLoading,
          filled: !0,
          stackLabel: this.inputValue.length > 0
        }),
        on: Object.assign({}, this.qListeners, {
          focus: this.__onDialogFieldFocus,
          blur: this.__onDialogFieldBlur
        }),
        scopedSlots: Object.assign({}, this.$scopedSlots, {
          rawControl: function rawControl() {
            return e.__getControl(t, !0);
          },
          before: void 0,
          after: void 0
        })
      })];
      return !0 === this.menu && i.push(t("div", {
        ref: "menuContent",
        staticClass: "scroll",
        class: this.menuContentClass,
        style: this.popupContentStyle,
        on: cache(this, "virtMenu", {
          click: prevent,
          "&scroll": this.__onVirtualScrollEvt
        })
      }, !0 === this.noOptions ? void 0 !== this.$scopedSlots["no-option"] ? this.$scopedSlots["no-option"]({
        inputValue: this.inputValue
      }) : null : this.__getOptions(t))), t(QDialog, {
        ref: "dialog",
        props: {
          value: this.dialog,
          dark: this.isOptionsDark,
          position: !0 === this.useInput ? "top" : void 0,
          transitionShow: this.transitionShowComputed,
          transitionHide: this.transitionHide
        },
        on: cache(this, "dialog", {
          "before-hide": this.__onDialogBeforeHide,
          hide: this.__onDialogHide,
          show: this.__onDialogShow
        })
      }, [t("div", {
        staticClass: "q-select__dialog" + (!0 === this.isOptionsDark ? " q-select__dialog--dark q-dark" : "") + (!0 === this.dialogFieldFocused ? " q-select__dialog--focused" : "")
      }, i)]);
    },
    __onDialogBeforeHide: function __onDialogBeforeHide() {
      this.$refs.dialog.__refocusTarget = this.$el.querySelector(".q-field__native > [tabindex]:last-child"), this.focused = !1;
    },
    __onDialogHide: function __onDialogHide(t) {
      this.hidePopup(), this.$emit("blur", t), this.__resetInputValue();
    },
    __onDialogShow: function __onDialogShow() {
      var t = document.activeElement;
      null !== t && t.id === this.targetUid || this.$refs.target === t || void 0 === this.$refs.target || this.$refs.target.focus();
    },
    __closeMenu: function __closeMenu() {
      !0 !== this.dialog && (this.optionIndex = -1, !0 === this.menu && (this.menu = !1), !1 === this.focused && (clearTimeout(this.filterId), this.filterId = void 0, !0 === this.innerLoading && (this.$emit("filter-abort"), this.innerLoading = !1)));
    },
    showPopup: function showPopup(t) {
      var e = this;
      !0 === this.hasDialog ? (this.__onControlFocusin(t), this.dialog = !0, this.$nextTick(function () {
        e.__focus();
      })) : this.__focus(), void 0 !== this.qListeners.filter ? this.filter(this.inputValue) : !0 === this.noOptions && void 0 === this.$scopedSlots["no-option"] || (this.menu = !0);
    },
    hidePopup: function hidePopup() {
      this.dialog = !1, this.__closeMenu();
    },
    __resetInputValue: function __resetInputValue() {
      !0 === this.useInput && this.updateInputValue(!0 !== this.multiple && !0 === this.fillInput && this.innerValue.length > 0 && this.getOptionLabel(this.innerValue[0]) || "", !0, !0);
    },
    __updateMenu: function __updateMenu(t) {
      var e = this,
          i = -1;

      if (!0 === t) {
        if (this.innerValue.length > 0) {
          var s = this.getOptionValue(this.innerValue[0]);
          i = this.options.findIndex(function (t) {
            return isDeepEqual(e.getOptionValue(t), s);
          });
        }

        this.__resetVirtualScroll(i);
      }

      this.setOptionIndex(i);
    },
    __onPreRender: function __onPreRender() {
      this.hasDialog = (!0 === this.$q.platform.is.mobile || "dialog" === this.behavior) && "menu" !== this.behavior && (!0 !== this.useInput || void 0 !== this.$scopedSlots["no-option"] || void 0 !== this.qListeners.filter || !1 === this.noOptions), this.transitionShowComputed = !0 === this.hasDialog && !0 === this.useInput && !0 === this.$q.platform.is.ios ? "fade" : this.transitionShow;
    },
    __onPostRender: function __onPostRender() {
      !1 === this.dialog && void 0 !== this.$refs.menu && this.$refs.menu.updatePosition();
    },
    updateMenuPosition: function updateMenuPosition() {
      this.__onPostRender();
    }
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.inputTimer);
  }
}),
    skeletonTypes = ["text", "rect", "circle", "QBtn", "QBadge", "QChip", "QToolbar", "QCheckbox", "QRadio", "QToggle", "QSlider", "QRange", "QInput", "QAvatar"],
    skeletonAnimations = ["wave", "pulse", "pulse-x", "pulse-y", "fade", "blink", "none"],
    QSkeleton = vue_runtime_esm["a" /* default */].extend({
  name: "QSkeleton",
  mixins: [DarkMixin, TagMixin, ListenersMixin],
  props: {
    type: {
      type: String,
      validator: function validator(t) {
        return skeletonTypes.includes(t);
      },
      default: "rect"
    },
    animation: {
      type: String,
      validator: function validator(t) {
        return skeletonAnimations.includes(t);
      },
      default: "wave"
    },
    square: Boolean,
    bordered: Boolean,
    size: String,
    width: String,
    height: String
  },
  computed: {
    style: function style() {
      return void 0 !== this.size ? {
        width: this.size,
        height: this.size
      } : {
        width: this.width,
        height: this.height
      };
    },
    classes: function classes() {
      return "q-skeleton--" + (!0 === this.isDark ? "dark" : "light") + " q-skeleton--type-" + this.type + ("none" !== this.animation ? " q-skeleton--anim q-skeleton--anim-" + this.animation : "") + (!0 === this.square ? " q-skeleton--square" : "") + (!0 === this.bordered ? " q-skeleton--bordered" : "");
    }
  },
  render: function render(t) {
    return t(this.tag, {
      staticClass: "q-skeleton",
      class: this.classes,
      style: this.style,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    slotsDef = [["left", "center", "start", "width"], ["right", "center", "end", "width"], ["top", "start", "center", "height"], ["bottom", "end", "center", "height"]],
    QSlideItem = vue_runtime_esm["a" /* default */].extend({
  name: "QSlideItem",
  mixins: [DarkMixin, ListenersMixin],
  props: {
    leftColor: String,
    rightColor: String,
    topColor: String,
    bottomColor: String
  },
  directives: {
    TouchPan: TouchPan
  },
  computed: {
    langDir: function langDir() {
      return !0 === this.$q.lang.rtl ? {
        left: "right",
        right: "left"
      } : {
        left: "left",
        right: "right"
      };
    }
  },
  methods: {
    reset: function reset() {
      this.$refs.content.style.transform = "translate(0,0)";
    },
    __pan: function __pan(t) {
      var e,
          i,
          s,
          n = this,
          o = this.$refs.content;
      if (t.isFirst) this.__dir = null, this.__size = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, this.__scale = 0, o.classList.add("no-transition"), slotsDef.forEach(function (t) {
        if (void 0 !== n.$scopedSlots[t[0]]) {
          var e = n.$refs[t[0] + "Content"];
          e.style.transform = "scale(1)", n.__size[t[0]] = e.getBoundingClientRect()[t[3]];
        }
      }), this.__axis = "up" === t.direction || "down" === t.direction ? "Y" : "X";else {
        if (t.isFinal) return o.classList.remove("no-transition"), void (1 === this.__scale ? (o.style.transform = "translate" + this.__axis + "(" + 100 * this.__dir + "%)", this.timer = setTimeout(function () {
          n.$emit(n.__showing, {
            reset: n.reset
          }), n.$emit("action", {
            side: n.__showing,
            reset: n.reset
          });
        }, 230)) : o.style.transform = "translate(0,0)");
        t.direction = "X" === this.__axis ? t.offset.x < 0 ? "left" : "right" : t.offset.y < 0 ? "up" : "down";
      }
      void 0 === this.$scopedSlots.left && t.direction === this.langDir.right || void 0 === this.$scopedSlots.right && t.direction === this.langDir.left || void 0 === this.$scopedSlots.top && "down" === t.direction || void 0 === this.$scopedSlots.bottom && "up" === t.direction ? o.style.transform = "translate(0,0)" : ("X" === this.__axis ? (i = "left" === t.direction ? -1 : 1, e = 1 === i ? this.langDir.left : this.langDir.right, s = t.distance.x) : (i = "up" === t.direction ? -2 : 2, e = 2 === i ? "top" : "bottom", s = t.distance.y), null !== this.__dir && Math.abs(i) !== Math.abs(this.__dir) || (this.__dir !== i && (["left", "right", "top", "bottom"].forEach(function (t) {
        void 0 !== n.$refs[t] && (n.$refs[t].style.visibility = e === t ? "visible" : "hidden");
      }), this.__showing = e, this.__dir = i), this.__scale = Math.max(0, Math.min(1, (s - 40) / this.__size[e])), o.style.transform = "translate" + this.__axis + "(" + s * i / Math.abs(i) + "px)", this.$refs[e + "Content"].style.transform = "scale(" + this.__scale + ")"));
    }
  },
  render: function render(t) {
    var e = this,
        i = [],
        s = void 0 !== this.$scopedSlots[this.langDir.right],
        n = void 0 !== this.$scopedSlots[this.langDir.left],
        o = void 0 !== this.$scopedSlots.bottom,
        r = void 0 !== this.$scopedSlots.top;
    return slotsDef.forEach(function (s) {
      var n = s[0];
      void 0 !== e.$scopedSlots[n] && i.push(t("div", {
        ref: n,
        class: "q-slide-item__" + n + " absolute-full row no-wrap items-" + s[1] + " justify-" + s[2] + (void 0 !== e[n + "Color"] ? " bg-" + e[n + "Color"] : "")
      }, [t("div", {
        ref: n + "Content"
      }, e.$scopedSlots[n]())]));
    }), i.push(t("div", {
      ref: "content",
      key: "content",
      staticClass: "q-slide-item__content",
      directives: !0 === s || !0 === n || !0 === o || !0 === r ? [{
        name: "touch-pan",
        value: this.__pan,
        modifiers: {
          left: s,
          right: n,
          up: o,
          down: r,
          prevent: !0,
          stop: !0,
          mouse: !0
        }
      }] : null
    }, slot(this, "default"))), t("div", {
      staticClass: "q-slide-item q-item-type overflow-hidden",
      class: !0 === this.isDark ? "q-slide-item--dark q-dark" : "",
      on: Object.assign({}, this.qListeners)
    }, i);
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.timer);
  }
}),
    QSpace = vue_runtime_esm["a" /* default */].extend({
  name: "QSpace",
  mixins: [ListenersMixin],
  render: function render(t) {
    return t("div", {
      staticClass: "q-space",
      on: Object.assign({}, this.qListeners)
    });
  }
}),
    QSpinnerAudio = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerAudio",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        fill: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 55 80",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("g", {
      attrs: {
        transform: "matrix(1 0 0 -1 0 80)"
      }
    }, [t("rect", {
      attrs: {
        width: "10",
        height: "20",
        rx: "3"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0s",
        dur: "4.3s",
        values: "20;45;57;80;64;32;66;45;64;23;66;13;64;56;34;34;2;23;76;79;20",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("rect", {
      attrs: {
        x: "15",
        width: "10",
        height: "80",
        rx: "3"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0s",
        dur: "2s",
        values: "80;55;33;5;75;23;73;33;12;14;60;80",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("rect", {
      attrs: {
        x: "30",
        width: "10",
        height: "50",
        rx: "3"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0s",
        dur: "1.4s",
        values: "50;34;78;23;56;23;34;76;80;54;21;50",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("rect", {
      attrs: {
        x: "45",
        width: "10",
        height: "30",
        rx: "3"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0s",
        dur: "2s",
        values: "30;45;13;80;56;72;45;76;34;23;67;30",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })])])]);
  }
}),
    QSpinnerBall = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerBall",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        stroke: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 57 57",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("g", {
      attrs: {
        transform: "translate(1 1)",
        "stroke-width": "2",
        fill: "none",
        "fill-rule": "evenodd"
      }
    }, [t("circle", {
      attrs: {
        cx: "5",
        cy: "50",
        r: "5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "cy",
        begin: "0s",
        dur: "2.2s",
        values: "50;5;50;50",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "cx",
        begin: "0s",
        dur: "2.2s",
        values: "5;27;49;5",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "27",
        cy: "5",
        r: "5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "cy",
        begin: "0s",
        dur: "2.2s",
        from: "5",
        to: "5",
        values: "5;50;50;5",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "cx",
        begin: "0s",
        dur: "2.2s",
        from: "27",
        to: "27",
        values: "27;49;5;27",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "49",
        cy: "50",
        r: "5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "cy",
        begin: "0s",
        dur: "2.2s",
        values: "50;50;5;50",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "cx",
        from: "49",
        to: "49",
        begin: "0s",
        dur: "2.2s",
        values: "49;5;27;49",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })])])]);
  }
}),
    QSpinnerBars = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerBars",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        fill: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 135 140",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("rect", {
      attrs: {
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0.5s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "y",
        begin: "0.5s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("rect", {
      attrs: {
        x: "30",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0.25s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "y",
        begin: "0.25s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("rect", {
      attrs: {
        x: "60",
        width: "15",
        height: "140",
        rx: "6"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "y",
        begin: "0s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("rect", {
      attrs: {
        x: "90",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0.25s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "y",
        begin: "0.25s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("rect", {
      attrs: {
        x: "120",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        begin: "0.5s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "y",
        begin: "0.5s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })])]);
  }
}),
    QSpinnerComment = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerComment",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid"
      }
    }, [t("rect", {
      attrs: {
        x: "0",
        y: "0",
        width: "100",
        height: "100",
        fill: "none"
      }
    }), t("path", {
      attrs: {
        d: "M78,19H22c-6.6,0-12,5.4-12,12v31c0,6.6,5.4,12,12,12h37.2c0.4,3,1.8,5.6,3.7,7.6c2.4,2.5,5.1,4.1,9.1,4 c-1.4-2.1-2-7.2-2-10.3c0-0.4,0-0.8,0-1.3h8c6.6,0,12-5.4,12-12V31C90,24.4,84.6,19,78,19z",
        fill: "currentColor"
      }
    }), t("circle", {
      attrs: {
        cx: "30",
        cy: "47",
        r: "5",
        fill: "#fff"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "opacity",
        from: "0",
        to: "1",
        values: "0;1;1",
        keyTimes: "0;0.2;1",
        dur: "1s",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "50",
        cy: "47",
        r: "5",
        fill: "#fff"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "opacity",
        from: "0",
        to: "1",
        values: "0;0;1;1",
        keyTimes: "0;0.2;0.4;1",
        dur: "1s",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "70",
        cy: "47",
        r: "5",
        fill: "#fff"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "opacity",
        from: "0",
        to: "1",
        values: "0;0;1;1",
        keyTimes: "0;0.4;0.6;1",
        dur: "1s",
        repeatCount: "indefinite"
      }
    })])]);
  }
}),
    QSpinnerCube = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerCube",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid"
      }
    }, [t("rect", {
      attrs: {
        x: "0",
        y: "0",
        width: "100",
        height: "100",
        fill: "none"
      }
    }), t("g", {
      attrs: {
        transform: "translate(25 25)"
      }
    }, [t("rect", {
      attrs: {
        x: "-20",
        y: "-20",
        width: "40",
        height: "40",
        fill: "currentColor",
        opacity: "0.9"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "scale",
        from: "1.5",
        to: "1",
        repeatCount: "indefinite",
        begin: "0s",
        dur: "1s",
        calcMode: "spline",
        keySplines: "0.2 0.8 0.2 0.8",
        keyTimes: "0;1"
      }
    })])]), t("g", {
      attrs: {
        transform: "translate(75 25)"
      }
    }, [t("rect", {
      attrs: {
        x: "-20",
        y: "-20",
        width: "40",
        height: "40",
        fill: "currentColor",
        opacity: "0.8"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "scale",
        from: "1.5",
        to: "1",
        repeatCount: "indefinite",
        begin: "0.1s",
        dur: "1s",
        calcMode: "spline",
        keySplines: "0.2 0.8 0.2 0.8",
        keyTimes: "0;1"
      }
    })])]), t("g", {
      attrs: {
        transform: "translate(25 75)"
      }
    }, [t("rect", {
      staticClass: "cube",
      attrs: {
        x: "-20",
        y: "-20",
        width: "40",
        height: "40",
        fill: "currentColor",
        opacity: "0.7"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "scale",
        from: "1.5",
        to: "1",
        repeatCount: "indefinite",
        begin: "0.3s",
        dur: "1s",
        calcMode: "spline",
        keySplines: "0.2 0.8 0.2 0.8",
        keyTimes: "0;1"
      }
    })])]), t("g", {
      attrs: {
        transform: "translate(75 75)"
      }
    }, [t("rect", {
      staticClass: "cube",
      attrs: {
        x: "-20",
        y: "-20",
        width: "40",
        height: "40",
        fill: "currentColor",
        opacity: "0.6"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "scale",
        from: "1.5",
        to: "1",
        repeatCount: "indefinite",
        begin: "0.2s",
        dur: "1s",
        calcMode: "spline",
        keySplines: "0.2 0.8 0.2 0.8",
        keyTimes: "0;1"
      }
    })])])]);
  }
}),
    QSpinnerDots = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerDots",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        fill: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 120 30",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("circle", {
      attrs: {
        cx: "15",
        cy: "15",
        r: "15"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "r",
        from: "15",
        to: "15",
        begin: "0s",
        dur: "0.8s",
        values: "15;9;15",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        from: "1",
        to: "1",
        begin: "0s",
        dur: "0.8s",
        values: "1;.5;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "60",
        cy: "15",
        r: "9",
        "fill-opacity": ".3"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "r",
        from: "9",
        to: "9",
        begin: "0s",
        dur: "0.8s",
        values: "9;15;9",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        from: ".5",
        to: ".5",
        begin: "0s",
        dur: "0.8s",
        values: ".5;1;.5",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "105",
        cy: "15",
        r: "15"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "r",
        from: "15",
        to: "15",
        begin: "0s",
        dur: "0.8s",
        values: "15;9;15",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        from: "1",
        to: "1",
        begin: "0s",
        dur: "0.8s",
        values: "1;.5;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })])]);
  }
}),
    QSpinnerFacebook = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerFacebook",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 100 100",
        xmlns: "http://www.w3.org/2000/svg",
        preserveAspectRatio: "xMidYMid"
      }
    }, [t("g", {
      attrs: {
        transform: "translate(20 50)"
      }
    }, [t("rect", {
      attrs: {
        x: "-10",
        y: "-30",
        width: "20",
        height: "60",
        fill: "currentColor",
        opacity: "0.6"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "scale",
        from: "2",
        to: "1",
        begin: "0s",
        repeatCount: "indefinite",
        dur: "1s",
        calcMode: "spline",
        keySplines: "0.1 0.9 0.4 1",
        keyTimes: "0;1",
        values: "2;1"
      }
    })])]), t("g", {
      attrs: {
        transform: "translate(50 50)"
      }
    }, [t("rect", {
      attrs: {
        x: "-10",
        y: "-30",
        width: "20",
        height: "60",
        fill: "currentColor",
        opacity: "0.8"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "scale",
        from: "2",
        to: "1",
        begin: "0.1s",
        repeatCount: "indefinite",
        dur: "1s",
        calcMode: "spline",
        keySplines: "0.1 0.9 0.4 1",
        keyTimes: "0;1",
        values: "2;1"
      }
    })])]), t("g", {
      attrs: {
        transform: "translate(80 50)"
      }
    }, [t("rect", {
      attrs: {
        x: "-10",
        y: "-30",
        width: "20",
        height: "60",
        fill: "currentColor",
        opacity: "0.9"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "scale",
        from: "2",
        to: "1",
        begin: "0.2s",
        repeatCount: "indefinite",
        dur: "1s",
        calcMode: "spline",
        keySplines: "0.1 0.9 0.4 1",
        keyTimes: "0;1",
        values: "2;1"
      }
    })])])]);
  }
}),
    QSpinnerGears = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerGears",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("g", {
      attrs: {
        transform: "translate(-20,-20)"
      }
    }, [t("path", {
      attrs: {
        d: "M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z",
        fill: "currentColor"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "90 50 50",
        to: "0 50 50",
        dur: "1s",
        repeatCount: "indefinite"
      }
    })])]), t("g", {
      attrs: {
        transform: "translate(20,20) rotate(15 50 50)"
      }
    }, [t("path", {
      attrs: {
        d: "M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z",
        fill: "currentColor"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 50 50",
        to: "90 50 50",
        dur: "1s",
        repeatCount: "indefinite"
      }
    })])])]);
  }
}),
    QSpinnerGrid = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerGrid",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        fill: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 105 105",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("circle", {
      attrs: {
        cx: "12.5",
        cy: "12.5",
        r: "12.5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "0s",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "12.5",
        cy: "52.5",
        r: "12.5",
        "fill-opacity": ".5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "100ms",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "52.5",
        cy: "12.5",
        r: "12.5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "300ms",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "52.5",
        cy: "52.5",
        r: "12.5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "600ms",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "92.5",
        cy: "12.5",
        r: "12.5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "800ms",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "92.5",
        cy: "52.5",
        r: "12.5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "400ms",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "12.5",
        cy: "92.5",
        r: "12.5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "700ms",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "52.5",
        cy: "92.5",
        r: "12.5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "500ms",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "92.5",
        cy: "92.5",
        r: "12.5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "200ms",
        dur: "1s",
        values: "1;.2;1",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })])]);
  }
}),
    QSpinnerHearts = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerHearts",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        fill: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 140 64",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("path", {
      attrs: {
        d: "M30.262 57.02L7.195 40.723c-5.84-3.976-7.56-12.06-3.842-18.063 3.715-6 11.467-7.65 17.306-3.68l4.52 3.76 2.6-5.274c3.716-6.002 11.47-7.65 17.304-3.68 5.84 3.97 7.56 12.054 3.842 18.062L34.49 56.118c-.897 1.512-2.793 1.915-4.228.9z",
        "fill-opacity": ".5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "0s",
        dur: "1.4s",
        values: "0.5;1;0.5",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("path", {
      attrs: {
        d: "M105.512 56.12l-14.44-24.272c-3.716-6.008-1.996-14.093 3.843-18.062 5.835-3.97 13.588-2.322 17.306 3.68l2.6 5.274 4.52-3.76c5.84-3.97 13.593-2.32 17.308 3.68 3.718 6.003 1.998 14.088-3.842 18.064L109.74 57.02c-1.434 1.014-3.33.61-4.228-.9z",
        "fill-opacity": ".5"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "fill-opacity",
        begin: "0.7s",
        dur: "1.4s",
        values: "0.5;1;0.5",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("path", {
      attrs: {
        d: "M67.408 57.834l-23.01-24.98c-5.864-6.15-5.864-16.108 0-22.248 5.86-6.14 15.37-6.14 21.234 0L70 16.168l4.368-5.562c5.863-6.14 15.375-6.14 21.235 0 5.863 6.14 5.863 16.098 0 22.247l-23.007 24.98c-1.43 1.556-3.757 1.556-5.188 0z"
      }
    })]);
  }
}),
    QSpinnerHourglass = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerHourglass",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("g", [t("path", {
      staticClass: "glass",
      attrs: {
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "5",
        "stroke-miterlimit": "10",
        d: "M58.4,51.7c-0.9-0.9-1.4-2-1.4-2.3s0.5-0.4,1.4-1.4 C70.8,43.8,79.8,30.5,80,15.5H70H30H20c0.2,15,9.2,28.1,21.6,32.3c0.9,0.9,1.4,1.2,1.4,1.5s-0.5,1.6-1.4,2.5 C29.2,56.1,20.2,69.5,20,85.5h10h40h10C79.8,69.5,70.8,55.9,58.4,51.7z"
      }
    }), t("clipPath", {
      attrs: {
        id: "uil-hourglass-clip1"
      }
    }, [t("rect", {
      staticClass: "clip",
      attrs: {
        x: "15",
        y: "20",
        width: "70",
        height: "25"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        from: "25",
        to: "0",
        dur: "1s",
        repeatCount: "indefinite",
        values: "25;0;0",
        keyTimes: "0;0.5;1"
      }
    }), t("animate", {
      attrs: {
        attributeName: "y",
        from: "20",
        to: "45",
        dur: "1s",
        repeatCount: "indefinite",
        values: "20;45;45",
        keyTimes: "0;0.5;1"
      }
    })])]), t("clipPath", {
      attrs: {
        id: "uil-hourglass-clip2"
      }
    }, [t("rect", {
      staticClass: "clip",
      attrs: {
        x: "15",
        y: "55",
        width: "70",
        height: "25"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "height",
        from: "0",
        to: "25",
        dur: "1s",
        repeatCount: "indefinite",
        values: "0;25;25",
        keyTimes: "0;0.5;1"
      }
    }), t("animate", {
      attrs: {
        attributeName: "y",
        from: "80",
        to: "55",
        dur: "1s",
        repeatCount: "indefinite",
        values: "80;55;55",
        keyTimes: "0;0.5;1"
      }
    })])]), t("path", {
      staticClass: "sand",
      attrs: {
        d: "M29,23c3.1,11.4,11.3,19.5,21,19.5S67.9,34.4,71,23H29z",
        "clip-path": "url(#uil-hourglass-clip1)",
        fill: "currentColor"
      }
    }), t("path", {
      staticClass: "sand",
      attrs: {
        d: "M71.6,78c-3-11.6-11.5-20-21.5-20s-18.5,8.4-21.5,20H71.6z",
        "clip-path": "url(#uil-hourglass-clip2)",
        fill: "currentColor"
      }
    }), t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 50 50",
        to: "180 50 50",
        repeatCount: "indefinite",
        dur: "1s",
        values: "0 50 50;0 50 50;180 50 50",
        keyTimes: "0;0.7;1"
      }
    })])]);
  }
}),
    QSpinnerInfinity = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerInfinity",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid"
      }
    }, [t("path", {
      attrs: {
        d: "M24.3,30C11.4,30,5,43.3,5,50s6.4,20,19.3,20c19.3,0,32.1-40,51.4-40C88.6,30,95,43.3,95,50s-6.4,20-19.3,20C56.4,70,43.6,30,24.3,30z",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "8",
        "stroke-dasharray": "10.691205342610678 10.691205342610678",
        "stroke-dashoffset": "0"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-dashoffset",
        from: "0",
        to: "21.382410685221355",
        begin: "0",
        dur: "2s",
        repeatCount: "indefinite",
        fill: "freeze"
      }
    })])]);
  }
}),
    QSpinnerIos = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerIos",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        stroke: "currentColor",
        fill: "currentColor",
        viewBox: "0 0 64 64"
      }
    }, [t("g", {
      attrs: {
        "stroke-width": "4",
        "stroke-linecap": "round"
      }
    }, [t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(180)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: "1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(210)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: "0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(240)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".1;0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(270)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".15;.1;0;1;.85;.7;.65;.55;.45;.35;.25;.15",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(300)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".25;.15;.1;0;1;.85;.7;.65;.55;.45;.35;.25",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(330)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".35;.25;.15;.1;0;1;.85;.7;.65;.55;.45;.35",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(0)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".45;.35;.25;.15;.1;0;1;.85;.7;.65;.55;.45",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(30)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".55;.45;.35;.25;.15;.1;0;1;.85;.7;.65;.55",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(60)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".65;.55;.45;.35;.25;.15;.1;0;1;.85;.7;.65",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(90)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".7;.65;.55;.45;.35;.25;.15;.1;0;1;.85;.7",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(120)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".85;.7;.65;.55;.45;.35;.25;.15;.1;0;1;.85",
        repeatCount: "indefinite"
      }
    })]), t("line", {
      attrs: {
        y1: "17",
        y2: "29",
        transform: "translate(32,32) rotate(150)"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: "1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1",
        repeatCount: "indefinite"
      }
    })])])]);
  }
}),
    QSpinnerOval = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerOval",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        stroke: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 38 38",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("g", {
      attrs: {
        transform: "translate(1 1)",
        "stroke-width": "2",
        fill: "none",
        "fill-rule": "evenodd"
      }
    }, [t("circle", {
      attrs: {
        "stroke-opacity": ".5",
        cx: "18",
        cy: "18",
        r: "18"
      }
    }), t("path", {
      attrs: {
        d: "M36 18c0-9.94-8.06-18-18-18"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 18 18",
        to: "360 18 18",
        dur: "1s",
        repeatCount: "indefinite"
      }
    })])])]);
  }
}),
    QSpinnerPie = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerPie",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("path", {
      attrs: {
        d: "M0 50A50 50 0 0 1 50 0L50 50L0 50",
        fill: "currentColor",
        opacity: "0.5"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 50 50",
        to: "360 50 50",
        dur: "0.8s",
        repeatCount: "indefinite"
      }
    })]), t("path", {
      attrs: {
        d: "M50 0A50 50 0 0 1 100 50L50 50L50 0",
        fill: "currentColor",
        opacity: "0.5"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 50 50",
        to: "360 50 50",
        dur: "1.6s",
        repeatCount: "indefinite"
      }
    })]), t("path", {
      attrs: {
        d: "M100 50A50 50 0 0 1 50 100L50 50L100 50",
        fill: "currentColor",
        opacity: "0.5"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 50 50",
        to: "360 50 50",
        dur: "2.4s",
        repeatCount: "indefinite"
      }
    })]), t("path", {
      attrs: {
        d: "M50 100A50 50 0 0 1 0 50L50 50L50 100",
        fill: "currentColor",
        opacity: "0.5"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 50 50",
        to: "360 50 50",
        dur: "3.2s",
        repeatCount: "indefinite"
      }
    })])]);
  }
}),
    QSpinnerPuff = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerPuff",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        stroke: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 44 44",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("g", {
      attrs: {
        fill: "none",
        "fill-rule": "evenodd",
        "stroke-width": "2"
      }
    }, [t("circle", {
      attrs: {
        cx: "22",
        cy: "22",
        r: "1"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "r",
        begin: "0s",
        dur: "1.8s",
        values: "1; 20",
        calcMode: "spline",
        keyTimes: "0; 1",
        keySplines: "0.165, 0.84, 0.44, 1",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        begin: "0s",
        dur: "1.8s",
        values: "1; 0",
        calcMode: "spline",
        keyTimes: "0; 1",
        keySplines: "0.3, 0.61, 0.355, 1",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "22",
        cy: "22",
        r: "1"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "r",
        begin: "-0.9s",
        dur: "1.8s",
        values: "1; 20",
        calcMode: "spline",
        keyTimes: "0; 1",
        keySplines: "0.165, 0.84, 0.44, 1",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        begin: "-0.9s",
        dur: "1.8s",
        values: "1; 0",
        calcMode: "spline",
        keyTimes: "0; 1",
        keySplines: "0.3, 0.61, 0.355, 1",
        repeatCount: "indefinite"
      }
    })])])]);
  }
}),
    QSpinnerRadio = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerRadio",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("g", {
      attrs: {
        transform: "scale(0.55)"
      }
    }, [t("circle", {
      attrs: {
        cx: "30",
        cy: "150",
        r: "30",
        fill: "currentColor"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "opacity",
        from: "0",
        to: "1",
        dur: "1s",
        begin: "0",
        repeatCount: "indefinite",
        keyTimes: "0;0.5;1",
        values: "0;1;1"
      }
    })]), t("path", {
      attrs: {
        d: "M90,150h30c0-49.7-40.3-90-90-90v30C63.1,90,90,116.9,90,150z",
        fill: "currentColor"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "opacity",
        from: "0",
        to: "1",
        dur: "1s",
        begin: "0.1",
        repeatCount: "indefinite",
        keyTimes: "0;0.5;1",
        values: "0;1;1"
      }
    })]), t("path", {
      attrs: {
        d: "M150,150h30C180,67.2,112.8,0,30,0v30C96.3,30,150,83.7,150,150z",
        fill: "currentColor"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "opacity",
        from: "0",
        to: "1",
        dur: "1s",
        begin: "0.2",
        repeatCount: "indefinite",
        keyTimes: "0;0.5;1",
        values: "0;1;1"
      }
    })])])]);
  }
}),
    QSpinnerRings = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerRings",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        stroke: "currentColor",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 45 45",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("g", {
      attrs: {
        fill: "none",
        "fill-rule": "evenodd",
        transform: "translate(1 1)",
        "stroke-width": "2"
      }
    }, [t("circle", {
      attrs: {
        cx: "22",
        cy: "22",
        r: "6"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "r",
        begin: "1.5s",
        dur: "3s",
        values: "6;22",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        begin: "1.5s",
        dur: "3s",
        values: "1;0",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "stroke-width",
        begin: "1.5s",
        dur: "3s",
        values: "2;0",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "22",
        cy: "22",
        r: "6"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "r",
        begin: "3s",
        dur: "3s",
        values: "6;22",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "stroke-opacity",
        begin: "3s",
        dur: "3s",
        values: "1;0",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    }), t("animate", {
      attrs: {
        attributeName: "stroke-width",
        begin: "3s",
        dur: "3s",
        values: "2;0",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        cx: "22",
        cy: "22",
        r: "8"
      }
    }, [t("animate", {
      attrs: {
        attributeName: "r",
        begin: "0s",
        dur: "1.5s",
        values: "6;1;2;3;4;5;6",
        calcMode: "linear",
        repeatCount: "indefinite"
      }
    })])])]);
  }
}),
    QSpinnerTail = vue_runtime_esm["a" /* default */].extend({
  name: "QSpinnerTail",
  mixins: [mixin$1],
  render: function render(t) {
    return t("svg", {
      staticClass: "q-spinner",
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        focusable: "false",
        width: this.cSize,
        height: this.cSize,
        viewBox: "0 0 38 38",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("defs", [t("linearGradient", {
      attrs: {
        x1: "8.042%",
        y1: "0%",
        x2: "65.682%",
        y2: "23.865%",
        id: "a"
      }
    }, [t("stop", {
      attrs: {
        "stop-color": "currentColor",
        "stop-opacity": "0",
        offset: "0%"
      }
    }), t("stop", {
      attrs: {
        "stop-color": "currentColor",
        "stop-opacity": ".631",
        offset: "63.146%"
      }
    }), t("stop", {
      attrs: {
        "stop-color": "currentColor",
        offset: "100%"
      }
    })])]), t("g", {
      attrs: {
        transform: "translate(1 1)",
        fill: "none",
        "fill-rule": "evenodd"
      }
    }, [t("path", {
      attrs: {
        d: "M36 18c0-9.94-8.06-18-18-18",
        stroke: "url(#a)",
        "stroke-width": "2"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 18 18",
        to: "360 18 18",
        dur: "0.9s",
        repeatCount: "indefinite"
      }
    })]), t("circle", {
      attrs: {
        fill: "currentColor",
        cx: "36",
        cy: "18",
        r: "1"
      }
    }, [t("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 18 18",
        to: "360 18 18",
        dur: "0.9s",
        repeatCount: "indefinite"
      }
    })])])]);
  }
}),
    QSplitter = vue_runtime_esm["a" /* default */].extend({
  name: "QSplitter",
  mixins: [DarkMixin, ListenersMixin],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    value: {
      type: Number,
      required: !0
    },
    reverse: Boolean,
    unit: {
      type: String,
      default: "%",
      validator: function validator(t) {
        return ["%", "px"].includes(t);
      }
    },
    limits: {
      type: Array,
      validator: function validator(t) {
        return 2 === t.length && "number" == typeof t[0] && "number" == typeof t[1] && t[0] >= 0 && t[0] <= t[1];
      }
    },
    emitImmediately: Boolean,
    horizontal: Boolean,
    disable: Boolean,
    beforeClass: [Array, String, Object],
    afterClass: [Array, String, Object],
    separatorClass: [Array, String, Object],
    separatorStyle: [Array, String, Object]
  },
  watch: {
    value: {
      immediate: !0,
      handler: function handler(t) {
        this.__normalize(t, this.computedLimits);
      }
    },
    limits: {
      deep: !0,
      handler: function handler() {
        var t = this;
        this.$nextTick(function () {
          t.__normalize(t.value, t.computedLimits);
        });
      }
    }
  },
  computed: {
    classes: function classes() {
      return (!0 === this.horizontal ? "column" : "row") + " q-splitter--" + (!0 === this.horizontal ? "horizontal" : "vertical") + " q-splitter--" + (!0 === this.disable ? "disabled" : "workable") + (!0 === this.isDark ? " q-splitter--dark" : "");
    },
    prop: function prop() {
      return !0 === this.horizontal ? "height" : "width";
    },
    side: function side() {
      return !0 !== this.reverse ? "before" : "after";
    },
    computedLimits: function computedLimits() {
      return void 0 !== this.limits ? this.limits : "%" === this.unit ? [10, 90] : [50, 1 / 0];
    },
    styles: function styles() {
      var t, e;
      return (e = {})[this.side] = ((t = {})[this.prop] = this.__getCSSValue(this.value), t), e;
    }
  },
  methods: {
    __pan: function __pan(t) {
      if (!0 === t.isFirst) {
        var e = this.$el.getBoundingClientRect()[this.prop];
        return this.__dir = !0 === this.horizontal ? "up" : "left", this.__maxValue = "%" === this.unit ? 100 : e, this.__value = Math.min(this.__maxValue, this.computedLimits[1], Math.max(this.computedLimits[0], this.value)), this.__multiplier = (!0 !== this.reverse ? 1 : -1) * (!0 === this.horizontal ? 1 : !0 === this.$q.lang.rtl ? -1 : 1) * ("%" === this.unit ? 0 === e ? 0 : 100 / e : 1), void this.$el.classList.add("q-splitter--active");
      }

      if (!0 === t.isFinal) return this.__normalized !== this.value && this.$emit("input", this.__normalized), void this.$el.classList.remove("q-splitter--active");
      var i = this.__value + this.__multiplier * (t.direction === this.__dir ? -1 : 1) * t.distance[!0 === this.horizontal ? "y" : "x"];
      this.__normalized = Math.min(this.__maxValue, this.computedLimits[1], Math.max(this.computedLimits[0], i)), this.$refs[this.side].style[this.prop] = this.__getCSSValue(this.__normalized), !0 === this.emitImmediately && this.value !== this.__normalized && this.$emit("input", this.__normalized);
    },
    __normalize: function __normalize(t, e) {
      t < e[0] ? this.$emit("input", e[0]) : t > e[1] && this.$emit("input", e[1]);
    },
    __getCSSValue: function __getCSSValue(t) {
      return ("%" === this.unit ? t : Math.round(t)) + this.unit;
    }
  },
  render: function render(t) {
    var e = !0 === this.disable ? {
      "aria-disabled": ""
    } : void 0,
        i = [t("div", {
      ref: "before",
      staticClass: "q-splitter__panel q-splitter__before" + (!0 === this.reverse ? " col" : ""),
      style: this.styles.before,
      class: this.beforeClass,
      on: cache(this, "stop", {
        input: stop
      })
    }, slot(this, "before")), t("div", {
      staticClass: "q-splitter__separator",
      style: this.separatorStyle,
      class: this.separatorClass,
      attrs: e
    }, [t("div", {
      staticClass: "absolute-full q-splitter__separator-area",
      directives: !0 === this.disable ? void 0 : cache(this, "dir#" + this.horizontal, [{
        name: "touch-pan",
        value: this.__pan,
        modifiers: {
          horizontal: !0 !== this.horizontal,
          vertical: this.horizontal,
          prevent: !0,
          stop: !0,
          mouse: !0,
          mouseAllDir: !0
        }
      }])
    }, slot(this, "separator"))]), t("div", {
      ref: "after",
      staticClass: "q-splitter__panel q-splitter__after" + (!0 === this.reverse ? "" : " col"),
      style: this.styles.after,
      class: this.afterClass,
      on: cache(this, "stop", {
        input: stop
      })
    }, slot(this, "after"))];
    return t("div", {
      staticClass: "q-splitter no-wrap",
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, mergeSlot(i, this, "default"));
  }
}),
    StepHeader = vue_runtime_esm["a" /* default */].extend({
  name: "StepHeader",
  mixins: [AttrsMixin],
  directives: {
    Ripple: Ripple
  },
  props: {
    stepper: {},
    step: {}
  },
  computed: {
    isActive: function isActive() {
      return this.stepper.value === this.step.name;
    },
    isDisable: function isDisable() {
      var t = this.step.disable;
      return !0 === t || "" === t;
    },
    isError: function isError() {
      var t = this.step.error;
      return !0 === t || "" === t;
    },
    isDone: function isDone() {
      var t = this.step.done;
      return !1 === this.isDisable && (!0 === t || "" === t);
    },
    headerNav: function headerNav() {
      var t = this.step.headerNav,
          e = !0 === t || "" === t || void 0 === t;
      return !1 === this.isDisable && this.stepper.headerNav && (!0 === this.isActive || e);
    },
    hasPrefix: function hasPrefix() {
      return this.step.prefix && !1 === this.isActive && !1 === this.isError && !1 === this.isDone;
    },
    icon: function icon() {
      return !0 === this.isActive ? this.step.activeIcon || this.stepper.activeIcon || this.$q.iconSet.stepper.active : !0 === this.isError ? this.step.errorIcon || this.stepper.errorIcon || this.$q.iconSet.stepper.error : !1 === this.isDisable && !0 === this.isDone ? this.step.doneIcon || this.stepper.doneIcon || this.$q.iconSet.stepper.done : this.step.icon || this.stepper.inactiveIcon;
    },
    color: function color() {
      var t = !0 === this.isError ? this.step.errorColor || this.stepper.errorColor : void 0;

      if (!0 === this.isActive) {
        var e = this.step.activeColor || this.stepper.activeColor || this.step.color;
        return void 0 !== e ? e : t;
      }

      return void 0 !== t ? t : !1 === this.isDisable && !0 === this.isDone ? this.step.doneColor || this.stepper.doneColor || this.step.color || this.stepper.inactiveColor : this.step.color || this.stepper.inactiveColor;
    },
    classes: function classes() {
      return "q-stepper__tab col-grow flex items-center no-wrap relative-position" + (void 0 !== this.color ? " text-" + this.color : "") + (!0 === this.isError ? " q-stepper__tab--error" : "") + (!0 === this.isActive ? " q-stepper__tab--active" : "") + (!0 === this.isDone ? " q-stepper__tab--done" : "") + (!0 === this.headerNav ? " q-stepper__tab--navigation q-focusable q-hoverable" : "") + (!0 === this.isDisable ? " q-stepper__tab--disabled" : "");
    }
  },
  methods: {
    activate: function activate() {
      void 0 !== this.$refs.blurTarget && this.$refs.blurTarget.focus(), !1 === this.isActive && this.stepper.goTo(this.step.name);
    },
    keyup: function keyup(t) {
      13 === t.keyCode && !1 === this.isActive && this.stepper.goTo(this.step.name);
    }
  },
  render: function render(t) {
    var e = {
      class: this.classes
    };
    !0 === this.stepper.headerNav && (e.directives = [{
      name: "ripple",
      value: this.headerNav
    }]), !0 === this.headerNav && Object.assign(e, {
      on: cache(this, "headnavon", {
        click: this.activate,
        keyup: this.keyup
      }),
      attrs: !0 === this.isDisable ? {
        tabindex: -1,
        "aria-disabled": ""
      } : {
        tabindex: this.qAttrs.tabindex || 0
      }
    });
    var i = [t("div", {
      staticClass: "q-focus-helper",
      attrs: {
        tabindex: -1
      },
      ref: "blurTarget"
    }), t("div", {
      staticClass: "q-stepper__dot row flex-center q-stepper__line relative-position"
    }, [t("span", {
      staticClass: "row flex-center"
    }, [!0 === this.hasPrefix ? this.step.prefix : t(QIcon, {
      props: {
        name: this.icon
      }
    })])])];

    if (void 0 !== this.step.title && null !== this.step.title) {
      var s = [t("div", {
        staticClass: "q-stepper__title"
      }, [this.step.title])];
      void 0 !== this.step.caption && null !== this.step.caption && s.push(t("div", {
        staticClass: "q-stepper__caption"
      }, [this.step.caption])), i.push(t("div", {
        staticClass: "q-stepper__label q-stepper__line relative-position"
      }, s));
    }

    return t("div", e, i);
  }
}),
    StepWrapper = vue_runtime_esm["a" /* default */].extend({
  name: "QStepWrapper",
  render: function render(t) {
    return t("div", {
      staticClass: "q-stepper__step-content"
    }, [t("div", {
      staticClass: "q-stepper__step-inner"
    }, slot(this, "default"))]);
  }
}),
    QStep = vue_runtime_esm["a" /* default */].extend({
  name: "QStep",
  inject: {
    stepper: {
      default: function _default() {
        console.error("QStep needs to be child of QStepper");
      }
    }
  },
  mixins: [PanelChildMixin],
  props: {
    icon: String,
    color: String,
    title: {
      type: String,
      required: !0
    },
    caption: String,
    prefix: [String, Number],
    doneIcon: String,
    doneColor: String,
    activeIcon: String,
    activeColor: String,
    errorIcon: String,
    errorColor: String,
    headerNav: {
      type: Boolean,
      default: !0
    },
    done: Boolean,
    error: Boolean
  },
  computed: {
    isActive: function isActive() {
      return this.stepper.value === this.name;
    }
  },
  watch: {
    isActive: function isActive(t) {
      var e = this;
      !0 === t && !0 === this.stepper.vertical && this.$nextTick(function () {
        void 0 !== e.$el && (e.$el.scrollTop = 0);
      });
    }
  },
  render: function render(t) {
    var e = this.stepper.vertical,
        i = !0 === e && !0 === this.stepper.keepAlive ? t("keep-alive", !0 === this.isActive ? [t(StepWrapper, {
      key: this.name
    }, slot(this, "default"))] : void 0) : !0 !== e || !0 === this.isActive ? StepWrapper.options.render.call(this, t) : void 0;
    return t("div", {
      staticClass: "q-stepper__step",
      on: Object.assign({}, this.qListeners)
    }, !0 === e ? [t(StepHeader, {
      props: {
        stepper: this.stepper,
        step: this
      }
    }), !0 === this.stepper.animated ? t(QSlideTransition, [i]) : i] : [i]);
  }
}),
    QStepper = vue_runtime_esm["a" /* default */].extend({
  name: "QStepper",
  provide: function provide() {
    return {
      stepper: this
    };
  },
  mixins: [DarkMixin, PanelParentMixin],
  props: {
    flat: Boolean,
    bordered: Boolean,
    alternativeLabels: Boolean,
    headerNav: Boolean,
    contracted: Boolean,
    headerClass: String,
    inactiveColor: String,
    inactiveIcon: String,
    doneIcon: String,
    doneColor: String,
    activeIcon: String,
    activeColor: String,
    errorIcon: String,
    errorColor: String
  },
  computed: {
    classes: function classes() {
      return "q-stepper q-stepper--" + (!0 === this.vertical ? "vertical" : "horizontal") + (!0 === this.flat || !0 === this.isDark ? " q-stepper--flat no-shadow" : "") + (!0 === this.bordered || !0 === this.isDark && !1 === this.flat ? " q-stepper--bordered" : "") + (!0 === this.contracted ? " q-stepper--contracted" : "") + (!0 === this.isDark ? " q-stepper--dark q-dark" : "");
    },
    headerClasses: function headerClasses() {
      return "q-stepper__header row items-stretch justify-between q-stepper__header--" + (!0 === this.alternativeLabels ? "alternative" : "standard") + "-labels" + (!1 === this.flat || !0 === this.bordered ? " q-stepper__header--border" : "") + (void 0 !== this.headerClass ? " " + this.headerClass : "");
    }
  },
  methods: {
    __getContent: function __getContent(t) {
      var e = this,
          i = slot(this, "message", []);
      return !0 === this.vertical ? (this.__isValidPanelName(this.value) && this.__updatePanelIndex(), i.concat(t("div", {
        staticClass: "q-stepper__content",
        on: cache(this, "stop", {
          input: stop
        })
      }, slot(this, "default")))) : [t("div", {
        class: this.headerClasses
      }, this.__getAllPanels().map(function (i) {
        var s = i.componentOptions.propsData;
        return t(StepHeader, {
          key: s.name,
          props: {
            stepper: e,
            step: s
          }
        });
      }))].concat(i, t("div", {
        staticClass: "q-stepper__content q-panel-parent",
        directives: this.panelDirectives
      }, this.__getPanelContent(t)));
    },
    __renderPanels: function __renderPanels(t) {
      return t("div", {
        class: this.classes,
        on: Object.assign({}, this.qListeners)
      }, mergeSlot(this.__getContent(t), this, "navigation"));
    }
  }
}),
    QStepperNavigation = vue_runtime_esm["a" /* default */].extend({
  name: "QStepperNavigation",
  mixins: [ListenersMixin],
  render: function render(t) {
    return t("div", {
      staticClass: "q-stepper__nav",
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    Top = {
  computed: {
    marginalsProps: function marginalsProps() {
      return {
        pagination: this.computedPagination,
        pagesNumber: this.pagesNumber,
        isFirstPage: this.isFirstPage,
        isLastPage: this.isLastPage,
        prevPage: this.prevPage,
        nextPage: this.nextPage,
        inFullscreen: this.inFullscreen,
        toggleFullscreen: this.toggleFullscreen
      };
    }
  },
  methods: {
    getTop: function getTop(t) {
      var e,
          i = this.$scopedSlots.top,
          s = this.$scopedSlots["top-left"],
          n = this.$scopedSlots["top-right"],
          o = this.$scopedSlots["top-selection"],
          r = !0 === this.hasSelectionMode && void 0 !== o && this.rowsSelectedNumber > 0,
          a = "q-table__top relative-position row items-center";
      return void 0 !== i ? t("div", {
        staticClass: a
      }, [i(this.marginalsProps)]) : (!0 === r ? e = o(this.marginalsProps).slice() : (e = [], void 0 !== s ? e.push(t("div", {
        staticClass: "q-table-control"
      }, [s(this.marginalsProps)])) : this.title && e.push(t("div", {
        staticClass: "q-table__control"
      }, [t("div", {
        staticClass: "q-table__title"
      }, this.title)]))), void 0 !== n && (e.push(t("div", {
        staticClass: "q-table__separator col"
      })), e.push(t("div", {
        staticClass: "q-table__control"
      }, [n(this.marginalsProps)]))), 0 !== e.length ? t("div", {
        staticClass: a
      }, e) : void 0);
    }
  }
},
    QTh = vue_runtime_esm["a" /* default */].extend({
  name: "QTh",
  mixins: [ListenersMixin],
  props: {
    props: Object,
    autoWidth: Boolean
  },
  render: function render(t) {
    var e,
        i,
        s = this,
        n = Object.assign({}, this.qListeners);
    if (void 0 === this.props) return t("th", {
      on: n,
      class: !0 === this.autoWidth ? "q-table--col-auto-width" : null
    }, slot(this, "default"));
    var o = this.$vnode.key;

    if (o) {
      if (void 0 === (e = this.props.colsMap[o])) return;
    } else e = this.props.col;

    if (!0 === e.sortable) {
      var r = "right" === e.align ? "unshift" : "push";
      (i = uniqueSlot(this, "default", []))[r](t(QIcon, {
        props: {
          name: this.$q.iconSet.table.arrowUp
        },
        staticClass: e.__iconClass
      }));
    } else i = slot(this, "default");

    var a = !0 === e.sortable ? {
      click: function click(t) {
        s.props.sort(e), s.$emit("click", t);
      }
    } : {};
    return t("th", {
      on: Object.assign({}, n, a),
      style: e.__thStyle,
      class: e.__thClass + (!0 === this.autoWidth ? " q-table--col-auto-width" : "")
    }, i);
  }
}),
    TableHeader = {
  methods: {
    getTableHeader: function getTableHeader(t) {
      var e = this.getTableHeaderRow(t);
      return !0 === this.loading && void 0 === this.$scopedSlots.loading && e.push(t("tr", {
        staticClass: "q-table__progress"
      }, [t("th", {
        staticClass: "relative-position",
        attrs: {
          colspan: "100%"
        }
      }, this.__getProgress(t))])), t("thead", e);
    },
    getTableHeaderRow: function getTableHeaderRow(t) {
      var e,
          i = this,
          s = this.$scopedSlots.header,
          n = this.$scopedSlots["header-cell"];
      if (void 0 !== s) return s(this.addTableHeaderRowMeta({
        header: !0,
        cols: this.computedCols,
        sort: this.sort,
        colsMap: this.computedColsMap
      })).slice();
      e = void 0 !== n ? function (t) {
        return n({
          col: t,
          cols: i.computedCols,
          sort: i.sort,
          colsMap: i.computedColsMap
        });
      } : function (e) {
        var s = {
          col: e,
          cols: i.computedCols,
          sort: i.sort,
          colsMap: i.computedColsMap
        },
            n = i.$scopedSlots["header-cell-" + e.name];
        return void 0 !== n ? n(s) : t(QTh, {
          key: e.name,
          props: {
            props: s
          },
          style: e.headerStyle,
          class: e.headerClasses
        }, e.label);
      };
      var o = this.computedCols.map(e);
      return !0 === this.singleSelection && !0 !== this.grid ? o.unshift(t("th", {
        staticClass: "q-table--col-auto-width"
      }, [" "])) : !0 === this.multipleSelection && o.unshift(t("th", {
        staticClass: "q-table--col-auto-width"
      }, [t(QCheckbox, {
        props: {
          color: this.color,
          value: !0 === this.someRowsSelected ? null : this.allRowsSelected,
          dark: this.isDark,
          dense: this.dense
        },
        on: cache(this, "inp", {
          input: function input(t) {
            !0 === i.someRowsSelected && (t = !1), i.__updateSelection(i.computedRows.map(i.getRowKey), i.computedRows, t);
          }
        })
      })])), [t("tr", {
        style: this.tableHeaderStyle,
        class: this.tableHeaderClass
      }, o)];
    },
    addTableHeaderRowMeta: function addTableHeaderRowMeta(t) {
      var e = this;
      return !0 === this.multipleSelection && (Object.defineProperty(t, "selected", {
        get: function get() {
          return !0 === e.someRowsSelected ? "some" : e.allRowsSelected;
        },
        set: function set(t) {
          !0 === e.someRowsSelected && (t = !1), e.__updateSelection(e.computedRows.map(e.getRowKey), e.computedRows, t);
        },
        configurable: !0,
        enumerable: !0
      }), t.partialSelected = this.someRowsSelected, t.multipleSelect = !0), t;
    }
  }
},
    TableBody = {
  methods: {
    getTableRowBody: function getTableRowBody(t, e, i) {
      var s = this.getRowKey(t),
          n = this.isRowSelected(s);
      return e(this.addBodyRowMeta({
        key: s,
        row: t,
        pageIndex: i,
        cols: this.computedCols,
        colsMap: this.computedColsMap,
        __trClass: n ? "selected" : ""
      }));
    },
    getTableRow: function getTableRow(t, e, i) {
      var s = this,
          n = this.$scopedSlots["body-cell"],
          o = this.getRowKey(e),
          r = this.isRowSelected(o),
          a = n ? this.computedCols.map(function (t) {
        return n(s.addBodyCellMetaData({
          row: e,
          pageIndex: i,
          col: t
        }));
      }) : this.computedCols.map(function (n) {
        var o = s.$scopedSlots["body-cell-" + n.name];
        return void 0 !== o ? o(s.addBodyCellMetaData({
          row: e,
          pageIndex: i,
          col: n
        })) : t("td", {
          class: n.__tdClass,
          style: n.__tdStyle
        }, s.getCellValue(n, e));
      });
      !0 === this.hasSelectionMode && a.unshift(t("td", {
        staticClass: "q-table--col-auto-width"
      }, [t(QCheckbox, {
        props: {
          value: r,
          color: this.color,
          dark: this.isDark,
          dense: this.dense
        },
        on: {
          input: function input(t, i) {
            s.__updateSelection([o], [e], t, i);
          }
        }
      })]));
      var l = {
        key: o,
        class: {
          selected: r
        },
        on: {}
      };
      return void 0 !== this.qListeners["row-click"] && (l.class["cursor-pointer"] = !0, l.on.click = function (t) {
        s.$emit("row-click", t, e);
      }), void 0 !== this.qListeners["row-dblclick"] && (l.class["cursor-pointer"] = !0, l.on.dblclick = function (t) {
        s.$emit("row-dblclick", t, e);
      }), t("tr", l, a);
    },
    getTableBody: function getTableBody(t) {
      var e = this,
          i = this.$scopedSlots.body,
          s = this.$scopedSlots["top-row"],
          n = this.$scopedSlots["bottom-row"],
          o = void 0 !== i ? function (t, s) {
        return e.getTableRowBody(t, i, s);
      } : function (i, s) {
        return e.getTableRow(t, i, s);
      },
          r = this.computedRows.map(o);
      return void 0 !== s && (r = s({
        cols: this.computedCols
      }).concat(r)), void 0 !== n && (r = r.concat(n({
        cols: this.computedCols
      }))), t("tbody", r);
    },
    getTableRowVirtual: function getTableRowVirtual(t) {
      var e = this,
          i = this.$scopedSlots.body;
      return void 0 !== i ? function (t, s) {
        return e.getTableRowBody(t.item, i, s);
      } : function (i, s) {
        return e.getTableRow(t, i.item, s);
      };
    },
    addBodyRowMeta: function addBodyRowMeta(t) {
      var e = this;
      return t.rowIndex = this.firstRowIndex + t.pageIndex, !0 === this.hasSelectionMode && Object.defineProperty(t, "selected", {
        get: function get() {
          return e.isRowSelected(t.key);
        },
        set: function set(i) {
          e.__updateSelection([t.key], [t.row], i);
        },
        configurable: !0,
        enumerable: !0
      }), Object.defineProperty(t, "expand", {
        get: function get() {
          return e.isRowExpanded(t.key);
        },
        set: function set(i) {
          e.__updateExpanded(t.key, i);
        },
        configurable: !0,
        enumerable: !0
      }), t.cols = t.cols.map(function (i) {
        var s = Object.assign({}, i);
        return Object.defineProperty(s, "value", {
          get: function get() {
            return e.getCellValue(i, t.row);
          },
          configurable: !0,
          enumerable: !0
        }), s;
      }), t;
    },
    addBodyCellMetaData: function addBodyCellMetaData(t) {
      var e = this;
      return t.rowIndex = this.firstRowIndex + t.pageIndex, Object.defineProperty(t, "value", {
        get: function get() {
          return e.getCellValue(t.col, t.row);
        },
        configurable: !0,
        enumerable: !0
      }), t;
    },
    getCellValue: function getCellValue(t, e) {
      var i = "function" == typeof t.field ? t.field(e) : e[t.field];
      return void 0 !== t.format ? t.format(i, e) : i;
    }
  }
},
    Bottom = {
  computed: {
    navIcon: function navIcon() {
      var t = [this.$q.iconSet.table.prevPage, this.$q.iconSet.table.nextPage];
      return !0 === this.$q.lang.rtl ? t.reverse() : t;
    }
  },
  methods: {
    getBottom: function getBottom(t) {
      if (!0 !== this.hideBottom) {
        if (!0 === this.nothingToDisplay) {
          var e = !0 === this.loading ? this.loadingLabel || this.$q.lang.table.loading : this.filter ? this.noResultsLabel || this.$q.lang.table.noResults : this.noDataLabel || this.$q.lang.table.noData,
              i = this.$scopedSlots["no-data"];
          return t("div", {
            staticClass: "q-table__bottom row items-center q-table__bottom--nodata"
          }, void 0 !== i ? [i({
            message: e,
            icon: this.$q.iconSet.table.warning,
            filter: this.filter
          })] : [t(QIcon, {
            staticClass: "q-table__bottom-nodata-icon",
            props: {
              name: this.$q.iconSet.table.warning
            }
          }), e]);
        }

        var s = this.$scopedSlots.bottom;
        return t("div", {
          staticClass: "q-table__bottom row items-center",
          class: void 0 !== s ? null : "justify-end"
        }, void 0 !== s ? [s(this.marginalsProps)] : this.getPaginationRow(t));
      }
    },
    getPaginationRow: function getPaginationRow(t) {
      var e,
          i = this,
          s = this.computedPagination.rowsPerPage,
          n = this.paginationLabel || this.$q.lang.table.pagination,
          o = this.$scopedSlots.pagination,
          r = this.rowsPerPageOptions.length > 1,
          a = [t("div", {
        staticClass: "q-table__control"
      }, [t("div", [!0 === this.hasSelectionMode && this.rowsSelectedNumber > 0 ? (this.selectedRowsLabel || this.$q.lang.table.selectedRecords)(this.rowsSelectedNumber) : ""])]), t("div", {
        staticClass: "q-table__separator col"
      })];
      if (!0 === r && a.push(t("div", {
        staticClass: "q-table__control"
      }, [t("span", {
        staticClass: "q-table__bottom-item"
      }, [this.rowsPerPageLabel || this.$q.lang.table.recordsPerPage]), t(QSelect, {
        staticClass: "q-table__select inline q-table__bottom-item",
        props: {
          color: this.color,
          value: s,
          options: this.computedRowsPerPageOptions,
          displayValue: 0 === s ? this.$q.lang.table.allRows : s,
          dark: this.isDark,
          borderless: !0,
          dense: !0,
          optionsDense: !0,
          optionsCover: !0
        },
        on: cache(this, "pgSize", {
          input: function input(t) {
            i.setPagination({
              page: 1,
              rowsPerPage: t.value
            });
          }
        })
      })])), void 0 !== o) e = o(this.marginalsProps);else if (e = [t("span", 0 !== s ? {
        staticClass: "q-table__bottom-item"
      } : {}, [s ? n(this.firstRowIndex + 1, Math.min(this.lastRowIndex, this.computedRowsNumber), this.computedRowsNumber) : n(1, this.filteredSortedRowsNumber, this.computedRowsNumber)])], 0 !== s) {
        var l = !0 === this.dense ? "sm" : void 0;
        e.push(t(QBtn, {
          props: {
            color: this.color,
            round: !0,
            icon: this.navIcon[0],
            dense: !0,
            flat: !0,
            size: l,
            disable: this.isFirstPage
          },
          on: cache(this, "pgPrev", {
            click: this.prevPage
          })
        }), t(QBtn, {
          props: {
            color: this.color,
            round: !0,
            icon: this.navIcon[1],
            dense: !0,
            size: l,
            flat: !0,
            disable: this.isLastPage
          },
          on: cache(this, "pgNext", {
            click: this.nextPage
          })
        }));
      }
      return a.push(t("div", {
        staticClass: "q-table__control"
      }, e)), a;
    }
  }
},
    TableGrid = {
  methods: {
    getGridBody: function getGridBody(t) {
      var e = this,
          i = void 0 !== this.$scopedSlots.item ? this.$scopedSlots.item : function (i) {
        var s = i.cols.map(function (e) {
          return t("div", {
            staticClass: "q-table__grid-item-row"
          }, [t("div", {
            staticClass: "q-table__grid-item-title"
          }, [e.label]), t("div", {
            staticClass: "q-table__grid-item-value"
          }, [e.value])]);
        });
        !0 === e.hasSelectionMode && s.unshift(t("div", {
          staticClass: "q-table__grid-item-row"
        }, [t(QCheckbox, {
          props: {
            value: i.selected,
            color: e.color,
            dark: e.isDark,
            dense: !0
          },
          on: {
            input: function input(t, s) {
              e.__updateSelection([i.key], [i.row], t, s);
            }
          }
        })]), t(QSeparator, {
          props: {
            dark: e.isDark
          }
        }));
        var n = {
          staticClass: "q-table__grid-item-card" + e.cardDefaultClass,
          class: e.cardClass,
          style: e.cardStyle,
          on: {}
        };
        return void 0 === e.qListeners["row-click"] && void 0 === e.qListeners["row-dblclick"] || (n.staticClass += " cursor-pointer"), void 0 !== e.qListeners["row-click"] && (n.on.click = function (t) {
          e.$emit("row-click", t, i.row);
        }), void 0 !== e.qListeners["row-dblclick"] && (n.on.dblclick = function (t) {
          e.$emit("row-dblclick", t, i.row);
        }), t("div", {
          staticClass: "q-table__grid-item col-xs-12 col-sm-6 col-md-4 col-lg-3",
          class: !0 === i.selected ? "q-table__grid-item--selected" : ""
        }, [t("div", n, s)]);
      };
      return t("div", {
        staticClass: "q-table__grid-content row",
        class: this.cardContainerClass,
        style: this.cardContainerStyle
      }, this.computedRows.map(function (t, s) {
        var n = e.getRowKey(t),
            o = e.isRowSelected(n);
        return i(e.addBodyRowMeta({
          key: n,
          row: t,
          pageIndex: s,
          cols: e.computedCols,
          colsMap: e.computedColsMap,
          __trClass: o ? "selected" : ""
        }));
      }));
    },
    getGridHeader: function getGridHeader(t) {
      return t("div", {
        staticClass: "q-table__middle"
      }, !0 === this.gridHeader ? [t("table", {
        staticClass: "q-table"
      }, [this.getTableHeader(t)])] : !0 === this.loading && void 0 === this.$scopedSlots.loading ? this.__getProgress(t) : void 0);
    }
  }
};

function getTableMiddle(t, e, i) {
  return t("div", Object.assign({}, e, {
    staticClass: "q-table__middle" + (void 0 !== e.staticClass ? " " + e.staticClass : "")
  }), [t("table", {
    staticClass: "q-table"
  }, i)]);
}

var comps = {
  list: QList,
  table: QMarkupTable
},
    QVirtualScroll = vue_runtime_esm["a" /* default */].extend({
  name: "QVirtualScroll",
  mixins: [AttrsMixin, ListenersMixin, VirtualScroll],
  props: {
    type: {
      type: String,
      default: "list",
      validator: function validator(t) {
        return ["list", "table", "__qtable"].includes(t);
      }
    },
    items: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    itemsFn: Function,
    itemsSize: Number,
    scrollTarget: {
      default: void 0
    }
  },
  computed: {
    virtualScrollLength: function virtualScrollLength() {
      return this.itemsSize >= 0 && void 0 !== this.itemsFn ? parseInt(this.itemsSize, 10) : Array.isArray(this.items) ? this.items.length : 0;
    },
    virtualScrollScope: function virtualScrollScope() {
      var t = this;
      if (0 === this.virtualScrollLength) return [];

      var e = function e(_e4, i) {
        return {
          index: t.virtualScrollSliceRange.from + i,
          item: _e4
        };
      };

      return void 0 === this.itemsFn ? this.items.slice(this.virtualScrollSliceRange.from, this.virtualScrollSliceRange.to).map(e) : this.itemsFn(this.virtualScrollSliceRange.from, this.virtualScrollSliceRange.to - this.virtualScrollSliceRange.from).map(e);
    },
    classes: function classes() {
      return "q-virtual-scroll q-virtual-scroll" + (!0 === this.virtualScrollHorizontal ? "--horizontal" : "--vertical") + (void 0 !== this.scrollTarget ? "" : " scroll");
    },
    attrs: function attrs() {
      return void 0 !== this.scrollTarget ? void 0 : {
        tabindex: 0
      };
    }
  },
  watch: {
    virtualScrollLength: function virtualScrollLength() {
      this.__resetVirtualScroll();
    },
    scrollTarget: function scrollTarget() {
      this.__unconfigureScrollTarget(), this.__configureScrollTarget();
    }
  },
  methods: {
    __getVirtualScrollEl: function __getVirtualScrollEl() {
      return this.$el;
    },
    __getVirtualScrollTarget: function __getVirtualScrollTarget() {
      return this.__scrollTarget;
    },
    __configureScrollTarget: function __configureScrollTarget() {
      this.__scrollTarget = getScrollTarget(this.$el, this.scrollTarget), this.__scrollTarget.addEventListener("scroll", this.__onVirtualScrollEvt, listenOpts.passive);
    },
    __unconfigureScrollTarget: function __unconfigureScrollTarget() {
      void 0 !== this.__scrollTarget && (this.__scrollTarget.removeEventListener("scroll", this.__onVirtualScrollEvt, listenOpts.passive), this.__scrollTarget = void 0);
    }
  },
  beforeMount: function beforeMount() {
    this.__resetVirtualScroll();
  },
  mounted: function mounted() {
    this.__configureScrollTarget();
  },
  beforeDestroy: function beforeDestroy() {
    this.__unconfigureScrollTarget();
  },
  render: function render(t) {
    if (void 0 !== this.$scopedSlots.default) {
      var e = this.__padVirtualScroll(t, "list" === this.type ? "div" : "tbody", this.virtualScrollScope.map(this.$scopedSlots.default));

      return void 0 !== this.$scopedSlots.before && (e = this.$scopedSlots.before().concat(e)), e = mergeSlot(e, this, "after"), "__qtable" === this.type ? getTableMiddle(t, {
        staticClass: this.classes
      }, e) : t(comps[this.type], {
        class: this.classes,
        attrs: this.attrs,
        props: this.qAttrs,
        on: Object.assign({}, this.qListeners)
      }, e);
    }

    console.error("QVirtualScroll: default scoped slot is required for rendering", this);
  }
});

function sortDate(t, e) {
  return new Date(t) - new Date(e);
}

var Sort = {
  props: {
    sortMethod: {
      type: Function,
      default: function _default(t, e, i) {
        var s = this.columns.find(function (t) {
          return t.name === e;
        });
        if (void 0 === s || void 0 === s.field) return t;
        var n = !0 === i ? -1 : 1,
            o = "function" == typeof s.field ? function (t) {
          return s.field(t);
        } : function (t) {
          return t[s.field];
        };
        return t.sort(function (t, e) {
          var i,
              r = o(t),
              a = o(e);
          return null === r || void 0 === r ? -1 * n : null === a || void 0 === a ? 1 * n : void 0 !== s.sort ? s.sort(r, a, t, e) * n : !0 === isNumber(r) && !0 === isNumber(a) ? (r - a) * n : !0 === isDate(r) && !0 === isDate(a) ? sortDate(r, a) * n : "boolean" == typeof r && "boolean" == typeof a ? (r - a) * n : (r = (i = [r, a].map(function (t) {
            return (t + "").toLocaleString().toLowerCase();
          }))[0]) < (a = i[1]) ? -1 * n : r === a ? 0 : n;
        });
      }
    }
  },
  computed: {
    columnToSort: function columnToSort() {
      var t = this.computedPagination.sortBy;
      if (t) return this.columns.find(function (e) {
        return e.name === t;
      }) || null;
    }
  },
  methods: {
    sort: function sort(t) {
      t === Object(t) && (t = t.name);
      var e = this.computedPagination,
          i = e.sortBy,
          s = e.descending;
      i !== t ? (i = t, s = !1) : !0 === this.binaryStateSort ? s = !s : !0 === s ? i = null : s = !0, this.setPagination({
        sortBy: i,
        descending: s,
        page: 1
      });
    }
  }
},
    Filter = {
  props: {
    filter: [String, Object],
    filterMethod: {
      type: Function,
      default: function _default(t, e, i, s) {
        void 0 === i && (i = this.computedCols), void 0 === s && (s = this.getCellValue);
        var n = e ? e.toLowerCase() : "";
        return t.filter(function (t) {
          return i.some(function (e) {
            return -1 !== (s(e, t) + "").toLowerCase().indexOf(n);
          });
        });
      }
    }
  },
  watch: {
    filter: {
      handler: function handler() {
        var t = this;
        this.$nextTick(function () {
          t.setPagination({
            page: 1
          }, !0);
        });
      },
      deep: !0
    }
  }
};

function samePagination(t, e) {
  for (var i in e) {
    if (e[i] !== t[i]) return !1;
  }

  return !0;
}

function fixPagination(t) {
  return t.page < 1 && (t.page = 1), void 0 !== t.rowsPerPage && t.rowsPerPage < 1 && (t.rowsPerPage = 0), t;
}

var Pagination = {
  props: {
    pagination: Object,
    rowsPerPageOptions: {
      type: Array,
      default: function _default() {
        return [3, 5, 7, 10, 15, 20, 25, 50, 0];
      }
    }
  },
  computed: {
    computedPagination: function computedPagination() {
      return fixPagination(Object.assign({}, this.innerPagination, this.pagination));
    },
    firstRowIndex: function firstRowIndex() {
      var t = this.computedPagination;
      return (t.page - 1) * t.rowsPerPage;
    },
    lastRowIndex: function lastRowIndex() {
      var t = this.computedPagination;
      return t.page * t.rowsPerPage;
    },
    isFirstPage: function isFirstPage() {
      return 1 === this.computedPagination.page;
    },
    pagesNumber: function pagesNumber() {
      return 0 === this.computedPagination.rowsPerPage ? 1 : Math.max(1, Math.ceil(this.computedRowsNumber / this.computedPagination.rowsPerPage));
    },
    isLastPage: function isLastPage() {
      return 0 === this.lastRowIndex || this.computedPagination.page >= this.pagesNumber;
    },
    computedRowsPerPageOptions: function computedRowsPerPageOptions() {
      var t = this;
      return this.rowsPerPageOptions.map(function (e) {
        return {
          label: 0 === e ? t.$q.lang.table.allRows : "" + e,
          value: e
        };
      });
    }
  },
  watch: {
    pagesNumber: function pagesNumber(t, e) {
      if (t !== e) {
        var i = this.computedPagination.page;
        t && !i ? this.setPagination({
          page: 1
        }) : t < i && this.setPagination({
          page: t
        });
      }
    }
  },
  methods: {
    __sendServerRequest: function __sendServerRequest(t) {
      this.requestServerInteraction({
        pagination: t,
        filter: this.filter
      });
    },
    setPagination: function setPagination(t, e) {
      var i = fixPagination(Object.assign({}, this.computedPagination, t));
      samePagination(this.computedPagination, i) ? this.isServerSide && e && this.__sendServerRequest(i) : this.isServerSide ? this.__sendServerRequest(i) : this.pagination ? this.$emit("update:pagination", i) : this.innerPagination = i;
    },
    prevPage: function prevPage() {
      var t = this.computedPagination.page;
      t > 1 && this.setPagination({
        page: t - 1
      });
    },
    nextPage: function nextPage() {
      var t = this.computedPagination,
          e = t.page,
          i = t.rowsPerPage;
      this.lastRowIndex > 0 && e * i < this.computedRowsNumber && this.setPagination({
        page: e + 1
      });
    }
  },
  created: function created() {
    this.$emit("update:pagination", Object.assign({}, this.computedPagination));
  }
},
    RowSelection = {
  props: {
    selection: {
      type: String,
      default: "none",
      validator: function validator(t) {
        return ["single", "multiple", "none"].includes(t);
      }
    },
    selected: {
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  computed: {
    selectedKeys: function selectedKeys() {
      var t = {};
      return this.selected.map(this.getRowKey).forEach(function (e) {
        t[e] = !0;
      }), t;
    },
    hasSelectionMode: function hasSelectionMode() {
      return "none" !== this.selection;
    },
    singleSelection: function singleSelection() {
      return "single" === this.selection;
    },
    multipleSelection: function multipleSelection() {
      return "multiple" === this.selection;
    },
    allRowsSelected: function allRowsSelected() {
      var t = this;
      return this.computedRows.length > 0 && this.computedRows.every(function (e) {
        return !0 === t.selectedKeys[t.getRowKey(e)];
      });
    },
    someRowsSelected: function someRowsSelected() {
      var t = this;
      return !0 !== this.allRowsSelected && this.computedRows.some(function (e) {
        return !0 === t.selectedKeys[t.getRowKey(e)];
      });
    },
    rowsSelectedNumber: function rowsSelectedNumber() {
      return this.selected.length;
    }
  },
  methods: {
    isRowSelected: function isRowSelected(t) {
      return !0 === this.selectedKeys[t];
    },
    clearSelection: function clearSelection() {
      this.$emit("update:selected", []);
    },
    __updateSelection: function __updateSelection(t, e, i, s) {
      var n = this;
      this.$emit("selection", {
        rows: e,
        added: i,
        keys: t,
        evt: s
      });
      var o = !0 === this.singleSelection ? !0 === i ? e : [] : !0 === i ? this.selected.concat(e) : this.selected.filter(function (e) {
        return !1 === t.includes(n.getRowKey(e));
      });
      this.$emit("update:selected", o);
    }
  }
};

function getVal(t) {
  return Array.isArray(t) ? t.slice() : [];
}

var RowExpand = {
  props: {
    expanded: Array
  },
  data: function data() {
    return {
      innerExpanded: getVal(this.expanded)
    };
  },
  watch: {
    expanded: function expanded(t) {
      this.innerExpanded = getVal(t);
    }
  },
  methods: {
    isRowExpanded: function isRowExpanded(t) {
      return this.innerExpanded.includes(t);
    },
    setExpanded: function setExpanded(t) {
      void 0 !== this.expanded ? this.$emit("update:expanded", t) : this.innerExpanded = t;
    },
    __updateExpanded: function __updateExpanded(t, e) {
      var i = this.innerExpanded.slice(),
          s = i.indexOf(t);
      !0 === e ? -1 === s && (i.push(t), this.setExpanded(i)) : -1 !== s && (i.splice(s, 1), this.setExpanded(i));
    }
  }
},
    ColumnSelection = {
  props: {
    visibleColumns: Array
  },
  computed: {
    computedCols: function computedCols() {
      var t = this,
          e = this.computedPagination,
          i = e.sortBy,
          s = e.descending;
      return (void 0 !== this.visibleColumns ? this.columns.filter(function (e) {
        return !0 === e.required || !0 === t.visibleColumns.includes(e.name);
      }) : this.columns).map(function (t) {
        return t.align = t.align || "right", t.__iconClass = "q-table__sort-icon q-table__sort-icon--" + t.align, t.__thClass = "text-" + t.align + (void 0 !== t.headerClasses ? " " + t.headerClasses : "") + (!0 === t.sortable ? " sortable" : "") + (t.name === i ? " sorted " + (!0 === s ? "sort-desc" : "") : ""), t.__tdClass = "text-" + t.align + (void 0 !== t.classes ? " " + t.classes : ""), t.__thStyle = void 0 !== t.headerStyle ? t.headerStyle : null, t.__tdStyle = void 0 !== t.style ? t.style : null, t;
      });
    },
    computedColsMap: function computedColsMap() {
      var t = {};
      return this.computedCols.forEach(function (e) {
        t[e.name] = e;
      }), t;
    }
  }
},
    commonVirtPropsObj = {};
commonVirtPropsList.forEach(function (t) {
  commonVirtPropsObj[t] = {};
});
var QTable = vue_runtime_esm["a" /* default */].extend({
  name: "QTable",
  mixins: [DarkMixin, ListenersMixin, FullscreenMixin, Top, TableHeader, TableBody, Bottom, TableGrid, Sort, Filter, Pagination, RowSelection, RowExpand, ColumnSelection],
  props: Object.assign({}, {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    rowKey: {
      type: [String, Function],
      default: "id"
    },
    columns: Array,
    loading: Boolean,
    binaryStateSort: Boolean,
    title: String,
    hideHeader: Boolean,
    hideBottom: Boolean,
    grid: Boolean,
    gridHeader: Boolean,
    dense: Boolean,
    flat: Boolean,
    bordered: Boolean,
    square: Boolean,
    separator: {
      type: String,
      default: "horizontal",
      validator: function validator(t) {
        return ["horizontal", "vertical", "cell", "none"].includes(t);
      }
    },
    wrapCells: Boolean,
    virtualScroll: Boolean
  }, commonVirtPropsObj, {
    noDataLabel: String,
    noResultsLabel: String,
    loadingLabel: String,
    selectedRowsLabel: Function,
    rowsPerPageLabel: String,
    paginationLabel: Function,
    color: {
      type: String,
      default: "grey-8"
    },
    tableStyle: [String, Array, Object],
    tableClass: [String, Array, Object],
    tableHeaderStyle: [String, Array, Object],
    tableHeaderClass: [String, Array, Object],
    cardContainerClass: [String, Array, Object],
    cardContainerStyle: [String, Array, Object],
    cardStyle: [String, Array, Object],
    cardClass: [String, Array, Object]
  }),
  data: function data() {
    return {
      innerPagination: {
        sortBy: null,
        descending: !1,
        page: 1,
        rowsPerPage: 5
      }
    };
  },
  watch: {
    needsReset: function needsReset() {
      !0 === this.hasVirtScroll && void 0 !== this.$refs.virtScroll && this.$refs.virtScroll.reset();
    }
  },
  computed: {
    getRowKey: function getRowKey() {
      var t = this;
      return "function" == typeof this.rowKey ? this.rowKey : function (e) {
        return e[t.rowKey];
      };
    },
    hasVirtScroll: function hasVirtScroll() {
      return !0 !== this.grid && !0 === this.virtualScroll;
    },
    needsReset: function needsReset() {
      var t = this;
      return ["tableStyle", "tableClass", "tableHeaderStyle", "tableHeaderClass", "containerClass"].map(function (e) {
        return t[e];
      }).join(";");
    },
    filteredSortedRows: function filteredSortedRows() {
      var t = this.data;
      if (!0 === this.isServerSide || 0 === t.length) return t;
      var e = this.computedPagination,
          i = e.sortBy,
          s = e.descending;
      return this.filter && (t = this.filterMethod(t, this.filter, this.computedCols, this.getCellValue)), void 0 !== this.columnToSort && (t = this.sortMethod(this.data === t ? t.slice() : t, i, s)), t;
    },
    filteredSortedRowsNumber: function filteredSortedRowsNumber() {
      return this.filteredSortedRows.length;
    },
    computedRows: function computedRows() {
      var t = this.filteredSortedRows;
      return !0 === this.isServerSide ? t : (0 !== this.computedPagination.rowsPerPage && (0 === this.firstRowIndex && this.data !== t ? t.length > this.lastRowIndex && (t.length = this.lastRowIndex) : t = t.slice(this.firstRowIndex, this.lastRowIndex)), t);
    },
    computedRowsNumber: function computedRowsNumber() {
      return !0 === this.isServerSide ? this.computedPagination.rowsNumber || 0 : this.filteredSortedRowsNumber;
    },
    nothingToDisplay: function nothingToDisplay() {
      return 0 === this.computedRows.length;
    },
    isServerSide: function isServerSide() {
      return void 0 !== this.computedPagination.rowsNumber;
    },
    cardDefaultClass: function cardDefaultClass() {
      return " q-table__card" + (!0 === this.isDark ? " q-table__card--dark q-dark" : "") + (!0 === this.square ? " q-table--square" : "") + (!0 === this.flat ? " q-table--flat" : "") + (!0 === this.bordered ? " q-table--bordered" : "");
    },
    containerClass: function containerClass() {
      return "q-table__container q-table--" + this.separator + "-separator column no-wrap" + (!0 === this.loading ? " q-table--loading" : "") + (!0 === this.grid ? " q-table--grid" : this.cardDefaultClass) + (!0 === this.isDark ? " q-table--dark" : "") + (!0 === this.dense ? " q-table--dense" : "") + (!1 === this.wrapCells ? " q-table--no-wrap" : "") + (!0 === this.inFullscreen ? " fullscreen scroll" : "");
    },
    virtProps: function virtProps() {
      var t = this,
          e = {};
      return commonVirtPropsList.forEach(function (i) {
        e[i] = t[i];
      }), void 0 === e.virtualScrollItemSize && (e.virtualScrollItemSize = !0 === this.dense ? 28 : 48), e;
    }
  },
  render: function render(t) {
    var e = [this.getTop(t)],
        i = {
      staticClass: this.containerClass
    };
    return !0 === this.grid ? e.push(this.getGridHeader(t)) : Object.assign(i, {
      class: this.cardClass,
      style: this.cardStyle
    }), e.push(this.getBody(t), this.getBottom(t)), !0 === this.loading && void 0 !== this.$scopedSlots.loading && e.push(this.$scopedSlots.loading()), t("div", i, e);
  },
  methods: {
    requestServerInteraction: function requestServerInteraction(t) {
      var e = this;
      void 0 === t && (t = {}), this.$nextTick(function () {
        e.$emit("request", {
          pagination: t.pagination || e.computedPagination,
          filter: t.filter || e.filter,
          getCellValue: e.getCellValue
        });
      });
    },
    resetVirtualScroll: function resetVirtualScroll() {
      !0 === this.hasVirtScroll && this.$refs.virtScroll.reset();
    },
    getBody: function getBody(t) {
      if (!0 === this.grid) return this.getGridBody(t);
      var e = !0 !== this.hideHeader ? this.getTableHeader(t) : null;
      return !0 === this.hasVirtScroll ? t(QVirtualScroll, {
        ref: "virtScroll",
        props: Object.assign({}, this.virtProps, {
          items: this.computedRows,
          type: "__qtable"
        }),
        on: cache(this, "vs", {
          "virtual-scroll": this.__onVScroll
        }),
        class: this.tableClass,
        style: this.tableStyle,
        scopedSlots: {
          before: null === e ? void 0 : function () {
            return e;
          },
          default: this.getTableRowVirtual(t)
        }
      }) : getTableMiddle(t, {
        staticClass: "scroll",
        class: this.tableClass,
        style: this.tableStyle
      }, [e, this.getTableBody(t)]);
    },
    scrollTo: function scrollTo(t) {
      if (void 0 === this.$refs.virtScroll) {
        t = parseInt(t, 10);
        var e = this.$el.querySelector("tbody tr:nth-of-type(" + (t + 1) + ")");

        if (null !== e) {
          var i = this.$el.querySelector(".q-table__middle.scroll"),
              s = e.offsetTop,
              n = s < i.scrollTop ? "decrease" : "increase";
          i.scrollTop = s, this.$emit("virtual-scroll", {
            index: t,
            from: 0,
            to: this.pagination.rowsPerPage - 1,
            direction: n
          });
        }
      } else this.$refs.virtScroll.scrollTo(t);
    },
    __onVScroll: function __onVScroll(t) {
      this.$emit("virtual-scroll", t);
    },
    __getProgress: function __getProgress(t) {
      return [t(QLinearProgress, {
        staticClass: "q-table__linear-progress",
        props: {
          color: this.color,
          dark: this.isDark,
          indeterminate: !0,
          trackColor: "transparent"
        }
      })];
    }
  }
}),
    QTr = vue_runtime_esm["a" /* default */].extend({
  name: "QTr",
  mixins: [ListenersMixin],
  props: {
    props: Object,
    noHover: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-tr" + (void 0 === this.props || !0 === this.props.header ? "" : " " + this.props.__trClass) + (!0 === this.noHover ? " q-tr--no-hover" : "");
    }
  },
  render: function render(t) {
    return t("tr", {
      on: Object.assign({}, this.qListeners),
      class: this.classes
    }, slot(this, "default"));
  }
}),
    QTd = vue_runtime_esm["a" /* default */].extend({
  name: "QTd",
  mixins: [ListenersMixin],
  props: {
    props: Object,
    autoWidth: Boolean,
    noHover: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-td" + (!0 === this.autoWidth ? " q-table--col-auto-width" : "") + (!0 === this.noHover ? " q-td--no-hover" : "");
    }
  },
  render: function render(t) {
    var e = this.qListeners;
    if (void 0 === this.props) return t("td", {
      on: e,
      class: this.classes
    }, slot(this, "default"));
    var i = this.$vnode.key,
        s = void 0 !== this.props.colsMap && i ? this.props.colsMap[i] : this.props.col;
    return void 0 !== s ? t("td", {
      on: e,
      style: s.__tdStyle,
      class: this.classes + " " + s.__tdClass
    }, slot(this, "default")) : void 0;
  }
}),
    trailingSlashRE = /\/?$/;

function queryIncludes(t, e) {
  for (var i in e) {
    if (!(i in t)) return !1;
  }

  return !0;
}

function isSameRoute(t, e) {
  return !!e && (t.path && e.path ? t.path.replace(trailingSlashRE, "") === e.path.replace(trailingSlashRE, "") && t.hash === e.hash && isDeepEqual(t.query, e.query) : !(!t.name || !e.name) && t.name === e.name && t.hash === e.hash && isDeepEqual(t.query, e.query) && isDeepEqual(t.params, e.params));
}

function isIncludedRoute(t, e) {
  return 0 === t.path.replace(trailingSlashRE, "/").indexOf(e.path.replace(trailingSlashRE, "/")) && (!e.hash || t.hash === e.hash) && queryIncludes(t.query, e.query);
}

var QRouteTab = vue_runtime_esm["a" /* default */].extend({
  name: "QRouteTab",
  mixins: [QTab, RouterLinkMixin],
  props: {
    to: {
      required: !0
    }
  },
  inject: {
    __activateRoute: {},
    __recalculateScroll: {}
  },
  watch: {
    $route: function $route() {
      this.__checkActivation();
    }
  },
  methods: {
    __activate: function __activate(t, e) {
      !0 !== this.disable && this.__checkActivation(!0), !0 === e ? this.$el.focus(t) : void 0 !== this.$refs.blurTarget && this.$refs.blurTarget.focus(t);
    },
    __checkActivation: function __checkActivation(t) {
      void 0 === t && (t = !1);
      var e = this.$route,
          i = this.$router.resolve(this.to, e, this.append),
          s = i.href,
          n = i.location,
          o = i.route,
          r = void 0 !== o.redirectedFrom,
          a = !0 === this.exact ? isSameRoute : isIncludedRoute,
          l = {
        name: this.name,
        selected: t,
        exact: this.exact,
        priorityMatched: o.matched.length,
        priorityHref: s.length
      };
      a(e, o) && this.__activateRoute(Object.assign({}, l, {
        redirected: r
      })), !0 === r && a(e, Object.assign({}, {
        path: o.redirectedFrom
      }, n)) && this.__activateRoute(l), this.isActive && this.__activateRoute();
    }
  },
  mounted: function mounted() {
    this.__recalculateScroll(), void 0 !== this.$router && this.__checkActivation();
  },
  beforeDestroy: function beforeDestroy() {
    this.__recalculateScroll(), this.__activateRoute({
      remove: !0,
      name: this.name
    });
  },
  render: function render(t) {
    return this.__renderTab(t, "router-link", this.routerLinkProps);
  }
}),
    QTime = vue_runtime_esm["a" /* default */].extend({
  name: "QTime",
  mixins: [DateTimeMixin],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    mask: {
      default: null
    },
    format24h: {
      type: Boolean,
      default: null
    },
    defaultDate: {
      type: String,
      validator: function validator(t) {
        return /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(t);
      }
    },
    options: Function,
    hourOptions: Array,
    minuteOptions: Array,
    secondOptions: Array,
    withSeconds: Boolean,
    nowBtn: Boolean
  },
  data: function data() {
    var t = __splitDate(this.value, this.__getComputedMask(), this.__getComputedLocale(), this.calendar, this.__getDefaultDateModel()),
        e = "Hour";

    return null !== t.hour && (null === t.minute ? e = "Minute" : !0 === this.withSeconds && null === t.second && (e = "Second")), {
      view: e,
      isAM: null === t.hour || t.hour < 12,
      innerModel: t
    };
  },
  watch: {
    value: function value(t) {
      var e = __splitDate(t, this.computedMask, this.computedLocale, this.calendar, this.defaultDateModel);

      e.dateHash === this.innerModel.dateHash && e.timeHash === this.innerModel.timeHash || (this.innerModel = e, null === e.hour ? this.view = "Hour" : this.isAM = e.hour < 12);
    }
  },
  computed: {
    classes: function classes() {
      return "q-time q-time--" + (!0 === this.landscape ? "landscape" : "portrait") + (!0 === this.isDark ? " q-time--dark q-dark" : "") + (!0 === this.disable ? " disabled" : !0 === this.readonly ? " q-time--readonly" : "") + (!0 === this.bordered ? " q-time--bordered" : "") + (!0 === this.square ? " q-time--square no-border-radius" : "") + (!0 === this.flat ? " q-time--flat no-shadow" : "");
    },
    computedMask: function computedMask() {
      return this.__getComputedMask();
    },
    stringModel: function stringModel() {
      var t = this.innerModel;
      return {
        hour: null === t.hour ? "--" : !0 === this.computedFormat24h ? pad(t.hour) : String(!0 === this.isAM ? 0 === t.hour ? 12 : t.hour : t.hour > 12 ? t.hour - 12 : t.hour),
        minute: null === t.minute ? "--" : pad(t.minute),
        second: null === t.second ? "--" : pad(t.second)
      };
    },
    defaultDateModel: function defaultDateModel() {
      return this.__getDefaultDateModel();
    },
    computedFormat24h: function computedFormat24h() {
      return null !== this.format24h ? this.format24h : this.$q.lang.date.format24h;
    },
    pointerStyle: function pointerStyle() {
      var t = "Hour" === this.view,
          e = !0 === t ? 12 : 60,
          i = this.innerModel[this.view.toLowerCase()],
          s = "rotate(" + (Math.round(i * (360 / e)) - 180) + "deg) translateX(-50%)";
      return !0 === t && !0 === this.computedFormat24h && this.innerModel.hour >= 12 && (s += " scale(.7)"), {
        transform: s
      };
    },
    minLink: function minLink() {
      return null !== this.innerModel.hour;
    },
    secLink: function secLink() {
      return !0 === this.minLink && null !== this.innerModel.minute;
    },
    hourInSelection: function hourInSelection() {
      var t = this;
      return void 0 !== this.hourOptions ? function (e) {
        return t.hourOptions.includes(e);
      } : void 0 !== this.options ? function (e) {
        return t.options(e, null, null);
      } : void 0;
    },
    minuteInSelection: function minuteInSelection() {
      var t = this;
      return void 0 !== this.minuteOptions ? function (e) {
        return t.minuteOptions.includes(e);
      } : void 0 !== this.options ? function (e) {
        return t.options(t.innerModel.hour, e, null);
      } : void 0;
    },
    secondInSelection: function secondInSelection() {
      var t = this;
      return void 0 !== this.secondOptions ? function (e) {
        return t.secondOptions.includes(e);
      } : void 0 !== this.options ? function (e) {
        return t.options(t.innerModel.hour, t.innerModel.minute, e);
      } : void 0;
    },
    positions: function positions() {
      var t,
          e,
          i,
          s = 0,
          n = 1;
      "Hour" === this.view ? (i = this.hourInSelection, !0 === this.computedFormat24h ? (t = 0, e = 23) : (t = 0, e = 11, !1 === this.isAM && (s = 12))) : (t = 0, e = 55, n = 5, i = "Minute" === this.view ? this.minuteInSelection : this.secondInSelection);

      for (var o = [], r = t, a = t; r <= e; r += n, a++) {
        var l = r + s,
            c = void 0 !== i && !1 === i(l),
            u = "Hour" === this.view && 0 === r ? !0 === this.format24h ? "00" : "12" : r;
        o.push({
          val: l,
          index: a,
          disable: c,
          label: u
        });
      }

      return o;
    }
  },
  methods: {
    setNow: function setNow() {
      this.__updateValue(Object.assign({}, this.__getCurrentDate(), this.__getCurrentTime())), this.view = "Hour";
    },
    __getDefaultDateModel: function __getDefaultDateModel() {
      if ("string" != typeof this.defaultDate) {
        var t = this.__getCurrentDate();

        return t.dateHash = t.year + "/" + pad(t.month) + "/" + pad(t.day), t;
      }

      return __splitDate(this.defaultDate, "YYYY/MM/DD", void 0, this.calendar);
    },
    __click: function __click(t) {
      !0 !== this._isBeingDestroyed && !0 !== this._isDestroyed && (!0 !== this.$q.platform.is.desktop && this.__updateClock(t, this.__getClockRect()), this.__goToNextView());
    },
    __activate: function __activate(t) {
      !0 !== this._isBeingDestroyed && !0 !== this._isDestroyed && this.__updateClock(t, this.__getClockRect());
    },
    __getClockRect: function __getClockRect() {
      var t = this.$refs.clock.getBoundingClientRect(),
          e = t.top,
          i = t.left,
          s = t.width / 2;
      return {
        top: e + s,
        left: i + s,
        dist: .7 * s
      };
    },
    __goToNextView: function __goToNextView() {
      "Hour" === this.view ? this.view = "Minute" : this.withSeconds && "Minute" === this.view && (this.view = "Second");
    },
    __drag: function __drag(t) {
      if (!0 !== this._isBeingDestroyed && !0 !== this._isDestroyed) {
        if (!0 === t.isFirst) return this.draggingClockRect = this.__getClockRect(), void (this.dragCache = this.__updateClock(t.evt, this.draggingClockRect));
        this.dragCache = this.__updateClock(t.evt, this.draggingClockRect, this.dragCache), !0 === t.isFinal && (this.draggingClockRect = !1, this.dragCache = null, this.__goToNextView());
      }
    },
    __updateClock: function __updateClock(t, e, i) {
      var s,
          n = position(t),
          o = Math.abs(n.top - e.top),
          r = Math.sqrt(Math.pow(Math.abs(n.top - e.top), 2) + Math.pow(Math.abs(n.left - e.left), 2)),
          a = Math.asin(o / r) * (180 / Math.PI);
      if (a = n.top < e.top ? e.left < n.left ? 90 - a : 270 + a : e.left < n.left ? a + 90 : 270 - a, "Hour" === this.view ? (s = Math.round(a / 30), !0 === this.computedFormat24h ? (r < e.dist ? s < 12 && (s += 12) : 12 === s && (s = 0), this.isAM = s < 12) : !0 === this.isAM && 12 === s ? s = 0 : !1 === this.isAM && 12 !== s && (s += 12)) : 60 === (s = Math.round(a / 6)) && (s = 0), i === s) return s;
      var l = this[this.view.toLowerCase() + "InSelection"];
      return void 0 === l || !0 === l(s) ? (this["__set" + this.view](s), s) : void 0;
    },
    __onKeyupHour: function __onKeyupHour(t) {
      if (13 === t.keyCode) this.view = "Hour";else {
        var e = !0 === this.computedFormat24h ? 24 : 12,
            i = !0 !== this.computedFormat24h && !1 === this.isAM ? 12 : 0;
        37 === t.keyCode ? this.__setHour(i + (24 + this.innerModel.hour - 1) % e) : 39 === t.keyCode && this.__setHour(i + (24 + this.innerModel.hour + 1) % e);
      }
    },
    __onKeyupMinute: function __onKeyupMinute(t) {
      13 === t.keyCode ? this.view = "Minute" : 37 === t.keyCode ? this.__setMinute((60 + this.innerModel.minute - 1) % 60) : 39 === t.keyCode && this.__setMinute((60 + this.innerModel.minute + 1) % 60);
    },
    __onKeyupSecond: function __onKeyupSecond(t) {
      13 === t.keyCode ? this.view = "Second" : 37 === t.keyCode ? this.__setSecond((60 + this.innerModel.second - 1) % 60) : 39 === t.keyCode && this.__setSecond((60 + this.innerModel.second + 1) % 60);
    },
    __getHeader: function __getHeader(t) {
      var e = this,
          i = [t("div", {
        staticClass: "q-time__link",
        class: "Hour" === this.view ? "q-time__link--active" : "cursor-pointer",
        attrs: {
          tabindex: this.computedTabindex
        },
        on: cache(this, "vH", {
          click: function click() {
            e.view = "Hour";
          },
          keyup: this.__onKeyupHour
        })
      }, [this.stringModel.hour]), t("div", [":"]), t("div", !0 === this.minLink ? {
        staticClass: "q-time__link",
        class: "Minute" === this.view ? "q-time__link--active" : "cursor-pointer",
        attrs: {
          tabindex: this.computedTabindex
        },
        on: cache(this, "vM", {
          click: function click() {
            e.view = "Minute";
          },
          keyup: this.__onKeyupMinute
        })
      } : {
        staticClass: "q-time__link"
      }, [this.stringModel.minute])];
      return !0 === this.withSeconds && i.push(t("div", [":"]), t("div", !0 === this.secLink ? {
        staticClass: "q-time__link",
        class: "Second" === this.view ? "q-time__link--active" : "cursor-pointer",
        attrs: {
          tabindex: this.computedTabindex
        },
        on: cache(this, "vS", {
          click: function click() {
            e.view = "Second";
          },
          keyup: this.__onKeyupSecond
        })
      } : {
        staticClass: "q-time__link"
      }, [this.stringModel.second])), t("div", {
        staticClass: "q-time__header flex flex-center no-wrap",
        class: this.headerClass
      }, [t("div", {
        staticClass: "q-time__header-label row items-center no-wrap",
        attrs: {
          dir: "ltr"
        }
      }, i), !1 === this.computedFormat24h ? t("div", {
        staticClass: "q-time__header-ampm column items-between no-wrap"
      }, [t("div", {
        staticClass: "q-time__link",
        class: !0 === this.isAM ? "q-time__link--active" : "cursor-pointer",
        attrs: {
          tabindex: this.computedTabindex
        },
        on: cache(this, "AM", {
          click: this.__setAm,
          keyup: function keyup(t) {
            13 === t.keyCode && e.__setAm();
          }
        })
      }, ["AM"]), t("div", {
        staticClass: "q-time__link",
        class: !0 !== this.isAM ? "q-time__link--active" : "cursor-pointer",
        attrs: {
          tabindex: this.computedTabindex
        },
        on: cache(this, "PM", {
          click: this.__setPm,
          keyup: function keyup(t) {
            13 === t.keyCode && e.__setPm();
          }
        })
      }, ["PM"])]) : null]);
    },
    __getClock: function __getClock(t) {
      var e = this,
          i = this.view.toLowerCase(),
          s = this.innerModel[i];
      return t("div", {
        staticClass: "q-time__content col relative-position"
      }, [t("transition", {
        props: {
          name: "q-transition--scale"
        }
      }, [t("div", {
        key: "clock" + this.view,
        staticClass: "q-time__container-parent absolute-full"
      }, [t("div", {
        ref: "clock",
        staticClass: "q-time__container-child fit overflow-hidden"
      }, [t("div", {
        staticClass: "q-time__clock cursor-pointer non-selectable",
        on: cache(this, "click", {
          click: this.__click,
          mousedown: this.__activate
        }),
        directives: cache(this, "touch", [{
          name: "touch-pan",
          value: this.__drag,
          modifiers: {
            stop: !0,
            prevent: !0,
            mouse: !0
          }
        }])
      }, [t("div", {
        staticClass: "q-time__clock-circle fit"
      }, [t("div", {
        staticClass: "q-time__clock-pointer",
        style: this.pointerStyle,
        class: null === this.innerModel[i] ? "hidden" : void 0 !== this.color ? "text-" + this.color : ""
      }), this.positions.map(function (i) {
        return t("div", {
          staticClass: "q-time__clock-position row flex-center q-time__clock-pos-" + i.index,
          class: i.val === s ? e.headerClass.concat(" q-time__clock-position--active") : !0 === i.disable ? "q-time__clock-position--disable" : null
        }, [t("span", [i.label])]);
      })])])])])]), !0 === this.nowBtn ? t(QBtn, {
        staticClass: "q-time__now-button absolute",
        props: {
          icon: this.$q.iconSet.datetime.now,
          unelevated: !0,
          size: "sm",
          round: !0,
          color: this.color,
          textColor: this.textColor,
          tabindex: this.computedTabindex
        },
        on: cache(this, "now", {
          click: this.setNow
        })
      }) : null]);
    },
    __setHour: function __setHour(t) {
      this.innerModel.hour !== t && (this.innerModel.hour = t, this.innerModel.minute = null, this.innerModel.second = null);
    },
    __setMinute: function __setMinute(t) {
      this.innerModel.minute !== t && (this.innerModel.minute = t, this.innerModel.second = null, !0 !== this.withSeconds && this.__updateValue({
        minute: t
      }));
    },
    __setSecond: function __setSecond(t) {
      this.innerModel.second !== t && this.__updateValue({
        second: t
      });
    },
    __setAm: function __setAm() {
      this.isAM || (this.isAM = !0, null !== this.innerModel.hour && (this.innerModel.hour -= 12, this.__verifyAndUpdate()));
    },
    __setPm: function __setPm() {
      this.isAM && (this.isAM = !1, null !== this.innerModel.hour && (this.innerModel.hour += 12, this.__verifyAndUpdate()));
    },
    __verifyAndUpdate: function __verifyAndUpdate() {
      return void 0 !== this.hourInSelection && !0 !== this.hourInSelection(this.innerModel.hour) ? (this.innerModel = __splitDate(), this.isAM = !0, void (this.view = "Hour")) : void 0 !== this.minuteInSelection && !0 !== this.minuteInSelection(this.innerModel.minute) ? (this.innerModel.minute = null, this.innerModel.second = null, void (this.view = "Minute")) : !0 === this.withSeconds && void 0 !== this.secondInSelection && !0 !== this.secondInSelection(this.innerModel.second) ? (this.innerModel.second = null, void (this.view = "Second")) : void (null === this.innerModel.hour || null === this.innerModel.minute || !0 === this.withSeconds && null === this.innerModel.second || this.__updateValue({}));
    },
    __getComputedMask: function __getComputedMask() {
      return "persian" !== this.calendar && null !== this.mask ? this.mask : "HH:mm" + (!0 === this.withSeconds ? ":ss" : "");
    },
    __updateValue: function __updateValue(t) {
      var e = Object.assign({}, this.innerModel, t),
          i = "persian" === this.calendar ? pad(e.hour) + ":" + pad(e.minute) + (!0 === this.withSeconds ? ":" + pad(e.second) : "") : formatDate(new Date(e.year, null === e.month ? null : e.month - 1, e.day, e.hour, e.minute, e.second, e.millisecond), this.computedMask, this.computedLocale, e.year, e.timezoneOffset);
      e.changed = i !== this.value, this.$emit("input", i, e);
    }
  },
  render: function render(t) {
    var e = [this.__getClock(t)],
        i = slot(this, "default");
    return void 0 !== i && e.push(t("div", {
      staticClass: "q-time__actions"
    }, i)), void 0 !== this.name && !0 !== this.disable && this.__injectFormInput(e, "push"), t("div", {
      class: this.classes,
      on: Object.assign({}, this.qListeners),
      attrs: {
        tabindex: -1
      }
    }, [this.__getHeader(t), t("div", {
      staticClass: "q-time__main col overflow-auto"
    }, e)]);
  }
}),
    QTimeline = vue_runtime_esm["a" /* default */].extend({
  name: "QTimeline",
  mixins: [DarkMixin, ListenersMixin],
  provide: function provide() {
    return {
      __timeline: this
    };
  },
  props: {
    color: {
      type: String,
      default: "primary"
    },
    side: {
      type: String,
      default: "right",
      validator: function validator(t) {
        return ["left", "right"].includes(t);
      }
    },
    layout: {
      type: String,
      default: "dense",
      validator: function validator(t) {
        return ["dense", "comfortable", "loose"].includes(t);
      }
    }
  },
  computed: {
    classes: function classes() {
      return "q-timeline--" + this.layout + " q-timeline--" + this.layout + "--" + this.side + (!0 === this.isDark ? " q-timeline--dark" : "");
    }
  },
  render: function render(t) {
    return t("ul", {
      staticClass: "q-timeline",
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QTimelineEntry = vue_runtime_esm["a" /* default */].extend({
  name: "QTimelineEntry",
  inject: {
    __timeline: {
      default: function _default() {
        console.error("QTimelineEntry needs to be child of QTimeline");
      }
    }
  },
  mixins: [ListenersMixin],
  props: {
    heading: Boolean,
    tag: {
      type: String,
      default: "h3"
    },
    side: {
      type: String,
      default: "right",
      validator: function validator(t) {
        return ["left", "right"].includes(t);
      }
    },
    icon: String,
    avatar: String,
    color: String,
    title: String,
    subtitle: String,
    body: String
  },
  computed: {
    colorClass: function colorClass() {
      return "text-" + (this.color || this.__timeline.color);
    },
    classes: function classes() {
      return "q-timeline__entry--" + this.side + (void 0 !== this.icon || void 0 !== this.avatar ? " q-timeline__entry--icon" : "");
    },
    reverse: function reverse() {
      return "comfortable" === this.__timeline.layout && "left" === this.__timeline.side;
    }
  },
  render: function render(t) {
    var e,
        i = uniqueSlot(this, "default", []);

    if (void 0 !== this.body && i.unshift(this.body), !0 === this.heading) {
      var s = [t("div"), t("div"), t(this.tag, {
        staticClass: "q-timeline__heading-title"
      }, i)];
      return t("div", {
        staticClass: "q-timeline__heading",
        on: Object.assign({}, this.qListeners)
      }, !0 === this.reverse ? s.reverse() : s);
    }

    void 0 !== this.icon ? e = [t(QIcon, {
      staticClass: "row items-center justify-center",
      props: {
        name: this.icon
      }
    })] : void 0 !== this.avatar && (e = [t("img", {
      staticClass: "q-timeline__dot-img",
      domProps: {
        src: this.avatar
      }
    })]);
    var n = [t("div", {
      staticClass: "q-timeline__subtitle"
    }, [t("span", slot(this, "subtitle", [this.subtitle]))]), t("div", {
      staticClass: "q-timeline__dot",
      class: this.colorClass
    }, e), t("div", {
      staticClass: "q-timeline__content"
    }, [t("h6", {
      staticClass: "q-timeline__title"
    }, slot(this, "title", [this.title]))].concat(i))];
    return t("li", {
      staticClass: "q-timeline__entry",
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, !0 === this.reverse ? n.reverse() : n);
  }
}),
    QToolbar = vue_runtime_esm["a" /* default */].extend({
  name: "QToolbar",
  mixins: [ListenersMixin],
  props: {
    inset: Boolean
  },
  render: function render(t) {
    return t("div", {
      staticClass: "q-toolbar row no-wrap items-center",
      class: this.inset ? "q-toolbar--inset" : null,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QToolbarTitle = vue_runtime_esm["a" /* default */].extend({
  name: "QToolbarTitle",
  mixins: [ListenersMixin],
  props: {
    shrink: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-toolbar__title ellipsis" + (!0 === this.shrink ? " col-shrink" : "");
    }
  },
  render: function render(t) {
    return t("div", {
      class: this.classes,
      on: Object.assign({}, this.qListeners)
    }, slot(this, "default"));
  }
}),
    QTree = vue_runtime_esm["a" /* default */].extend({
  name: "QTree",
  mixins: [DarkMixin],
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    nodeKey: {
      type: String,
      required: !0
    },
    labelKey: {
      type: String,
      default: "label"
    },
    childrenKey: {
      type: String,
      default: "children"
    },
    color: String,
    controlColor: String,
    textColor: String,
    selectedColor: String,
    icon: String,
    tickStrategy: {
      type: String,
      default: "none",
      validator: function validator(t) {
        return ["none", "strict", "leaf", "leaf-filtered"].includes(t);
      }
    },
    ticked: Array,
    expanded: Array,
    selected: {},
    defaultExpandAll: Boolean,
    accordion: Boolean,
    filter: String,
    filterMethod: {
      type: Function,
      default: function _default(t, e) {
        var i = e.toLowerCase();
        return t[this.labelKey] && t[this.labelKey].toLowerCase().indexOf(i) > -1;
      }
    },
    duration: Number,
    noConnectors: Boolean,
    noNodesLabel: String,
    noResultsLabel: String
  },
  computed: {
    classes: function classes() {
      return "q-tree" + (!0 === this.noConnectors ? " q-tree--no-connectors" : "") + (!0 === this.isDark ? " q-tree--dark" : "") + (void 0 !== this.color ? " text-" + this.color : "");
    },
    hasSelection: function hasSelection() {
      return void 0 !== this.selected;
    },
    computedIcon: function computedIcon() {
      return this.icon || this.$q.iconSet.tree.icon;
    },
    computedControlColor: function computedControlColor() {
      return this.controlColor || this.color;
    },
    textColorClass: function textColorClass() {
      if (void 0 !== this.textColor) return "text-" + this.textColor;
    },
    selectedColorClass: function selectedColorClass() {
      var t = this.selectedColor || this.color;
      if (t) return "text-" + t;
    },
    meta: function meta() {
      var t = this,
          e = {},
          i = function i(s, n) {
        var o = s.tickStrategy || (n ? n.tickStrategy : t.tickStrategy),
            r = s[t.nodeKey],
            a = s[t.childrenKey] && s[t.childrenKey].length > 0,
            l = !0 !== a,
            c = !0 !== s.disabled && !0 === t.hasSelection && !1 !== s.selectable,
            u = !0 !== s.disabled && !1 !== s.expandable,
            h = "none" !== o,
            d = "strict" === o,
            p = "leaf-filtered" === o,
            f = "leaf" === o || "leaf-filtered" === o,
            m = !0 !== s.disabled && !1 !== s.tickable;
        !0 === f && !0 === m && n && !0 !== n.tickable && (m = !1);
        var v = s.lazy;
        v && t.lazy[r] && (v = t.lazy[r]);
        var g = {
          key: r,
          parent: n,
          isParent: a,
          isLeaf: l,
          lazy: v,
          disabled: s.disabled,
          link: !0 !== s.disabled && (!0 === c || !0 === u && (!0 === a || !0 === v)),
          children: [],
          matchesFilter: !t.filter || t.filterMethod(s, t.filter),
          selected: r === t.selected && !0 === c,
          selectable: c,
          expanded: !0 === a && t.innerExpanded.includes(r),
          expandable: u,
          noTick: !0 === s.noTick || !0 !== d && v && "loaded" !== v,
          tickable: m,
          tickStrategy: o,
          hasTicking: h,
          strictTicking: d,
          leafFilteredTicking: p,
          leafTicking: f,
          ticked: !0 === d ? t.innerTicked.includes(r) : !0 === l && t.innerTicked.includes(r)
        };

        if (e[r] = g, !0 === a && (g.children = s[t.childrenKey].map(function (t) {
          return i(t, g);
        }), t.filter && (!0 !== g.matchesFilter ? g.matchesFilter = g.children.some(function (t) {
          return t.matchesFilter;
        }) : !0 !== g.noTick && !0 !== g.disabled && !0 === g.tickable && !0 === p && !0 === g.children.every(function (t) {
          return !0 !== t.matchesFilter || !0 === t.noTick || !0 !== t.tickable;
        }) && (g.tickable = !1)), !0 === g.matchesFilter && (!0 !== g.noTick && !0 !== d && !0 === g.children.every(function (t) {
          return t.noTick;
        }) && (g.noTick = !0), f))) {
          if (g.ticked = !1, g.indeterminate = g.children.some(function (t) {
            return !0 === t.indeterminate;
          }), g.tickable = !0 === g.tickable && g.children.some(function (t) {
            return t.tickable;
          }), !0 !== g.indeterminate) {
            var _ = g.children.reduce(function (t, e) {
              return !0 === e.ticked ? t + 1 : t;
            }, 0);

            _ === g.children.length ? g.ticked = !0 : _ > 0 && (g.indeterminate = !0);
          }

          !0 === g.indeterminate && (g.indeterminateNextState = g.children.every(function (t) {
            return !0 !== t.tickable || !0 !== t.ticked;
          }));
        }

        return g;
      };

      return this.nodes.forEach(function (t) {
        return i(t, null);
      }), e;
    }
  },
  data: function data() {
    return {
      lazy: {},
      innerTicked: this.ticked || [],
      innerExpanded: this.expanded || []
    };
  },
  watch: {
    ticked: function ticked(t) {
      this.innerTicked = t;
    },
    expanded: function expanded(t) {
      this.innerExpanded = t;
    }
  },
  methods: {
    getNodeByKey: function getNodeByKey(t) {
      var e = this,
          i = [].reduce,
          s = function s(n, o) {
        return n || !o ? n : !0 === Array.isArray(o) ? i.call(Object(o), s, n) : o[e.nodeKey] === t ? o : o[e.childrenKey] ? s(null, o[e.childrenKey]) : void 0;
      };

      return s(null, this.nodes);
    },
    getTickedNodes: function getTickedNodes() {
      var t = this;
      return this.innerTicked.map(function (e) {
        return t.getNodeByKey(e);
      });
    },
    getExpandedNodes: function getExpandedNodes() {
      var t = this;
      return this.innerExpanded.map(function (e) {
        return t.getNodeByKey(e);
      });
    },
    isExpanded: function isExpanded(t) {
      return !(!t || !this.meta[t]) && this.meta[t].expanded;
    },
    collapseAll: function collapseAll() {
      void 0 !== this.expanded ? this.$emit("update:expanded", []) : this.innerExpanded = [];
    },
    expandAll: function expandAll() {
      var t = this,
          e = this.innerExpanded,
          i = function i(s) {
        s[t.childrenKey] && s[t.childrenKey].length > 0 && !1 !== s.expandable && !0 !== s.disabled && (e.push(s[t.nodeKey]), s[t.childrenKey].forEach(i));
      };

      this.nodes.forEach(i), void 0 !== this.expanded ? this.$emit("update:expanded", e) : this.innerExpanded = e;
    },
    setExpanded: function setExpanded(t, e, i, s) {
      var n = this;

      if (void 0 === i && (i = this.getNodeByKey(t)), void 0 === s && (s = this.meta[t]), s.lazy && "loaded" !== s.lazy) {
        if ("loading" === s.lazy) return;
        this.$set(this.lazy, t, "loading"), this.$emit("lazy-load", {
          node: i,
          key: t,
          done: function done(e) {
            n.lazy[t] = "loaded", e && n.$set(i, n.childrenKey, e), n.$nextTick(function () {
              var e = n.meta[t];
              e && !0 === e.isParent && n.__setExpanded(t, !0);
            });
          },
          fail: function fail() {
            n.$delete(n.lazy, t);
          }
        });
      } else !0 === s.isParent && !0 === s.expandable && this.__setExpanded(t, e);
    },
    __setExpanded: function __setExpanded(t, e) {
      var i = this,
          s = this.innerExpanded,
          n = void 0 !== this.expanded;

      if (!0 === n && (s = s.slice()), e) {
        if (this.accordion && this.meta[t]) {
          var o = [];
          this.meta[t].parent ? this.meta[t].parent.children.forEach(function (e) {
            e.key !== t && !0 === e.expandable && o.push(e.key);
          }) : this.nodes.forEach(function (e) {
            var s = e[i.nodeKey];
            s !== t && o.push(s);
          }), o.length > 0 && (s = s.filter(function (t) {
            return !1 === o.includes(t);
          }));
        }

        s = s.concat([t]).filter(function (t, e, i) {
          return i.indexOf(t) === e;
        });
      } else s = s.filter(function (e) {
        return e !== t;
      });

      !0 === n ? this.$emit("update:expanded", s) : this.innerExpanded = s;
    },
    isTicked: function isTicked(t) {
      return !(!t || !this.meta[t]) && this.meta[t].ticked;
    },
    setTicked: function setTicked(t, e) {
      var i = this.innerTicked,
          s = void 0 !== this.ticked;
      !0 === s && (i = i.slice()), i = e ? i.concat(t).filter(function (t, e, i) {
        return i.indexOf(t) === e;
      }) : i.filter(function (e) {
        return !1 === t.includes(e);
      }), !0 === s && this.$emit("update:ticked", i);
    },
    __getSlotScope: function __getSlotScope(t, e, i) {
      var s = this,
          n = {
        tree: this,
        node: t,
        key: i,
        color: this.color,
        dark: this.isDark
      };
      return Object.defineProperty(n, "expanded", {
        get: function get() {
          return e.expanded;
        },
        set: function set(t) {
          t !== e.expanded && s.setExpanded(i, t);
        },
        configurable: !0,
        enumerable: !0
      }), Object.defineProperty(n, "ticked", {
        get: function get() {
          return e.ticked;
        },
        set: function set(t) {
          t !== e.ticked && s.setTicked([i], t);
        },
        configurable: !0,
        enumerable: !0
      }), n;
    },
    __getChildren: function __getChildren(t, e) {
      var i = this;
      return (this.filter ? e.filter(function (t) {
        return i.meta[t[i.nodeKey]].matchesFilter;
      }) : e).map(function (e) {
        return i.__getNode(t, e);
      });
    },
    __getNodeMedia: function __getNodeMedia(t, e) {
      if (void 0 !== e.icon) return t(QIcon, {
        staticClass: "q-tree__icon q-mr-sm",
        props: {
          name: e.icon,
          color: e.iconColor
        }
      });
      var i = e.img || e.avatar;
      return i ? t("img", {
        staticClass: "q-tree__" + (e.img ? "img" : "avatar") + " q-mr-sm",
        attrs: {
          src: i
        }
      }) : void 0;
    },
    __getNode: function __getNode(t, e) {
      var i = this,
          s = e[this.nodeKey],
          n = this.meta[s],
          o = e.header && this.$scopedSlots["header-" + e.header] || this.$scopedSlots["default-header"],
          r = !0 === n.isParent ? this.__getChildren(t, e[this.childrenKey]) : [],
          a = r.length > 0 || n.lazy && "loaded" !== n.lazy,
          l = e.body && this.$scopedSlots["body-" + e.body] || this.$scopedSlots["default-body"],
          c = void 0 !== o || void 0 !== l ? this.__getSlotScope(e, n, s) : null;
      return void 0 !== l && (l = t("div", {
        staticClass: "q-tree__node-body relative-position"
      }, [t("div", {
        class: this.textColorClass
      }, [l(c)])])), t("div", {
        key: s,
        staticClass: "q-tree__node relative-position",
        class: {
          "q-tree__node--parent": a,
          "q-tree__node--child": !a
        }
      }, [t("div", {
        staticClass: "q-tree__node-header relative-position row no-wrap items-center",
        class: {
          "q-tree__node--link q-hoverable q-focusable": n.link,
          "q-tree__node--selected": n.selected,
          "q-tree__node--disabled": n.disabled
        },
        attrs: {
          tabindex: n.link ? 0 : -1
        },
        on: {
          click: function click(t) {
            i.__onClick(e, n, t);
          },
          keypress: function keypress(t) {
            !0 !== shouldIgnoreKey(t) && (13 === t.keyCode ? i.__onClick(e, n, t, !0) : 32 === t.keyCode && i.__onExpandClick(e, n, t, !0));
          }
        }
      }, [t("div", {
        staticClass: "q-focus-helper",
        attrs: {
          tabindex: -1
        },
        ref: "blurTarget_" + n.key
      }), "loading" === n.lazy ? t(QSpinner, {
        staticClass: "q-tree__spinner q-mr-xs",
        props: {
          color: this.computedControlColor
        }
      }) : !0 === a ? t(QIcon, {
        staticClass: "q-tree__arrow q-mr-xs",
        class: {
          "q-tree__arrow--rotate": n.expanded
        },
        props: {
          name: this.computedIcon
        },
        on: {
          click: function click(t) {
            i.__onExpandClick(e, n, t);
          }
        }
      }) : null, !0 === n.hasTicking && !0 !== n.noTick ? t(QCheckbox, {
        staticClass: "q-mr-xs",
        props: {
          value: !0 === n.indeterminate ? null : n.ticked,
          color: this.computedControlColor,
          dark: this.isDark,
          dense: !0,
          keepColor: !0,
          disable: !0 !== n.tickable
        },
        on: {
          keydown: stopAndPrevent,
          input: function input(t) {
            i.__onTickedClick(n, t);
          }
        }
      }) : null, t("div", {
        staticClass: "q-tree__node-header-content col row no-wrap items-center",
        class: n.selected ? this.selectedColorClass : this.textColorClass
      }, [o ? o(c) : [this.__getNodeMedia(t, e), t("div", e[this.labelKey])]])]), !0 === a ? t(QSlideTransition, {
        props: {
          duration: this.duration
        },
        on: cache(this, "slide", {
          show: function show() {
            i.$emit("after-show");
          },
          hide: function hide() {
            i.$emit("after-hide");
          }
        })
      }, [t("div", {
        staticClass: "q-tree__node-collapsible",
        class: this.textColorClass,
        directives: [{
          name: "show",
          value: n.expanded
        }]
      }, [l, t("div", {
        staticClass: "q-tree__children",
        class: {
          "q-tree__node--disabled": n.disabled
        }
      }, r)])]) : l]);
    },
    __blur: function __blur(t) {
      var e = this.$refs["blurTarget_" + t];
      void 0 !== e && e.focus();
    },
    __onClick: function __onClick(t, e, i, s) {
      !0 !== s && this.__blur(e.key), this.hasSelection ? e.selectable && this.$emit("update:selected", e.key !== this.selected ? e.key : null) : this.__onExpandClick(t, e, i, s), "function" == typeof t.handler && t.handler(t);
    },
    __onExpandClick: function __onExpandClick(t, e, i, s) {
      void 0 !== i && stopAndPrevent(i), !0 !== s && this.__blur(e.key), this.setExpanded(e.key, !e.expanded, t, e);
    },
    __onTickedClick: function __onTickedClick(t, e) {
      if (!0 === t.indeterminate && (e = t.indeterminateNextState), t.strictTicking) this.setTicked([t.key], e);else if (t.leafTicking) {
        var i = [],
            s = function s(t) {
          t.isParent ? (!0 !== e && !0 !== t.noTick && !0 === t.tickable && i.push(t.key), !0 === t.leafTicking && t.children.forEach(s)) : !0 === t.noTick || !0 !== t.tickable || !0 === t.leafFilteredTicking && !0 !== t.matchesFilter || i.push(t.key);
        };

        s(t), this.setTicked(i, e);
      }
    }
  },
  render: function render(t) {
    var e = this.__getChildren(t, this.nodes);

    return t("div", {
      class: this.classes
    }, 0 === e.length ? this.filter ? this.noResultsLabel || this.$q.lang.tree.noResults : this.noNodesLabel || this.$q.lang.tree.noNodes : e);
  },
  created: function created() {
    !0 === this.defaultExpandAll && this.expandAll();
  }
}),
    QUploaderBase = vue_runtime_esm["a" /* default */].extend({
  name: "QUploaderBase",
  mixins: [DarkMixin, FileMixin],
  props: {
    label: String,
    color: String,
    textColor: String,
    square: Boolean,
    flat: Boolean,
    bordered: Boolean,
    noThumbnails: Boolean,
    autoUpload: Boolean,
    hideUploadBtn: Boolean,
    disable: Boolean,
    readonly: Boolean
  },
  provide: function provide() {
    return {
      __qUploaderGetInput: this.__getInputControl
    };
  },
  data: function data() {
    return {
      files: [],
      queuedFiles: [],
      uploadedFiles: [],
      dnd: !1,
      expanded: !1,
      uploadSize: 0,
      uploadedSize: 0
    };
  },
  watch: {
    isUploading: function isUploading(t, e) {
      !1 === e && !0 === t ? this.$emit("start") : !0 === e && !1 === t && this.$emit("finish");
    }
  },
  computed: {
    canUpload: function canUpload() {
      return !0 === this.editable && !0 !== this.isBusy && !0 !== this.isUploading && this.queuedFiles.length > 0;
    },
    canAddFiles: function canAddFiles() {
      return !0 === this.editable && !1 === this.isUploading && (!0 === this.multiple || 0 === this.queuedFiles.length) && (void 0 === this.maxFiles || this.files.length < this.maxFilesNumber) && (void 0 === this.maxTotalSize || this.uploadSize < this.maxTotalSizeNumber);
    },
    uploadProgress: function uploadProgress() {
      return 0 === this.uploadSize ? 0 : this.uploadedSize / this.uploadSize;
    },
    uploadProgressLabel: function uploadProgressLabel() {
      return this.__getProgressLabel(this.uploadProgress);
    },
    uploadedSizeLabel: function uploadedSizeLabel() {
      return humanStorageSize(this.uploadedSize);
    },
    uploadSizeLabel: function uploadSizeLabel() {
      return humanStorageSize(this.uploadSize);
    },
    colorClass: function colorClass() {
      var t = [];
      return void 0 !== this.color && t.push("bg-" + this.color), void 0 !== this.textColor && t.push("text-" + this.textColor), t.join(" ");
    },
    editable: function editable() {
      return !0 !== this.disable && !0 !== this.readonly;
    }
  },
  methods: {
    reset: function reset() {
      this.disable || (this.abort(), this.uploadedSize = 0, this.uploadSize = 0, this.__revokeImgURLs(), this.files = [], this.queuedFiles = [], this.uploadedFiles = []);
    },
    removeUploadedFiles: function removeUploadedFiles() {
      this.disable || (this.files = this.files.filter(function (t) {
        return "uploaded" !== t.__status || (void 0 !== t._img && window.URL.revokeObjectURL(t._img.src), !1);
      }), this.uploadedFiles = []);
    },
    removeQueuedFiles: function removeQueuedFiles() {
      var t = this;

      if (!this.disable) {
        var e = [],
            i = this.files.filter(function (i) {
          return "idle" !== i.__status && "failed" !== i.__status || (t.uploadSize -= i.size, e.push(i), void 0 !== i._img && window.URL.revokeObjectURL(i._img.src), !1);
        });
        e.length > 0 && (this.files = i, this.queuedFiles = [], this.$emit("removed", e));
      }
    },
    removeFile: function removeFile(t) {
      this.disable || ("uploaded" === t.__status ? this.uploadedFiles = this.uploadedFiles.filter(function (e) {
        return e.name !== t.name;
      }) : "uploading" === t.__status ? t.__abort() : this.uploadSize -= t.size, this.files = this.files.filter(function (e) {
        return e.name !== t.name || (void 0 !== e._img && window.URL.revokeObjectURL(e._img.src), !1);
      }), this.queuedFiles = this.queuedFiles.filter(function (e) {
        return e.name !== t.name;
      }), this.$emit("removed", [t]));
    },
    __revokeImgURLs: function __revokeImgURLs() {
      this.files.forEach(function (t) {
        void 0 !== t._img && window.URL.revokeObjectURL(t._img.src);
      });
    },
    __getFileInput: function __getFileInput() {
      return this.$refs.input || this.$el.getElementsByClassName("q-uploader__input")[0];
    },
    __getProgressLabel: function __getProgressLabel(t) {
      return (100 * t).toFixed(2) + "%";
    },
    __updateFile: function __updateFile(t, e, i) {
      if (t.__status = e, "idle" === e) return t.__uploaded = 0, t.__progress = 0, t.__sizeLabel = humanStorageSize(t.size), void (t.__progressLabel = "0.00%");
      "failed" !== e ? (t.__uploaded = "uploaded" === e ? t.size : i, t.__progress = "uploaded" === e ? 1 : Math.min(.9999, t.__uploaded / t.size), t.__progressLabel = this.__getProgressLabel(t.__progress), this.$forceUpdate()) : this.$forceUpdate();
    },
    __addFiles: function __addFiles(t, e) {
      var i = this,
          s = this.__processFiles(t, e, this.files, !0);

      if (void 0 !== s) {
        var n = s.filter(function (t) {
          return -1 === i.files.findIndex(function (e) {
            return t.name === e.name;
          });
        });
        this.__getFileInput().value = "", void 0 !== n && (n.forEach(function (t) {
          if (i.__updateFile(t, "idle"), i.uploadSize += t.size, !0 !== i.noThumbnails && t.type.toUpperCase().startsWith("IMAGE")) {
            var e = new Image();
            e.src = window.URL.createObjectURL(t), t.__img = e;
          }
        }), this.files = this.files.concat(n), this.queuedFiles = this.queuedFiles.concat(n), this.$emit("added", n), !0 === this.autoUpload && this.upload());
      }
    },
    __getBtn: function __getBtn(t, e, i, s) {
      if (!0 === e) return t(QBtn, {
        props: {
          type: "a",
          icon: this.$q.iconSet.uploader[i],
          flat: !0,
          dense: !0
        },
        on: "add" === i ? null : {
          click: s
        }
      }, "add" === i ? this.__getInputControl(t) : null);
    },
    __getInputControl: function __getInputControl(t) {
      return [t("input", {
        ref: "input",
        staticClass: "q-uploader__input overflow-hidden absolute-full",
        attrs: Object.assign({}, {
          tabindex: -1,
          type: "file",
          title: "",
          accept: this.accept
        }, !0 === this.multiple ? {
          multiple: !0
        } : {}),
        on: cache(this, "input", {
          mousedown: stop,
          change: this.__addFiles
        })
      })];
    },
    __getHeader: function __getHeader(t) {
      return void 0 !== this.$scopedSlots.header ? this.$scopedSlots.header(this) : [t("div", {
        staticClass: "q-uploader__header-content flex flex-center no-wrap q-gutter-xs"
      }, [this.__getBtn(t, this.queuedFiles.length > 0, "removeQueue", this.removeQueuedFiles), this.__getBtn(t, this.uploadedFiles.length > 0, "removeUploaded", this.removeUploadedFiles), !0 === this.isUploading ? t(QSpinner, {
        staticClass: "q-uploader__spinner"
      }) : null, t("div", {
        staticClass: "col column justify-center"
      }, [void 0 !== this.label ? t("div", {
        staticClass: "q-uploader__title"
      }, [this.label]) : null, t("div", {
        staticClass: "q-uploader__subtitle"
      }, [this.uploadSizeLabel + " / " + this.uploadProgressLabel])]), this.__getBtn(t, this.canAddFiles, "add", this.pickFiles), this.__getBtn(t, !1 === this.hideUploadBtn && !0 === this.canUpload, "upload", this.upload), this.__getBtn(t, this.isUploading, "clear", this.abort)])];
    },
    __getList: function __getList(t) {
      var e = this;
      return void 0 !== this.$scopedSlots.list ? this.$scopedSlots.list(this) : this.files.map(function (i) {
        return t("div", {
          key: i.name,
          staticClass: "q-uploader__file relative-position",
          class: {
            "q-uploader__file--img": !0 !== e.noThumbnails && void 0 !== i.__img,
            "q-uploader__file--failed": "failed" === i.__status,
            "q-uploader__file--uploaded": "uploaded" === i.__status
          },
          style: !0 !== e.noThumbnails && void 0 !== i.__img ? {
            backgroundImage: 'url("' + i.__img.src + '")'
          } : null
        }, [t("div", {
          staticClass: "q-uploader__file-header row flex-center no-wrap"
        }, ["failed" === i.__status ? t(QIcon, {
          staticClass: "q-uploader__file-status",
          props: {
            name: e.$q.iconSet.type.negative,
            color: "negative"
          }
        }) : null, t("div", {
          staticClass: "q-uploader__file-header-content col"
        }, [t("div", {
          staticClass: "q-uploader__title"
        }, [i.name]), t("div", {
          staticClass: "q-uploader__subtitle row items-center no-wrap"
        }, [i.__sizeLabel + " / " + i.__progressLabel])]), "uploading" === i.__status ? t(QCircularProgress, {
          props: {
            value: i.__progress,
            min: 0,
            max: 1,
            indeterminate: 0 === i.__progress
          }
        }) : t(QBtn, {
          props: {
            round: !0,
            dense: !0,
            flat: !0,
            icon: e.$q.iconSet.uploader["uploaded" === i.__status ? "done" : "clear"]
          },
          on: {
            click: function click() {
              e.removeFile(i);
            }
          }
        })])]);
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    !0 === this.isUploading && this.abort(), this.files.length > 0 && this.__revokeImgURLs();
  },
  render: function render(t) {
    var e = [t("div", {
      staticClass: "q-uploader__header",
      class: this.colorClass
    }, this.__getHeader(t)), t("div", {
      staticClass: "q-uploader__list scroll"
    }, this.__getList(t)), this.__getDnd(t, "uploader")];
    return !0 === this.isBusy && e.push(t("div", {
      staticClass: "q-uploader__overlay absolute-full flex flex-center"
    }, [t(QSpinner)])), t("div", {
      staticClass: "q-uploader column no-wrap",
      class: {
        "q-uploader--dark q-dark": this.isDark,
        "q-uploader--bordered": this.bordered,
        "q-uploader--square no-border-radius": this.square,
        "q-uploader--flat no-shadow": this.flat,
        "disabled q-uploader--disable": this.disable
      },
      on: !0 === this.canAddFiles ? cache(this, "drag", {
        dragover: this.__onDragOver
      }) : null
    }, e);
  }
});

function getFn(t) {
  return "function" == typeof t ? t : function () {
    return t;
  };
}

var UploaderXHRMixin = {
  props: {
    url: [Function, String],
    method: {
      type: [Function, String],
      default: "POST"
    },
    fieldName: {
      type: [Function, String],
      default: function _default(t) {
        return t.name;
      }
    },
    headers: [Function, Array],
    formFields: [Function, Array],
    withCredentials: [Function, Boolean],
    sendRaw: [Function, Boolean],
    batch: [Function, Boolean],
    factory: Function
  },
  data: function data() {
    return {
      xhrs: [],
      promises: [],
      workingThreads: 0
    };
  },
  computed: {
    xhrProps: function xhrProps() {
      return {
        url: getFn(this.url),
        method: getFn(this.method),
        headers: getFn(this.headers),
        formFields: getFn(this.formFields),
        fieldName: getFn(this.fieldName),
        withCredentials: getFn(this.withCredentials),
        sendRaw: getFn(this.sendRaw),
        batch: getFn(this.batch)
      };
    },
    isUploading: function isUploading() {
      return this.workingThreads > 0;
    },
    isBusy: function isBusy() {
      return this.promises.length > 0;
    }
  },
  methods: {
    abort: function abort() {
      this.xhrs.forEach(function (t) {
        t.abort();
      }), this.promises.length > 0 && (this.abortPromises = !0);
    },
    upload: function upload() {
      var t = this;

      if (!1 !== this.canUpload) {
        var e = this.queuedFiles.slice(0);
        this.queuedFiles = [], this.xhrProps.batch(e) ? this.__runFactory(e) : e.forEach(function (e) {
          t.__runFactory([e]);
        });
      }
    },
    __runFactory: function __runFactory(t) {
      var e = this;

      if (this.workingThreads++, "function" == typeof this.factory) {
        var i = this.factory(t);
        if (i) {
          if ("function" == typeof i.catch && "function" == typeof i.then) {
            this.promises.push(i);

            var s = function s(_s) {
              !0 !== e._isBeingDestroyed && !0 !== e._isDestroyed && (e.promises = e.promises.filter(function (t) {
                return t !== i;
              }), 0 === e.promises.length && (e.abortPromises = !1), e.queuedFiles = e.queuedFiles.concat(t), t.forEach(function (t) {
                e.__updateFile(t, "failed");
              }), e.$emit("factory-failed", _s, t), e.workingThreads--);
            };

            i.then(function (n) {
              !0 === e.abortPromises ? s(new Error("Aborted")) : !0 !== e._isBeingDestroyed && !0 !== e._isDestroyed && (e.promises = e.promises.filter(function (t) {
                return t !== i;
              }), e.__uploadFiles(t, n));
            }).catch(s);
          } else this.__uploadFiles(t, i || {});
        } else this.$emit("factory-failed", new Error("QUploader: factory() does not return properly"), t), this.workingThreads--;
      } else this.__uploadFiles(t, {});
    },
    __uploadFiles: function __uploadFiles(t, e) {
      var i = this,
          s = new FormData(),
          n = new XMLHttpRequest(),
          o = function o(t, s) {
        return void 0 !== e[t] ? getFn(e[t])(s) : i.xhrProps[t](s);
      },
          r = o("url", t);

      if (!r) return console.error("q-uploader: invalid or no URL specified"), void this.workingThreads--;
      var a = o("formFields", t);
      void 0 !== a && a.forEach(function (t) {
        s.append(t.name, t.value);
      });
      var l,
          c = 0,
          u = 0,
          h = 0,
          d = 0;
      n.upload.addEventListener("progress", function (e) {
        if (!0 !== l) {
          var s = Math.min(d, e.loaded);
          i.uploadedSize += s - h;

          for (var n = (h = s) - u, o = c; n > 0 && o < t.length; o++) {
            var r = t[o];
            if (!(n > r.size)) return void i.__updateFile(r, "uploading", n);
            n -= r.size, c++, u += r.size, i.__updateFile(r, "uploading", r.size);
          }
        }
      }, !1), n.onreadystatechange = function () {
        n.readyState < 4 || (n.status && n.status < 400 ? (i.uploadedFiles = i.uploadedFiles.concat(t), t.forEach(function (t) {
          i.__updateFile(t, "uploaded");
        }), i.$emit("uploaded", {
          files: t,
          xhr: n
        })) : (l = !0, i.uploadedSize -= h, i.queuedFiles = i.queuedFiles.concat(t), t.forEach(function (t) {
          i.__updateFile(t, "failed");
        }), i.$emit("failed", {
          files: t,
          xhr: n
        })), i.workingThreads--, i.xhrs = i.xhrs.filter(function (t) {
          return t !== n;
        }));
      }, n.open(o("method", t), r), !0 === o("withCredentials", t) && (n.withCredentials = !0);
      var p = o("headers", t);
      void 0 !== p && p.forEach(function (t) {
        n.setRequestHeader(t.name, t.value);
      });
      var f = o("sendRaw", t);
      t.forEach(function (t) {
        i.__updateFile(t, "uploading", 0), !0 !== f && s.append(o("fieldName", t), t, t.name), t.xhr = n, t.__abort = function () {
          n.abort();
        }, d += t.size;
      }), this.$emit("uploading", {
        files: t,
        xhr: n
      }), this.xhrs.push(n), !0 === f ? n.send(new Blob(t)) : n.send(s);
    }
  }
},
    QUploader = vue_runtime_esm["a" /* default */].extend({
  name: "QUploader",
  mixins: [QUploaderBase, UploaderXHRMixin]
}),
    QUploaderAddTrigger = vue_runtime_esm["a" /* default */].extend({
  name: "QUploaderAddTrigger",
  inject: {
    __qUploaderGetInput: {
      default: function _default() {
        console.error("QUploaderAddTrigger needs to be child of QUploader");
      }
    }
  },
  render: function render(t) {
    return this.__qUploaderGetInput(t);
  }
}),
    QVideo = vue_runtime_esm["a" /* default */].extend({
  name: "QVideo",
  mixins: [RatioMixin, ListenersMixin],
  props: {
    src: {
      type: String,
      required: !0
    }
  },
  computed: {
    iframeData: function iframeData() {
      return {
        attrs: {
          src: this.src,
          frameborder: "0",
          allowfullscreen: !0
        }
      };
    },
    classes: function classes() {
      return "q-video" + (void 0 !== this.ratio ? " q-video--responsive" : "");
    }
  },
  render: function render(t) {
    return t("div", {
      class: this.classes,
      style: this.ratioStyle,
      on: Object.assign({}, this.qListeners)
    }, [t("iframe", this.iframeData)]);
  }
}),
    components$1 = Object.freeze({
  __proto__: null,
  QAjaxBar: QAjaxBar,
  QAvatar: QAvatar,
  QBadge: QBadge,
  QBanner: QBanner,
  QBar: QBar,
  QBreadcrumbs: QBreadcrumbs,
  QBreadcrumbsEl: QBreadcrumbsEl,
  QBtn: QBtn,
  QBtnDropdown: QBtnDropdown,
  QBtnGroup: QBtnGroup,
  QBtnToggle: QBtnToggle,
  QCard: QCard,
  QCardSection: QCardSection,
  QCardActions: QCardActions,
  QCarousel: QCarousel,
  QCarouselSlide: QCarouselSlide,
  QCarouselControl: QCarouselControl,
  QChatMessage: QChatMessage,
  QCheckbox: QCheckbox,
  QChip: QChip,
  QCircularProgress: QCircularProgress,
  QColor: QColor,
  QDate: QDate,
  QDialog: QDialog,
  QDrawer: QDrawer,
  QEditor: QEditor,
  QExpansionItem: QExpansionItem,
  QFab: QFab,
  QFabAction: QFabAction,
  QField: QField,
  QFile: QFile,
  QFooter: QFooter,
  QForm: QForm,
  QHeader: QHeader,
  QIcon: QIcon,
  QImg: QImg,
  QInfiniteScroll: QInfiniteScroll,
  QInnerLoading: QInnerLoading,
  QInput: QInput,
  QIntersection: QIntersection,
  QList: QList,
  QItem: QItem,
  QItemSection: QItemSection,
  QItemLabel: QItemLabel,
  QKnob: QKnob,
  QLayout: QLayout,
  QMarkupTable: QMarkupTable,
  QMenu: QMenu,
  QNoSsr: QNoSsr,
  QOptionGroup: QOptionGroup,
  QPage: QPage,
  QPageContainer: QPageContainer,
  QPageScroller: QPageScroller,
  QPageSticky: QPageSticky,
  QPagination: QPagination,
  QParallax: QParallax,
  QPopupEdit: QPopupEdit,
  QPopupProxy: QPopupProxy,
  QLinearProgress: QLinearProgress,
  QPullToRefresh: QPullToRefresh,
  QRadio: QRadio,
  QRange: QRange,
  QRating: QRating,
  QResizeObserver: QResizeObserver,
  QResponsive: QResponsive,
  QScrollArea: QScrollArea,
  QScrollObserver: QScrollObserver,
  QSelect: QSelect,
  QSeparator: QSeparator,
  QSkeleton: QSkeleton,
  QSlideItem: QSlideItem,
  QSlideTransition: QSlideTransition,
  QSlider: QSlider,
  QSpace: QSpace,
  QSpinner: QSpinner,
  QSpinnerAudio: QSpinnerAudio,
  QSpinnerBall: QSpinnerBall,
  QSpinnerBars: QSpinnerBars,
  QSpinnerComment: QSpinnerComment,
  QSpinnerCube: QSpinnerCube,
  QSpinnerDots: QSpinnerDots,
  QSpinnerFacebook: QSpinnerFacebook,
  QSpinnerGears: QSpinnerGears,
  QSpinnerGrid: QSpinnerGrid,
  QSpinnerHearts: QSpinnerHearts,
  QSpinnerHourglass: QSpinnerHourglass,
  QSpinnerInfinity: QSpinnerInfinity,
  QSpinnerIos: QSpinnerIos,
  QSpinnerOval: QSpinnerOval,
  QSpinnerPie: QSpinnerPie,
  QSpinnerPuff: QSpinnerPuff,
  QSpinnerRadio: QSpinnerRadio,
  QSpinnerRings: QSpinnerRings,
  QSpinnerTail: QSpinnerTail,
  QSplitter: QSplitter,
  QStep: QStep,
  QStepper: QStepper,
  QStepperNavigation: QStepperNavigation,
  QTabPanels: QTabPanels,
  QTabPanel: QTabPanel,
  QTable: QTable,
  QTh: QTh,
  QTr: QTr,
  QTd: QTd,
  QTabs: QTabs,
  QTab: QTab,
  QRouteTab: QRouteTab,
  QTime: QTime,
  QTimeline: QTimeline,
  QTimelineEntry: QTimelineEntry,
  QToggle: QToggle,
  QToolbar: QToolbar,
  QToolbarTitle: QToolbarTitle,
  QTooltip: QTooltip,
  QTree: QTree,
  QUploader: QUploader,
  QUploaderBase: QUploaderBase,
  QUploaderAddTrigger: QUploaderAddTrigger,
  QVideo: QVideo,
  QVirtualScroll: QVirtualScroll
});

function getDepth(t) {
  if (!1 === t) return 0;
  if (!0 === t || void 0 === t) return 1;
  var e = parseInt(t, 10);
  return isNaN(e) ? 0 : e;
}

var ClosePopup = {
  name: "close-popup",
  bind: function bind(t, e, i) {
    var s = {
      depth: getDepth(e.value),
      handler: function handler(t) {
        0 !== s.depth && setTimeout(function () {
          closePortals(i.componentInstance || i.context, t, s.depth);
        });
      },
      handlerKey: function handlerKey(t) {
        !0 === isKeyCode(t, 13) && s.handler(t);
      }
    };
    void 0 !== t.__qclosepopup && (t.__qclosepopup_old = t.__qclosepopup), t.__qclosepopup = s, t.addEventListener("click", s.handler), t.addEventListener("keyup", s.handlerKey);
  },
  update: function update(t, e) {
    var i = e.value,
        s = e.oldValue;
    void 0 !== t.__qclosepopup && i !== s && (t.__qclosepopup.depth = getDepth(i));
  },
  unbind: function unbind(t) {
    var e = t.__qclosepopup_old || t.__qclosepopup;
    void 0 !== e && (t.removeEventListener("click", e.handler), t.removeEventListener("keyup", e.handlerKey), delete t[t.__qclosepopup_old ? "__qclosepopup_old" : "__qclosepopup"]);
  }
},
    GoBack = {
  name: "go-back",
  bind: function bind(t, e, i) {
    var s = e.value,
        n = e.modifiers,
        o = {
      value: s,
      position: window.history.length - 1,
      single: n.single,
      goBack: function goBack() {
        var t = i.context.$router;
        !0 === o.single ? t.go(-1) : !0 === client.is.nativeMobile ? t.go(o.position - window.history.length) : t.replace(o.value);
      },
      goBackKey: function goBackKey(t) {
        !0 === isKeyCode(t, 13) && o.goBack();
      }
    };
    t.__qgoback && (t.__qgoback_old = t.__qgoback), t.__qgoback = o, t.addEventListener("click", o.goBack), t.addEventListener("keyup", o.goBackKey);
  },
  update: function update(t, e) {
    var i = e.value,
        s = e.oldValue,
        n = e.modifiers,
        o = t.__qgoback;
    void 0 !== o && (i !== s && (o.value = i), o.single !== n.single && (o.single = n.single));
  },
  unbind: function unbind(t) {
    var e = t.__qgoback_old || t.__qgoback;
    void 0 !== e && (t.removeEventListener("click", e.goBack), t.removeEventListener("keyup", e.goBackKey), delete t[t.__qgoback_old ? "__qgoback_old" : "__qgoback"]);
  }
};

function objectWithoutProperties(t, e) {
  var i = {};

  for (var s in t) {
    Object.prototype.hasOwnProperty.call(t, s) && -1 === e.indexOf(s) && (i[s] = t[s]);
  }

  return i;
}

var defaultCfg$1 = {
  childList: !0,
  subtree: !0,
  attributes: !0,
  characterData: !0,
  attributeOldValue: !0,
  characterDataOldValue: !0
};

function update$1(t, e, i) {
  var s,
      n = i.modifiers,
      o = n.once,
      r = objectWithoutProperties(n, ["once"]),
      a = i.value;
  e.once = o, e.handler !== a && (s = !0, e.handler = a), void 0 !== e.opts && !1 !== isDeepEqual(r, e.mod) || (s = !0, e.mod = r, e.opts = 0 === Object.keys(r).length ? defaultCfg$1 : r), !0 === s && (void 0 !== e.observer && e.observer.disconnect(), e.observer = new MutationObserver(function (i) {
    "function" == typeof e.handler && (!1 !== e.handler(i) && !0 !== e.once || destroy$1(t));
  }), e.observer.observe(t, e.opts));
}

function destroy$1(t) {
  var e = t.__qmutation;
  void 0 !== e && (void 0 !== e.observer && e.observer.disconnect(), delete t.__qmutation);
}

var Mutation = {
  name: "mutation",
  inserted: function inserted(t, e) {
    var i = {};
    update$1(t, i, e), t.__qmutation = i;
  },
  update: function update(t, e) {
    var i = t.__qmutation;
    void 0 !== i && update$1(t, i, e);
  },
  unbind: destroy$1
};

function updateBinding(t, e) {
  var i = e.value,
      s = e.oldValue;
  "function" == typeof i ? (t.handler = i, "function" != typeof s && (t.scrollTarget.addEventListener("scroll", t.scroll, listenOpts.passive), t.scroll())) : t.scrollTarget.removeEventListener("scroll", t.scroll);
}

var ScrollFire = {
  name: "scroll-fire",
  bind: function bind(t) {
    var e = {
      scroll: debounce(function () {
        var i, s;
        e.scrollTarget === window ? (s = t.getBoundingClientRect().bottom, i = window.innerHeight) : (s = offset(t).top + height(t), i = offset(e.scrollTarget).top + height(e.scrollTarget)), s > 0 && s < i && (e.scrollTarget.removeEventListener("scroll", e.scroll, listenOpts.passive), e.handler(t));
      }, 25)
    };
    t.__qscrollfire && (t.__qscrollfire_old = t.__qscrollfire), t.__qscrollfire = e;
  },
  inserted: function inserted(t, e) {
    var i = t.__qscrollfire;
    i.scrollTarget = getScrollTarget(t), updateBinding(i, e);
  },
  update: function update(t, e) {
    void 0 !== t.__qscrollfire && e.value !== e.oldValue && updateBinding(t.__qscrollfire, e);
  },
  unbind: function unbind(t) {
    var e = t.__qscrollfire_old || t.__qscrollfire;
    void 0 !== e && (e.scrollTarget.removeEventListener("scroll", e.scroll, listenOpts.passive), delete t[t.__qscrollfire_old ? "__qscrollfire_old" : "__qscrollfire"]);
  }
};

function updateBinding$1(t, e) {
  var i = e.value,
      s = e.oldValue;
  "function" == typeof i ? (t.handler = i, "function" != typeof s && t.scrollTarget.addEventListener("scroll", t.scroll, listenOpts.passive)) : t.scrollTarget.removeEventListener("scroll", t.scroll, listenOpts.passive);
}

var Scroll = {
  name: "scroll",
  bind: function bind(t) {
    var e = {
      scroll: function scroll() {
        e.handler(getScrollPosition(e.scrollTarget), getHorizontalScrollPosition(e.scrollTarget));
      }
    };
    t.__qscroll && (t.__qscroll_old = t.__qscroll), t.__qscroll = e;
  },
  inserted: function inserted(t, e) {
    var i = t.__qscroll;
    i.scrollTarget = getScrollTarget(t), updateBinding$1(i, e);
  },
  update: function update(t, e) {
    void 0 !== t.__qscroll && e.oldValue !== e.value && updateBinding$1(t.__qscroll, e);
  },
  unbind: function unbind(t) {
    var e = t.__qscroll_old || t.__qscroll;
    void 0 !== e && (e.scrollTarget.removeEventListener("scroll", e.scroll, listenOpts.passive), delete t[t.__qscroll_old ? "__qscroll_old" : "__qscroll"]);
  }
};

function update$2(t, e) {
  var i,
      s = t.__qtouchhold;

  if (void 0 !== s) {
    e.oldValue !== e.value && ("function" != typeof e.value && s.end(), s.handler = e.value);
    var n = [600, 5, 7];
    "string" == typeof e.arg && e.arg.length && e.arg.split(":").forEach(function (t, e) {
      var i = parseInt(t, 10);
      i && (n[e] = i);
    }), i = n, s.duration = i[0], s.touchSensitivity = i[1], s.mouseSensitivity = i[2];
  }
}

var TouchHold = {
  name: "touch-hold",
  bind: function bind(t, e) {
    var i = e.modifiers;

    if (!0 === i.mouse || !0 === client.has.touch) {
      var s = {
        noop: noop,
        mouseStart: function mouseStart(t) {
          "function" == typeof s.handler && !0 === leftClick(t) && (addEvt(s, "temp", [[document, "mousemove", "move", "passiveCapture"], [document, "click", "end", "notPassiveCapture"]]), s.start(t, !0));
        },
        touchStart: function touchStart(t) {
          if (void 0 !== t.target && "function" == typeof s.handler) {
            var e = getTouchTarget(t.target);
            addEvt(s, "temp", [[e, "touchmove", "move", "passiveCapture"], [e, "touchcancel", "end", "notPassiveCapture"], [e, "touchend", "end", "notPassiveCapture"]]), s.start(t);
          }
        },
        start: function start(t, e) {
          s.origin = position(t);
          var i = Date.now();
          !0 === client.is.mobile && (document.body.classList.add("non-selectable"), clearSelection(), s.styleCleanup = function (t) {
            s.styleCleanup = void 0;

            var e = function e() {
              document.body.classList.remove("non-selectable");
            };

            !0 === t ? (clearSelection(), setTimeout(e, 10)) : e();
          }), s.triggered = !1, s.sensitivity = !0 === e ? s.mouseSensitivity : s.touchSensitivity, s.timer = setTimeout(function () {
            clearSelection(), s.triggered = !0, s.handler({
              evt: t,
              touch: !0 !== e,
              mouse: !0 === e,
              position: s.origin,
              duration: Date.now() - i
            });
          }, s.duration);
        },
        move: function move(t) {
          var e = position(t),
              i = e.top,
              n = e.left;
          (Math.abs(n - s.origin.left) >= s.sensitivity || Math.abs(i - s.origin.top) >= s.sensitivity) && clearTimeout(s.timer);
        },
        end: function end(t) {
          cleanEvt(s, "temp"), void 0 !== s.styleCleanup && s.styleCleanup(s.triggered), !0 === s.triggered ? void 0 !== t && stopAndPrevent(t) : clearTimeout(s.timer);
        }
      };
      t.__qtouchhold && (t.__qtouchhold_old = t.__qtouchhold), t.__qtouchhold = s, update$2(t, e), !0 === i.mouse && addEvt(s, "main", [[t, "mousedown", "mouseStart", "passive" + (!0 === i.mouseCapture ? "Capture" : "")]]), !0 === client.has.touch && addEvt(s, "main", [[t, "touchstart", "touchStart", "passive" + (!0 === i.capture ? "Capture" : "")], [t, "touchend", "noop", "notPassiveCapture"]]);
    }
  },
  update: update$2,
  unbind: function unbind(t) {
    var e = t.__qtouchhold_old || t.__qtouchhold;
    void 0 !== e && (cleanEvt(e, "main"), cleanEvt(e, "temp"), clearTimeout(e.timer), void 0 !== e.styleCleanup && e.styleCleanup(), delete t[t.__qtouchhold_old ? "__qtouchhold_old" : "__qtouchhold"]);
  }
},
    keyCodes$2 = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  delete: [8, 46]
},
    keyRegex = new RegExp("^([\\d+]+|" + Object.keys(keyCodes$2).join("|") + ")$", "i");

function shouldEnd(t, e) {
  var i = position(t),
      s = i.top,
      n = i.left;
  return Math.abs(n - e.left) >= 7 || Math.abs(s - e.top) >= 7;
}

var metaValue,
    TouchRepeat = {
  name: "touch-repeat",
  bind: function bind(t, e) {
    var i = e.modifiers,
        s = e.value,
        n = e.arg,
        o = Object.keys(i).reduce(function (t, e) {
      if (!0 === keyRegex.test(e)) {
        var i = isNaN(parseInt(e, 10)) ? keyCodes$2[e.toLowerCase()] : parseInt(e, 10);
        i >= 0 && t.push(i);
      }

      return t;
    }, []);

    if (!0 === i.mouse || !0 === client.has.touch || 0 !== o.length) {
      var r = "string" == typeof n && n.length > 0 ? n.split(":").map(function (t) {
        return parseInt(t, 10);
      }) : [0, 600, 300],
          a = r.length - 1,
          l = {
        keyboard: o,
        handler: s,
        noop: noop,
        mouseStart: function mouseStart(t) {
          void 0 === l.event && "function" == typeof l.handler && !0 === leftClick(t) && (addEvt(l, "temp", [[document, "mousemove", "move", "passiveCapture"], [document, "click", "end", "notPassiveCapture"]]), l.start(t, !0));
        },
        keyboardStart: function keyboardStart(e) {
          if ("function" == typeof l.handler && !0 === isKeyCode(e, o)) {
            if ((0 === r[0] || void 0 !== l.event) && (stopAndPrevent(e), t.focus(), void 0 !== l.event)) return;
            addEvt(l, "temp", [[document, "keyup", "end", "notPassiveCapture"], [document, "click", "end", "notPassiveCapture"]]), l.start(e, !1, !0);
          }
        },
        touchStart: function touchStart(t) {
          if (void 0 !== t.target && "function" == typeof l.handler) {
            var e = getTouchTarget(t.target);
            addEvt(l, "temp", [[e, "touchmove", "move", "passiveCapture"], [e, "touchcancel", "end", "notPassiveCapture"], [e, "touchend", "end", "notPassiveCapture"]]), l.start(t);
          }
        },
        start: function start(t, e, i) {
          function s(t) {
            l.styleCleanup = void 0, document.documentElement.style.cursor = "";

            var e = function e() {
              document.body.classList.remove("non-selectable");
            };

            !0 === t ? (clearSelection(), setTimeout(e, 10)) : e();
          }

          !0 !== i && (l.origin = position(t)), !0 === client.is.mobile && (document.body.classList.add("non-selectable"), clearSelection(), l.styleCleanup = s), l.event = {
            touch: !0 !== e && !0 !== i,
            mouse: !0 === e,
            keyboard: !0 === i,
            startTime: Date.now(),
            repeatCount: 0
          };

          var n = function n() {
            if (void 0 !== l.event) {
              0 === l.event.repeatCount && (l.event.evt = t, !0 === i ? l.event.keyCode = t.keyCode : l.event.position = position(t), !0 !== client.is.mobile && (document.documentElement.style.cursor = "pointer", document.body.classList.add("non-selectable"), clearSelection(), l.styleCleanup = s)), l.event.duration = Date.now() - l.event.startTime, l.event.repeatCount += 1, l.handler(l.event);
              var e = a < l.event.repeatCount ? a : l.event.repeatCount;
              l.timer = setTimeout(n, r[e]);
            }
          };

          0 === r[0] ? n() : l.timer = setTimeout(n, r[0]);
        },
        move: function move(t) {
          void 0 !== l.event && !0 === shouldEnd(t, l.origin) && clearTimeout(l.timer);
        },
        end: function end(t) {
          void 0 !== l.event && (void 0 !== l.styleCleanup && l.styleCleanup(!0), void 0 !== t && l.event.repeatCount > 0 && stopAndPrevent(t), cleanEvt(l, "temp"), clearTimeout(l.timer), l.event = void 0);
        }
      };
      void 0 !== t.__qtouchrepeat && (t.__qtouchrepeat_old = t.__qtouchrepeat), t.__qtouchrepeat = l, !0 === i.mouse && addEvt(l, "main", [[t, "mousedown", "mouseStart", "passive" + (!0 === i.mouseCapture ? "Capture" : "")]]), !0 === client.has.touch && addEvt(l, "main", [[t, "touchstart", "touchStart", "passive" + (!0 === i.capture ? "Capture" : "")], [t, "touchend", "noop", "notPassiveCapture"]]), o.length > 0 && addEvt(l, "main", [[t, "keydown", "keyboardStart", "notPassive" + (!0 === i.keyCapture ? "Capture" : "")]]);
    }
  },
  update: function update(t, e) {
    var i = t.__qtouchrepeat;
    void 0 !== i && e.oldValue !== e.value && ("function" != typeof e.value && i.end(), i.handler = e.value);
  },
  unbind: function unbind(t) {
    var e = t.__qtouchrepeat_old || t.__qtouchrepeat;
    void 0 !== e && (clearTimeout(e.timer), cleanEvt(e, "main"), cleanEvt(e, "temp"), void 0 !== e.styleCleanup && e.styleCleanup(), delete t[t.__qtouchrepeat_old ? "__qtouchrepeat_old" : "__qtouchrepeat"]);
  }
},
    directives = Object.freeze({
  __proto__: null,
  ClosePopup: ClosePopup,
  GoBack: GoBack,
  Intersection: Intersection,
  Mutation: Mutation,
  Ripple: Ripple,
  ScrollFire: ScrollFire,
  Scroll: Scroll,
  TouchHold: TouchHold,
  TouchPan: TouchPan,
  TouchRepeat: TouchRepeat,
  TouchSwipe: TouchSwipe
});

function getProp() {
  return Platform.is.winphone ? "msapplication-navbutton-color" : Platform.is.safari ? "apple-mobile-web-app-status-bar-style" : "theme-color";
}

function getMetaTag(t) {
  var e = document.getElementsByTagName("META");

  for (var i in e) {
    if (e[i].name === t) return e[i];
  }
}

function setColor(t) {
  void 0 === metaValue && (metaValue = getProp());
  var e = getMetaTag(metaValue),
      i = void 0 === e;
  i && (e = document.createElement("meta")).setAttribute("name", metaValue), e.setAttribute("content", t), i && document.head.appendChild(e);
}

var AddressbarColor = {
  install: function install(t) {
    var e = t.$q,
        i = t.cfg;
    this.set = !1 !== isSSR || !0 !== Platform.is.mobile || !0 !== Platform.is.nativeMobile && !0 !== Platform.is.winphone && !0 !== Platform.is.safari && !0 !== Platform.is.webkit && !0 !== Platform.is.vivaldi ? noop : function (t) {
      var e = t || getBrand("primary");
      !0 === Platform.is.nativeMobile && window.StatusBar ? window.StatusBar.backgroundColorByHexString(e) : setColor(e);
    }, e.addressbarColor = this, i.addressbarColor && this.set(i.addressbarColor);
  }
},
    prefixes = {};

function promisify(t, e) {
  try {
    var i = t[e]();
    return void 0 === i ? Promise.resolve() : i;
  } catch (t) {
    return Promise.reject(t);
  }
}

var AppFullscreen = {
  isCapable: !1,
  isActive: !1,
  request: function request(t) {
    return this.isCapable && !this.isActive ? promisify(t || document.documentElement, prefixes.request) : this.__getErr();
  },
  exit: function exit() {
    return this.isCapable && this.isActive ? promisify(document, prefixes.exit) : this.__getErr();
  },
  toggle: function toggle(t) {
    return this.isActive ? this.exit() : this.request(t);
  },
  install: function install(t) {
    var e = this;
    t.$q.fullscreen = this, !0 !== isSSR && (prefixes.request = ["requestFullscreen", "msRequestFullscreen", "mozRequestFullScreen", "webkitRequestFullscreen"].find(function (t) {
      return document.documentElement[t];
    }), this.isCapable = void 0 !== prefixes.request, !1 !== this.isCapable ? (this.__getErr = function () {
      return Promise.resolve();
    }, prefixes.exit = ["exitFullscreen", "msExitFullscreen", "mozCancelFullScreen", "webkitExitFullscreen"].find(function (t) {
      return document[t];
    }), this.isActive = !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement), ["onfullscreenchange", "onmsfullscreenchange", "onwebkitfullscreenchange"].forEach(function (t) {
      document[t] = function () {
        e.isActive = !e.isActive;
      };
    }), vue_runtime_esm["a" /* default */].util.defineReactive(this, "isActive", this.isActive)) : this.__getErr = function () {
      return Promise.reject("Not capable");
    });
  }
},
    AppVisibility = {
  appVisible: !1,
  install: function install(t) {
    var e = this,
        i = t.$q;

    if (!0 !== isSSR) {
      var s, n;
      void 0 !== document.hidden ? (s = "hidden", n = "visibilitychange") : void 0 !== document.msHidden ? (s = "msHidden", n = "msvisibilitychange") : void 0 !== document.webkitHidden && (s = "webkitHidden", n = "webkitvisibilitychange");

      var o = function o() {
        e.appVisible = i.appVisible = !document[s];
      };

      o(), n && void 0 !== document[s] && (vue_runtime_esm["a" /* default */].util.defineReactive(i, "appVisible", this.appVisible), document.addEventListener(n, o, !1));
    } else this.appVisible = i.appVisible = !0;
  }
},
    BottomSheet = vue_runtime_esm["a" /* default */].extend({
  name: "BottomSheetPlugin",
  mixins: [DarkMixin, AttrsMixin],
  inheritAttrs: !1,
  props: {
    title: String,
    message: String,
    actions: Array,
    grid: Boolean,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  computed: {
    dialogProps: function dialogProps() {
      return Object.assign({}, this.qAttrs, {
        position: "bottom"
      });
    }
  },
  methods: {
    show: function show() {
      this.$refs.dialog.show();
    },
    hide: function hide() {
      this.$refs.dialog.hide();
    },
    onOk: function onOk(t) {
      this.$emit("ok", t), this.hide();
    },
    __getGrid: function __getGrid(t) {
      var e = this;
      return this.actions.map(function (i) {
        var s = i.avatar || i.img;
        return void 0 === i.label ? t(QSeparator, {
          staticClass: "col-all",
          props: {
            dark: e.isDark
          }
        }) : t("div", {
          staticClass: "q-bottom-sheet__item q-hoverable q-focusable cursor-pointer relative-position",
          class: i.classes,
          attrs: {
            tabindex: 0
          },
          on: {
            click: function click() {
              return e.onOk(i);
            },
            keyup: function keyup(t) {
              13 === t.keyCode && e.onOk(i);
            }
          }
        }, [t("div", {
          staticClass: "q-focus-helper"
        }), i.icon ? t(QIcon, {
          props: {
            name: i.icon,
            color: i.color
          }
        }) : s ? t("img", {
          attrs: {
            src: s
          },
          staticClass: i.avatar ? "q-bottom-sheet__avatar" : null
        }) : t("div", {
          staticClass: "q-bottom-sheet__empty-icon"
        }), t("div", [i.label])]);
      });
    },
    __getList: function __getList(t) {
      var e = this;
      return this.actions.map(function (i) {
        var s = i.avatar || i.img;
        return void 0 === i.label ? t(QSeparator, {
          props: {
            spaced: !0,
            dark: e.isDark
          }
        }) : t(QItem, {
          staticClass: "q-bottom-sheet__item",
          class: i.classes,
          props: {
            tabindex: 0,
            clickable: !0,
            dark: e.isDark
          },
          on: {
            click: function click() {
              return e.onOk(i);
            },
            keyup: function keyup(t) {
              13 === t.keyCode && e.onOk(i);
            }
          }
        }, [t(QItemSection, {
          props: {
            avatar: !0
          }
        }, [i.icon ? t(QIcon, {
          props: {
            name: i.icon,
            color: i.color
          }
        }) : s ? t("img", {
          attrs: {
            src: s
          },
          staticClass: i.avatar ? "q-bottom-sheet__avatar" : null
        }) : null]), t(QItemSection, [i.label])]);
      });
    }
  },
  render: function render(t) {
    var e = this,
        i = [];
    return this.title && i.push(t(QCardSection, {
      staticClass: "q-dialog__title"
    }, [this.title])), this.message && i.push(t(QCardSection, {
      staticClass: "q-dialog__message scroll"
    }, [this.message])), i.push(!0 === this.grid ? t("div", {
      staticClass: "scroll row items-stretch justify-start"
    }, this.__getGrid(t)) : t("div", {
      staticClass: "scroll"
    }, this.__getList(t))), t(QDialog, {
      ref: "dialog",
      props: this.dialogProps,
      on: cache(this, "hide", {
        hide: function hide() {
          e.$emit("hide");
        }
      })
    }, [t(QCard, {
      staticClass: "q-bottom-sheet q-bottom-sheet--" + (!0 === this.grid ? "grid" : "list") + (!0 === this.isDark ? " q-bottom-sheet--dark q-dark" : ""),
      style: this.cardStyle,
      class: this.cardClass
    }, i)]);
  }
});

function objectWithoutProperties$1(t, e) {
  var i = {};

  for (var s in t) {
    Object.prototype.hasOwnProperty.call(t, s) && -1 === e.indexOf(s) && (i[s] = t[s]);
  }

  return i;
}

var ssrAPI = {
  onOk: function onOk() {
    return ssrAPI;
  },
  okCancel: function okCancel() {
    return ssrAPI;
  },
  hide: function hide() {
    return ssrAPI;
  }
};

function globalDialog(t) {
  return function (e) {
    e.className;
    var i = e.class,
        s = e.style,
        n = e.component,
        o = e.root,
        r = e.parent,
        a = objectWithoutProperties$1(e, ["className", "class", "style", "component", "root", "parent"]);
    if (!0 === isSSR) return ssrAPI;
    void 0 !== i && (a.cardClass = i), void 0 !== s && (a.cardStyle = s);
    var l = [],
        c = [],
        u = {
      onOk: function onOk(t) {
        return l.push(t), u;
      },
      onCancel: function onCancel(t) {
        return c.push(t), u;
      },
      onDismiss: function onDismiss(t) {
        return l.push(t), c.push(t), u;
      },
      hide: function hide() {
        return v.$refs.dialog.hide(), u;
      }
    },
        h = document.createElement("div");
    document.body.appendChild(h);
    var d = !1,
        p = {
      ok: function ok(t) {
        d = !0, l.forEach(function (e) {
          e(t);
        });
      },
      hide: function hide() {
        v.$destroy(), v.$el.remove(), v = null, !0 !== d && c.forEach(function (t) {
          t();
        });
      }
    };
    vue_runtime_esm["a" /* default */].observable(a);
    var f = void 0 !== n ? n : t,
        m = void 0 === n ? a : void 0,
        v = new vue_runtime_esm["a" /* default */]({
      name: "QGlobalDialog",
      el: h,
      parent: void 0 === r ? o : r,
      render: function render(t) {
        return t(f, {
          ref: "dialog",
          props: a,
          attrs: m,
          on: p
        });
      },
      mounted: function mounted() {
        this.$refs.dialog.show();
      }
    });
    return u;
  };
}

var BottomSheet$1 = {
  install: function install(t) {
    var e = t.$q;
    this.create = e.bottomSheet = globalDialog(BottomSheet);
  }
};

function encode(t) {
  return encodeURIComponent(t);
}

function decode(t) {
  return decodeURIComponent(t);
}

function stringifyCookieValue(t) {
  return encode(t === Object(t) ? JSON.stringify(t) : "" + t);
}

function read(t) {
  if ("" === t) return t;
  0 === t.indexOf('"') && (t = t.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\")), t = decode(t.replace(/\+/g, " "));

  try {
    t = JSON.parse(t);
  } catch (t) {}

  return t;
}

function getString(t) {
  var e = new Date();
  return e.setMilliseconds(e.getMilliseconds() + t), e.toUTCString();
}

function parseExpireString(t) {
  var e = 0,
      i = t.match(/(\d+)d/),
      s = t.match(/(\d+)h/),
      n = t.match(/(\d+)m/),
      o = t.match(/(\d+)s/);
  return i && (e += 864e5 * i[1]), s && (e += 36e5 * s[1]), n && (e += 6e4 * n[1]), o && (e += 1e3 * o[1]), 0 === e ? t : getString(e);
}

function _set(t, e, i, s) {
  var n, o;
  void 0 === i && (i = {}), void 0 !== i.expires && ("[object Date]" === Object.prototype.toString.call(i.expires) ? n = i.expires.toUTCString() : "string" == typeof i.expires ? n = parseExpireString(i.expires) : (o = parseFloat(i.expires), n = !1 === isNaN(o) ? getString(864e5 * o) : i.expires));
  var r = encode(t) + "=" + stringifyCookieValue(e),
      a = [r, void 0 !== n ? "; Expires=" + n : "", i.path ? "; Path=" + i.path : "", i.domain ? "; Domain=" + i.domain : "", i.sameSite ? "; SameSite=" + i.sameSite : "", i.httpOnly ? "; HttpOnly" : "", i.secure ? "; Secure" : "", i.other ? "; " + i.other : ""].join("");

  if (s) {
    s.req.qCookies ? s.req.qCookies.push(a) : s.req.qCookies = [a], s.res.setHeader("Set-Cookie", s.req.qCookies);
    var l = s.req.headers.cookie || "";

    if (void 0 !== n && o < 0) {
      var c = _get(t, s);

      void 0 !== c && (l = l.replace(t + "=" + c + "; ", "").replace("; " + t + "=" + c, "").replace(t + "=" + c, ""));
    } else l = l ? r + "; " + l : a;

    s.req.headers.cookie = l;
  } else document.cookie = a;
}

function _get(t, e) {
  for (var i, s, n, o = t ? null : {}, r = e ? e.req.headers : document, a = r.cookie ? r.cookie.split("; ") : [], l = 0, c = a.length; l < c; l++) {
    if (s = decode((i = a[l].split("=")).shift()), n = i.join("="), t) {
      if (t === s) {
        o = read(n);
        break;
      }
    } else o[s] = n;
  }

  return o;
}

function _remove(t, e, i) {
  _set(t, "", Object.assign({}, {
    expires: -1
  }, e), i);
}

function _has(t, e) {
  return null !== _get(t, e);
}

function getObject(t) {
  return {
    get: function get(e) {
      return _get(e, t);
    },
    set: function set(e, i, s) {
      return _set(e, i, s, t);
    },
    has: function has(e) {
      return _has(e, t);
    },
    remove: function remove(e, i) {
      return _remove(e, i, t);
    },
    getAll: function getAll() {
      return _get(null, t);
    }
  };
}

var vm,
    timeout,
    updateId,
    ssrTakeover,
    Cookies = {
  parseSSR: function parseSSR(t) {
    return void 0 !== t ? getObject(t) : this;
  },
  install: function install(t) {
    var e = t.$q,
        i = t.queues;
    !0 === isSSR ? i.server.push(function (t, e) {
      t.cookies = getObject(e.ssr);
    }) : (Object.assign(this, getObject()), e.cookies = this);
  }
},
    DialogPlugin = vue_runtime_esm["a" /* default */].extend({
  name: "DialogPlugin",
  mixins: [DarkMixin, AttrsMixin],
  inheritAttrs: !1,
  props: {
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: !0
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: "ok",
      validator: function validator(t) {
        return ["ok", "cancel", "none"].includes(t);
      }
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  computed: {
    hasForm: function hasForm() {
      return void 0 !== this.prompt || void 0 !== this.options;
    },
    okLabel: function okLabel() {
      return Object(this.ok) === this.ok ? this.$q.lang.label.ok : !0 === this.ok ? this.$q.lang.label.ok : this.ok;
    },
    cancelLabel: function cancelLabel() {
      return Object(this.cancel) === this.cancel ? this.$q.lang.label.cancel : !0 === this.cancel ? this.$q.lang.label.cancel : this.cancel;
    },
    vmColor: function vmColor() {
      return this.color || (!0 === this.isDark ? "amber" : "primary");
    },
    okDisabled: function okDisabled() {
      return void 0 !== this.prompt ? void 0 !== this.prompt.isValid && !0 !== this.prompt.isValid(this.prompt.model) : void 0 !== this.options ? void 0 !== this.options.isValid && !0 !== this.options.isValid(this.options.model) : void 0;
    },
    okProps: function okProps() {
      return Object.assign({
        color: this.vmColor,
        label: this.okLabel,
        ripple: !1
      }, Object(this.ok) === this.ok ? this.ok : {
        flat: !0
      }, {
        disable: this.okDisabled
      });
    },
    cancelProps: function cancelProps() {
      return Object.assign({
        color: this.vmColor,
        label: this.cancelLabel,
        ripple: !1
      }, Object(this.cancel) === this.cancel ? this.cancel : {
        flat: !0
      });
    }
  },
  methods: {
    show: function show() {
      this.$refs.dialog.show();
    },
    hide: function hide() {
      this.$refs.dialog.hide();
    },
    getPrompt: function getPrompt(t) {
      var e = this;
      return [t(QInput, {
        props: {
          value: this.prompt.model,
          type: this.prompt.type,
          label: this.prompt.label,
          stackLabel: this.prompt.stackLabel,
          outlined: this.prompt.outlined,
          filled: this.prompt.filled,
          standout: this.prompt.standout,
          color: this.vmColor,
          dense: !0,
          autofocus: !0,
          dark: this.isDark
        },
        attrs: this.prompt.attrs,
        on: cache(this, "prompt", {
          input: function input(t) {
            e.prompt.model = t;
          },
          keyup: function keyup(t) {
            !0 !== e.okDisabled && "textarea" !== e.prompt.type && !0 === isKeyCode(t, 13) && e.onOk();
          }
        })
      })];
    },
    getOptions: function getOptions(t) {
      var e = this;
      return [t(QOptionGroup, {
        props: {
          value: this.options.model,
          type: this.options.type,
          color: this.vmColor,
          inline: this.options.inline,
          options: this.options.items,
          dark: this.isDark
        },
        on: cache(this, "opts", {
          input: function input(t) {
            e.options.model = t;
          }
        })
      })];
    },
    getButtons: function getButtons(t) {
      var e = [];
      if (this.cancel && e.push(t(QBtn, {
        props: this.cancelProps,
        attrs: {
          "data-autofocus": "cancel" === this.focus && !0 !== this.hasForm
        },
        on: cache(this, "cancel", {
          click: this.onCancel
        })
      })), this.ok && e.push(t(QBtn, {
        props: this.okProps,
        attrs: {
          "data-autofocus": "ok" === this.focus && !0 !== this.hasForm
        },
        on: cache(this, "ok", {
          click: this.onOk
        })
      })), e.length > 0) return t(QCardActions, {
        staticClass: !0 === this.stackButtons ? "items-end" : null,
        props: {
          vertical: this.stackButtons,
          align: "right"
        }
      }, e);
    },
    onOk: function onOk() {
      this.$emit("ok", clone$1(this.getData())), this.hide();
    },
    onCancel: function onCancel() {
      this.hide();
    },
    getData: function getData() {
      return void 0 !== this.prompt ? this.prompt.model : void 0 !== this.options ? this.options.model : void 0;
    },
    getSection: function getSection(t, e, i) {
      return !0 === this.html ? t(QCardSection, {
        staticClass: e,
        domProps: {
          innerHTML: i
        }
      }) : t(QCardSection, {
        staticClass: e
      }, [i]);
    }
  },
  render: function render(t) {
    var e = this,
        i = [];
    return this.title && i.push(this.getSection(t, "q-dialog__title", this.title)), this.message && i.push(this.getSection(t, "q-dialog__message scroll", this.message)), !0 === this.hasForm && i.push(t(QCardSection, {
      staticClass: "scroll"
    }, void 0 !== this.prompt ? this.getPrompt(t) : this.getOptions(t))), (this.ok || this.cancel) && i.push(this.getButtons(t)), t(QDialog, {
      ref: "dialog",
      props: Object.assign({}, this.qAttrs, {
        value: this.value
      }),
      on: cache(this, "hide", {
        hide: function hide() {
          e.$emit("hide");
        }
      })
    }, [t(QCard, {
      staticClass: "q-dialog-plugin" + (!0 === this.isDark ? " q-dialog-plugin--dark q-dark" : ""),
      style: this.cardStyle,
      class: this.cardClass,
      props: {
        dark: this.isDark
      }
    }, i)]);
  }
}),
    Dialog = {
  install: function install(t) {
    var e = t.$q;
    this.create = e.dialog = globalDialog(DialogPlugin);
  }
},
    LoadingBar = {
  isActive: !1,
  start: noop,
  stop: noop,
  increment: noop,
  setDefaults: noop,
  install: function install(t) {
    var e = this,
        i = t.$q,
        s = t.cfg;

    if (!0 !== isSSR) {
      var n = void 0 !== s.loadingBar ? Object.assign({}, s.loadingBar) : {},
          o = i.loadingBar = new vue_runtime_esm["a" /* default */]({
        name: "LoadingBar",
        render: function render(t) {
          return t(QAjaxBar, {
            ref: "bar",
            props: n
          });
        }
      }).$mount().$refs.bar;
      Object.assign(this, {
        start: function start(t) {
          o.start(t), e.isActive = o.isActive = o.calls > 0;
        },
        stop: function stop() {
          o.stop(), e.isActive = o.isActive = o.calls > 0;
        },
        increment: o.increment,
        setDefaults: function setDefaults(t) {
          t === Object(t) && Object.assign(n, t), o.$parent.$forceUpdate();
        }
      }), vue_runtime_esm["a" /* default */].util.defineReactive(this, "isActive", this.isActive), vue_runtime_esm["a" /* default */].util.defineReactive(o, "isActive", this.isActive), o.setDefaults = this.setDefaults, document.body.appendChild(o.$parent.$el);
    } else i.loadingBar = this;
  }
},
    uid$3 = 0,
    props = {},
    originalDefaults = {
  delay: 0,
  message: !1,
  spinnerSize: 80,
  spinnerColor: "white",
  messageColor: "white",
  backgroundColor: "black",
  spinner: QSpinner,
  customClass: ""
},
    defaults = Object.assign({}, originalDefaults),
    Loading = {
  isActive: !1,
  show: function show(t) {
    var e = this;
    !0 !== isSSR && ((props = t === Object(t) && !0 === t.ignoreDefaults ? Object.assign({}, originalDefaults, t) : Object.assign({}, defaults, t)).customClass += " text-" + props.backgroundColor, props.uid = "l_" + uid$3++, this.isActive = !0, void 0 === vm ? (clearTimeout(timeout), timeout = setTimeout(function () {
      timeout = void 0;
      var t = document.createElement("div");
      document.body.appendChild(t), vm = new vue_runtime_esm["a" /* default */]({
        name: "QLoading",
        el: t,
        mounted: function mounted() {
          preventScroll(!0);
        },
        render: function render(t) {
          var i;
          return t("transition", {
            props: {
              name: "q-transition--fade",
              appear: !0
            },
            on: cache(e, "tr", {
              "after-leave": function afterLeave() {
                !0 !== e.isActive && void 0 !== vm && (preventScroll(!1), vm.$destroy(), vm.$el.remove(), vm = void 0);
              }
            })
          }, [!0 === e.isActive ? t("div", {
            staticClass: "q-loading fullscreen column flex-center z-max",
            key: props.uid,
            class: props.customClass.trim()
          }, [t(props.spinner, {
            props: {
              color: props.spinnerColor,
              size: props.spinnerSize
            }
          }), props.message && t("div", {
            class: "text-" + props.messageColor,
            domProps: (i = {}, i[!0 === props.sanitize ? "textContent" : "innerHTML"] = props.message, i)
          }) || void 0]) : null]);
        }
      });
    }, props.delay)) : vm.$forceUpdate());
  },
  hide: function hide() {
    !0 === this.isActive && (void 0 !== timeout && (clearTimeout(timeout), timeout = void 0), this.isActive = !1);
  },
  setDefaults: function setDefaults(t) {
    t === Object(t) && Object.assign(defaults, t);
  },
  install: function install(t) {
    var e = t.$q,
        i = t.cfg.loading;
    this.setDefaults(i), e.loading = this;
  }
};

function normalize(t) {
  t.title && (t.title = t.titleTemplate ? t.titleTemplate(t.title) : t.title, delete t.titleTemplate), [["meta", "content"], ["link", "href"]].forEach(function (e) {
    var i = t[e[0]],
        s = e[1];

    for (var n in i) {
      var o = i[n];
      o.template && (1 === Object.keys(o).length ? delete i[n] : (o[s] = o.template(o[s] || ""), delete o.template));
    }
  });
}

function changed(t, e) {
  if (Object.keys(t).length !== Object.keys(e).length) return !0;

  for (var i in t) {
    if (t[i] !== e[i]) return !0;
  }
}

function bodyFilter(t) {
  return !1 === ["class", "style"].includes(t);
}

function htmlFilter(t) {
  return !1 === ["lang", "dir"].includes(t);
}

function diff(t, e) {
  var i = {},
      s = {};
  return void 0 === t ? {
    add: e,
    remove: s
  } : (t.title !== e.title && (i.title = e.title), ["meta", "link", "script", "htmlAttr", "bodyAttr"].forEach(function (n) {
    var o = t[n],
        r = e[n];

    if (s[n] = [], void 0 !== o && null !== o) {
      for (var a in i[n] = {}, o) {
        !1 === r.hasOwnProperty(a) && s[n].push(a);
      }

      for (var l in r) {
        !1 === o.hasOwnProperty(l) ? i[n][l] = r[l] : !0 === changed(o[l], r[l]) && (s[n].push(l), i[n][l] = r[l]);
      }
    } else i[n] = r;
  }), {
    add: i,
    remove: s
  });
}

function apply$1(t) {
  var e = t.add,
      i = t.remove;
  e.title && (document.title = e.title), Object.keys(i).length > 0 && (["meta", "link", "script"].forEach(function (t) {
    i[t].forEach(function (e) {
      document.head.querySelector(t + '[data-qmeta="' + e + '"]').remove();
    });
  }), i.htmlAttr.filter(htmlFilter).forEach(function (t) {
    document.documentElement.removeAttribute(t);
  }), i.bodyAttr.filter(bodyFilter).forEach(function (t) {
    document.body.removeAttribute(t);
  })), ["meta", "link", "script"].forEach(function (t) {
    var i = e[t];

    for (var s in i) {
      var n = document.createElement(t);

      for (var o in i[s]) {
        "innerHTML" !== o && n.setAttribute(o, i[s][o]);
      }

      n.setAttribute("data-qmeta", s), "script" === t && (n.innerHTML = i[s].innerHTML || ""), document.head.appendChild(n);
    }
  }), Object.keys(e.htmlAttr).filter(htmlFilter).forEach(function (t) {
    document.documentElement.setAttribute(t, e.htmlAttr[t] || "");
  }), Object.keys(e.bodyAttr).filter(bodyFilter).forEach(function (t) {
    document.body.setAttribute(t, e.bodyAttr[t] || "");
  });
}

function parseMeta(t, e) {
  !0 !== t._inactive && (!0 === hasMeta(t) && (extend(!0, e, t.__qMeta), !0 === t.$options.meta.stopPropagation) || t.$children.forEach(function (t) {
    parseMeta(t, e);
  }));
}

function updateClient() {
  !0 === ssrTakeover && (ssrTakeover = !1, this.$root.__currentMeta = window.__Q_META__);
  var t = {
    title: "",
    titleTemplate: null,
    meta: {},
    link: {},
    script: {},
    htmlAttr: {},
    bodyAttr: {}
  };
  parseMeta(this.$root, t), normalize(t), apply$1(diff(this.$root.__currentMeta, t)), this.$root.__currentMeta = t;
}

function getAttr(t) {
  return function (e) {
    var i = t[e];
    return e + (void 0 !== i ? '="' + i + '"' : "");
  };
}

function getHead(t) {
  var e = "";
  return t.title && (e += "<title>" + t.title + "</title>"), ["meta", "link", "script"].forEach(function (i) {
    var s = t[i];

    for (var n in s) {
      var o = Object.keys(s[n]).filter(function (t) {
        return "innerHTML" !== t;
      }).map(getAttr(s[n]));
      e += "<" + i + " " + o.join(" ") + ' data-qmeta="' + n + '">', "script" === i && (e += (s[n].innerHTML || "") + "<\/script>");
    }
  }), e;
}

function getServerMeta(t, e, i) {
  var s = {
    title: "",
    titleTemplate: null,
    meta: {},
    link: {},
    htmlAttr: {},
    bodyAttr: {},
    noscript: {}
  };
  parseMeta(t, s), normalize(s);
  var n = void 0 !== i && void 0 !== i.nonce ? ' nonce="' + i.nonce + '"' : "",
      o = {
    "%%Q_HTML_ATTRS%%": Object.keys(s.htmlAttr).filter(htmlFilter).map(getAttr(s.htmlAttr)).join(" "),
    "%%Q_HEAD_TAGS%%": getHead(s),
    "%%Q_BODY_ATTRS%%": Object.keys(s.bodyAttr).filter(bodyFilter).map(getAttr(s.bodyAttr)).join(" "),
    "%%Q_BODY_TAGS%%": Object.keys(s.noscript).map(function (t) {
      return '<noscript data-qmeta="' + t + '">' + s.noscript[t] + "</noscript>";
    }).join("") + "<script" + n + ">window.__Q_META__=" + (delete s.noscript && JSON.stringify(s)) + "<\/script>"
  };
  return Object.keys(o).forEach(function (t) {
    e = e.replace(t, o[t]);
  }), e;
}

function beforeCreate() {
  "function" == typeof this.$options.meta ? (void 0 === this.$options.computed && (this.$options.computed = {}), this.$options.computed.__qMeta = this.$options.meta) : !0 === hasMeta(this) && (this.__qMeta = this.$options.meta);
}

function hasMeta(t) {
  return void 0 !== t.$options.meta && null !== t.$options.meta;
}

function triggerMeta() {
  !0 === hasMeta(this) && this.__qMetaUpdate();
}

!1 === isSSR && vue_runtime_esm["a" /* default */].util.defineReactive(Loading, "isActive", Loading.isActive);
var Meta = {
  install: function install(t) {
    var e = t.queues;
    !0 === isSSR ? (vue_runtime_esm["a" /* default */].prototype.$getMetaHTML = function (t) {
      return function (e, i) {
        return getServerMeta(t, e, i);
      };
    }, vue_runtime_esm["a" /* default */].mixin({
      beforeCreate: beforeCreate
    }), e.server.push(function (t, e) {
      e.ssr.Q_HTML_ATTRS += " %%Q_HTML_ATTRS%%", Object.assign(e.ssr, {
        Q_HEAD_TAGS: "%%Q_HEAD_TAGS%%",
        Q_BODY_ATTRS: "%%Q_BODY_ATTRS%%",
        Q_BODY_TAGS: "%%Q_BODY_TAGS%%"
      });
    })) : (ssrTakeover = fromSSR, vue_runtime_esm["a" /* default */].mixin({
      beforeCreate: beforeCreate,
      created: function created() {
        !0 === hasMeta(this) && (this.__qMetaUnwatch = this.$watch("__qMeta", this.__qMetaUpdate));
      },
      activated: triggerMeta,
      deactivated: triggerMeta,
      beforeMount: triggerMeta,
      destroyed: function destroyed() {
        !0 === hasMeta(this) && (this.__qMetaUnwatch(), this.__qMetaUpdate());
      },
      methods: {
        __qMetaUpdate: function __qMetaUpdate() {
          clearTimeout(updateId), updateId = setTimeout(updateClient.bind(this), 50);
        }
      }
    }));
  }
};

function objectWithoutProperties$2(t, e) {
  var i = {};

  for (var s in t) {
    Object.prototype.hasOwnProperty.call(t, s) && -1 === e.indexOf(s) && (i[s] = t[s]);
  }

  return i;
}

var uid$4 = 0,
    defaults$1 = {},
    attrs$2 = {
  role: "alert"
},
    positionList = ["top-left", "top-right", "bottom-left", "bottom-right", "top", "bottom", "left", "right", "center"],
    badgePositions = ["top-left", "top-right", "bottom-left", "bottom-right"],
    notifTypes = {
  positive: {
    icon: function icon() {
      return this.$q.iconSet.type.positive;
    },
    color: "positive"
  },
  negative: {
    icon: function icon() {
      return this.$q.iconSet.type.negative;
    },
    color: "negative"
  },
  warning: {
    icon: function icon() {
      return this.$q.iconSet.type.warning;
    },
    color: "warning",
    textColor: "dark"
  },
  info: {
    icon: function icon() {
      return this.$q.iconSet.type.info;
    },
    color: "info"
  }
},
    groups = {},
    positionClass$1 = {},
    Notifications = {
  name: "QNotifications",
  created: function created() {
    var t = this;
    this.notifs = {}, positionList.forEach(function (e) {
      t.notifs[e] = [];
      var i = ["left", "center", "right"].includes(e) ? "center" : e.indexOf("top") > -1 ? "top" : "bottom",
          s = e.indexOf("left") > -1 ? "start" : e.indexOf("right") > -1 ? "end" : "center",
          n = ["left", "right"].includes(e) ? "items-" + ("left" === e ? "start" : "end") + " justify-center" : "center" === e ? "flex-center" : "items-" + s;
      positionClass$1[e] = "q-notifications__list q-notifications__list--" + i + " fixed column no-wrap " + n;
    });
  },
  methods: {
    add: function add(t) {
      var e = this;
      if (!t) return console.error("Notify: parameter required"), !1;
      var i = {
        textColor: "white"
      };

      if ("string" != typeof t && !0 === t.ignoreDefaults || Object.assign(i, defaults$1), Object(t) === t ? (Object.assign(i, notifTypes[t.type], t), "function" == typeof i.icon && (i.icon = i.icon.call(this))) : Object.assign(i, {
        message: t
      }), i.meta = {
        hasMedia: Boolean(i.icon || i.avatar)
      }, i.position) {
        if (!1 === positionList.includes(i.position)) return console.error("Notify: wrong position: " + i.position), !1;
      } else i.position = "bottom";

      if (void 0 === i.timeout) i.timeout = 5e3;else {
        var s = parseInt(i.timeout, 10);
        if (isNaN(s) || s < 0) return console.error("Notify: wrong timeout: " + i.timeout), !1;
        i.timeout = s;
      }
      0 === i.timeout ? i.progress = !1 : !0 === i.progress && (i.meta.progressStyle = {
        animationDuration: i.timeout + 1e3 + "ms"
      });
      var n = (!0 === Array.isArray(t.actions) ? t.actions : []).concat(!0 !== t.ignoreDefaults && !0 === Array.isArray(defaults$1.actions) ? defaults$1.actions : []).concat(void 0 !== notifTypes[t.type] && !0 === Array.isArray(notifTypes[t.type].actions) ? notifTypes[t.type].actions : []);
      i.closeBtn && n.push({
        label: "string" == typeof i.closeBtn ? i.closeBtn : this.$q.lang.label.close
      }), i.actions = n.map(function (t) {
        var e = t.handler,
            s = t.noDismiss,
            n = objectWithoutProperties$2(t, ["handler", "noDismiss"]);
        return {
          props: Object.assign({}, {
            flat: !0
          }, n),
          on: {
            click: "function" == typeof e ? function () {
              e(), !0 !== s && i.meta.close();
            } : function () {
              i.meta.close();
            }
          }
        };
      }), void 0 === i.multiLine && (i.multiLine = i.actions.length > 1), Object.assign(i.meta, {
        staticClass: "q-notification row items-stretch q-notification--" + (!0 === i.multiLine ? "multi-line" : "standard") + (void 0 !== i.color ? " bg-" + i.color : "") + (void 0 !== i.textColor ? " text-" + i.textColor : "") + (void 0 !== i.classes ? " " + i.classes : ""),
        wrapperClass: "q-notification__wrapper col relative-position border-radius-inherit " + (!0 === i.multiLine ? "column no-wrap justify-center" : "row items-center"),
        contentClass: "q-notification__content row items-center" + (!0 === i.multiLine ? "" : " col")
      }), !1 === i.group ? i.group = void 0 : (void 0 !== i.group && !0 !== i.group || (i.group = [i.message, i.caption, i.multiline].concat(i.actions.map(function (t) {
        return t.props.label + "*" + t.props.icon;
      })).join("|")), i.group += "|" + i.position), 0 === i.actions.length ? i.actions = void 0 : i.meta.actionsClass = "q-notification__actions row items-center " + (!0 === i.multiLine ? "justify-end" : "col-auto") + (!0 === i.meta.hasMedia ? " q-notification__actions--with-media" : "");
      var o = groups[i.group];

      if (void 0 === o) {
        if (i.meta.uid = uid$4++, i.meta.badge = 1, -1 !== ["left", "right", "center"].indexOf(i.position)) this.notifs[i.position].splice(Math.floor(this.notifs[i.position].length / 2), 0, i);else {
          var r = i.position.indexOf("top") > -1 ? "unshift" : "push";
          this.notifs[i.position][r](i);
        }
        void 0 !== i.group && (groups[i.group] = i);
      } else {
        void 0 !== o.meta.timer && clearTimeout(o.meta.timer);
        var a = groups[i.group];

        if (void 0 !== i.badgePosition) {
          if (!1 === badgePositions.includes(i.badgePosition)) return console.error("Notify - wrong badgePosition specified: " + i.badgePosition), !1;
        } else i.badgePosition = "top-" + (i.position.indexOf("left") > -1 ? "right" : "left");

        i.meta.uid = a.meta.uid, i.meta.badge = a.meta.badge + 1, i.meta.badgeStaticClass = "q-notification__badge q-notification__badge--" + i.badgePosition + (void 0 !== i.badgeColor ? " bg-" + i.badgeColor : "") + (void 0 !== i.badgeTextColor ? " text-" + i.badgeTextColor : "");
        var l = this.notifs[i.position].indexOf(a);
        this.notifs[i.position][l] = groups[i.group] = i;
      }

      return i.meta.close = function () {
        e.remove(i);
      }, this.$forceUpdate(), i.timeout > 0 && (i.meta.timer = setTimeout(function () {
        i.meta.close();
      }, i.timeout + 1e3)), i.meta.close;
    },
    remove: function remove(t) {
      clearTimeout(t.meta.timer);
      var e = this.notifs[t.position].indexOf(t);

      if (-1 !== e) {
        void 0 !== t.group && delete groups[t.group];
        var i = this.$refs["notif_" + t.meta.uid];

        if (i) {
          var s = getComputedStyle(i),
              n = s.width,
              o = s.height;
          i.style.left = i.offsetLeft + "px", i.style.width = n, i.style.height = o;
        }

        this.notifs[t.position].splice(e, 1), this.$forceUpdate(), "function" == typeof t.onDismiss && t.onDismiss();
      }
    }
  },
  render: function render(t) {
    var e = this;
    return t("div", {
      staticClass: "q-notifications"
    }, positionList.map(function (i) {
      return t("transition-group", {
        key: i,
        staticClass: positionClass$1[i],
        tag: "div",
        props: {
          name: "q-notification--" + i,
          mode: "out-in"
        }
      }, e.notifs[i].map(function (e) {
        var i,
            s = e.meta,
            n = {
          staticClass: "q-notification__message col"
        };
        if (!0 === e.html) n.domProps = {
          innerHTML: e.caption ? "<div>" + e.message + '</div><div class="q-notification__caption">' + e.caption + "</div>" : e.message
        };else {
          var o = [e.message];
          i = e.caption ? [t("div", o), t("div", {
            staticClass: "q-notification__caption"
          }, [e.caption])] : o;
        }
        var r = [];
        !0 === s.hasMedia && (e.icon ? r.push(t(QIcon, {
          staticClass: "q-notification__icon col-auto",
          attrs: {
            role: "img"
          },
          props: {
            name: e.icon
          }
        })) : e.avatar && r.push(t(QAvatar, {
          staticClass: "q-notification__avatar col-auto"
        }, [t("img", {
          attrs: {
            src: e.avatar,
            "aria-hidden": "true"
          }
        })]))), r.push(t("div", n, i));
        var a = [t("div", {
          staticClass: s.contentClass
        }, r)];
        return !0 === e.progress && a.push(t("div", {
          key: s.uid + "|p|" + s.badge,
          staticClass: "q-notification__progress",
          style: s.progressStyle,
          class: e.progressClass
        })), void 0 !== e.actions && a.push(t("div", {
          staticClass: s.actionsClass
        }, e.actions.map(function (e) {
          return t(QBtn, {
            props: e.props,
            on: e.on
          });
        }))), s.badge > 1 && a.push(t("div", {
          key: s.uid + "|" + s.badge,
          staticClass: s.badgeStaticClass,
          style: e.badgeStyle,
          class: e.badgeClass
        }, [s.badge])), t("div", {
          ref: "notif_" + s.uid,
          key: s.uid,
          staticClass: s.staticClass,
          attrs: attrs$2
        }, [t("div", {
          staticClass: s.wrapperClass
        }, a)]);
      }));
    }));
  }
},
    Notify = {
  create: function create(t) {
    return !0 === isSSR ? noop : this.__vm.add(t);
  },
  setDefaults: function setDefaults(t) {
    t === Object(t) && Object.assign(defaults$1, t);
  },
  registerType: function registerType(t, e) {
    !0 !== isSSR && e === Object(e) && (notifTypes[t] = e);
  },
  install: function install(t) {
    var e = t.cfg,
        i = t.$q;
    if (!0 === isSSR) return i.notify = noop, void (i.notify.setDefaults = noop);
    this.setDefaults(e.notify), i.notify = this.create.bind(this), i.notify.setDefaults = this.setDefaults, i.notify.registerType = this.registerType;
    var s = document.createElement("div");
    document.body.appendChild(s), this.__vm = new vue_runtime_esm["a" /* default */](Notifications), this.__vm.$mount(s);
  }
};

function encode$1(t) {
  return "[object Date]" === Object.prototype.toString.call(t) ? "__q_date|" + t.toUTCString() : "[object RegExp]" === Object.prototype.toString.call(t) ? "__q_expr|" + t.source : "number" == typeof t ? "__q_numb|" + t : "boolean" == typeof t ? "__q_bool|" + (t ? "1" : "0") : "string" == typeof t ? "__q_strn|" + t : "function" == typeof t ? "__q_strn|" + t.toString() : t === Object(t) ? "__q_objt|" + JSON.stringify(t) : t;
}

function decode$1(t) {
  var e, i;
  if (t.length < 9) return t;

  switch (e = t.substr(0, 8), i = t.substring(9), e) {
    case "__q_date":
      return new Date(i);

    case "__q_expr":
      return new RegExp(i);

    case "__q_numb":
      return Number(i);

    case "__q_bool":
      return Boolean("1" === i);

    case "__q_strn":
      return "" + i;

    case "__q_objt":
      return JSON.parse(i);

    default:
      return t;
  }
}

function getEmptyStorage() {
  return {
    has: noop,
    getLength: noop,
    getItem: noop,
    getIndex: noop,
    getAll: noop,
    set: noop,
    remove: noop,
    clear: noop,
    isEmpty: noop
  };
}

function getStorage(t) {
  var e = window[t + "Storage"],
      i = function i(t) {
    var i = e.getItem(t);
    return i ? decode$1(i) : null;
  };

  return {
    has: function has(t) {
      return null !== e.getItem(t);
    },
    getLength: function getLength() {
      return e.length;
    },
    getItem: i,
    getIndex: function getIndex(t) {
      return t < e.length ? i(e.key(t)) : null;
    },
    getKey: function getKey(t) {
      return t < e.length ? e.key(t) : null;
    },
    getAll: function getAll() {
      for (var t, s = {}, n = e.length, o = 0; o < n; o++) {
        s[t = e.key(o)] = i(t);
      }

      return s;
    },
    getAllKeys: function getAllKeys() {
      for (var t = [], i = e.length, s = 0; s < i; s++) {
        t.push(e.key(s));
      }

      return t;
    },
    set: function set(t, i) {
      e.setItem(t, encode$1(i));
    },
    remove: function remove(t) {
      e.removeItem(t);
    },
    clear: function clear() {
      e.clear();
    },
    isEmpty: function isEmpty() {
      return 0 === e.length;
    }
  };
}

var LocalStorage = {
  install: function install(t) {
    var e = t.$q,
        i = !0 === isSSR || !1 === client.has.webStorage ? getEmptyStorage() : getStorage("local");
    e.localStorage = i, Object.assign(this, i);
  }
},
    SessionStorage = {
  install: function install(t) {
    var e = t.$q,
        i = !0 === isSSR || !1 === client.has.webStorage ? getEmptyStorage() : getStorage("session");
    e.sessionStorage = i, Object.assign(this, i);
  }
},
    plugins = Object.freeze({
  __proto__: null,
  AddressbarColor: AddressbarColor,
  AppFullscreen: AppFullscreen,
  AppVisibility: AppVisibility,
  BottomSheet: BottomSheet$1,
  Cookies: Cookies,
  Dark: Dark,
  Dialog: Dialog,
  LoadingBar: LoadingBar,
  Loading: Loading,
  Meta: Meta,
  Notify: Notify,
  Platform: Platform,
  Screen: Screen,
  LocalStorage: LocalStorage,
  SessionStorage: SessionStorage
});

function fallback(t) {
  var e = document.createElement("textarea");
  e.value = t, e.contentEditable = !0, e.style.position = "fixed", document.body.appendChild(e), e.focus(), e.select();
  var i = document.execCommand("copy");
  return e.remove(), i;
}

function copyToClipboard(t) {
  return void 0 !== navigator.clipboard ? navigator.clipboard.writeText(t) : new Promise(function (e, i) {
    var s = fallback(t);
    s ? e(!0) : i(s);
  });
}

function clean(t) {
  setTimeout(function () {
    window.URL.revokeObjectURL(t.href);
  }, 1e4), t.remove();
}

function exportFile(t, e, i) {
  var s = new Blob([e], {
    type: i || "text/plain"
  });
  if (window.navigator.msSaveOrOpenBlob) return window.navigator.msSaveOrOpenBlob(s, t);
  var n = document.createElement("a");
  n.download = t, n.href = window.URL.createObjectURL(s), n.classList.add("hidden"), n.style.position = "fixed", document.body.appendChild(n);

  try {
    return n.click(), clean(n), !0;
  } catch (t) {
    return clean(n), t;
  }
}

function openWindow(t, e) {
  var i = window.open;

  if (!0 === Platform.is.cordova) {
    if (void 0 !== cordova && void 0 !== cordova.InAppBrowser && void 0 !== cordova.InAppBrowser.open) i = cordova.InAppBrowser.open;else if (void 0 !== navigator && void 0 !== navigator.app) return navigator.app.loadUrl(t, {
      openExternal: !0
    });
  } else if (void 0 !== vue_runtime_esm["a" /* default */].prototype.$q.electron) return vue_runtime_esm["a" /* default */].prototype.$q.electron.shell.openExternal(t);

  var s = i(t, "_blank");
  if (s) return Platform.is.desktop && s.focus(), s;
  e && e();
}

function openUrl(t, e) {
  if (!0 !== Platform.is.ios || void 0 === window.SafariViewController) return openWindow(t, e);
  window.SafariViewController.isAvailable(function (i) {
    i ? window.SafariViewController.show({
      url: t
    }, noop, e) : openWindow(t, e);
  });
}

var index_esm = Object.assign({}, VuePlugin, {
  install: function install(t, e) {
    VuePlugin.install(t, Object.assign({}, {
      components: components$1,
      directives: directives,
      plugins: plugins
    }, e));
  }
});
/* harmony default export */ var quasar_esm = (index_esm);

// CONCATENATED MODULE: ./.quasar/bex/bridge.js


















function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * THIS FILE IS GENERATED AUTOMATICALLY.
 * DO NOT EDIT.
 **/



var typeSizes = {
  'undefined': function undefined() {
    return 0;
  },
  'boolean': function boolean() {
    return 4;
  },
  'number': function number() {
    return 8;
  },
  'string': function string(item) {
    return 2 * item.length;
  },
  'object': function object(item) {
    return !item ? 0 : Object.keys(item).reduce(function (total, key) {
      return bridge_sizeOf(key) + bridge_sizeOf(item[key]) + total;
    }, 0);
  }
},
    bridge_sizeOf = function sizeOf(value) {
  return typeSizes[typeof_default()(value)](value);
};

var bridge_Bridge = /*#__PURE__*/function (_EventEmitter) {
  inherits_default()(Bridge, _EventEmitter);

  var _super = _createSuper(Bridge);

  function Bridge(wall) {
    var _this;

    classCallCheck_default()(this, Bridge);

    _this = _super.call(this);

    _this.setMaxListeners(Infinity);

    _this.wall = wall;
    wall.listen(function (messages) {
      if (Array.isArray(messages)) {
        messages.forEach(function (message) {
          return _this._emit(message);
        });
      } else {
        _this._emit(messages);
      }
    });
    _this._sendingQueue = [];
    _this._sending = false;
    _this._maxMessageSize = 32 * 1024 * 1024; // 32mb

    return _this;
  }
  /**
   * Send an event.
   *
   * @param event
   * @param payload
   * @returns Promise<>
   */


  createClass_default()(Bridge, [{
    key: "send",
    value: function send(event, payload) {
      return this._send([{
        event: event,
        payload: payload
      }]);
    }
    /**
     * Return all registered events
     * @returns {*}
     */

  }, {
    key: "getEvents",
    value: function getEvents() {
      return this._events;
    }
  }, {
    key: "_emit",
    value: function _emit(message) {
      if (typeof message === 'string') {
        this.emit(message);
      } else {
        this.emit(message.event, message.payload);
      }
    }
  }, {
    key: "_send",
    value: function _send(messages) {
      this._sendingQueue.push(messages);

      return this._nextSend();
    }
  }, {
    key: "_nextSend",
    value: function _nextSend() {
      var _this2 = this;

      if (!this._sendingQueue.length || this._sending) return Promise.resolve();
      this._sending = true;

      var messages = this._sendingQueue.shift(),
          currentMessage = messages[0],
          eventListenerKey = "".concat(currentMessage.event, ".").concat(uid$2()),
          eventResponseKey = eventListenerKey + '.result';

      return new Promise(function (resolve, reject) {
        var allChunks = [];

        var fn = function fn(r) {
          // If this is a split message then keep listening for the chunks and build a list to resolve
          if (r !== void 0 && r._chunkSplit) {
            var chunkData = r._chunkSplit;
            allChunks = [].concat(toConsumableArray_default()(allChunks), toConsumableArray_default()(r.data)); // Last chunk received so resolve the promise.

            if (chunkData.lastChunk) {
              _this2.off(eventResponseKey, fn);

              resolve(allChunks);
            }
          } else {
            _this2.off(eventResponseKey, fn);

            resolve(r);
          }
        };

        _this2.on(eventResponseKey, fn);

        try {
          // Add an event response key to the payload we're sending so the message knows which channel to respond on.
          var messagesToSend = messages.map(function (m) {
            return _objectSpread(_objectSpread({}, m), {
              payload: {
                data: m.payload,
                eventResponseKey: eventResponseKey
              }
            });
          });

          _this2.wall.send(messagesToSend);
        } catch (err) {
          var errorMessage = 'Message length exceeded maximum allowed length.';

          if (err.message === errorMessage) {
            // If the payload is an array and too big then split it into chunks and send to the clients bridge
            // the client bridge will then resolve the promise.
            if (!Array.isArray(currentMessage.payload)) {
              if (false) {}
            } else {
              var objectSize = bridge_sizeOf(currentMessage);

              if (objectSize > _this2._maxMessageSize) {
                var chunksRequired = Math.ceil(objectSize / _this2._maxMessageSize),
                    arrayItemCount = Math.ceil(currentMessage.payload.length / chunksRequired);
                var data = currentMessage.payload;

                for (var i = 0; i < chunksRequired; i++) {
                  var take = Math.min(data.length, arrayItemCount);

                  _this2.wall.send([{
                    event: currentMessage.event,
                    payload: {
                      _chunkSplit: {
                        count: chunksRequired,
                        lastChunk: i === chunksRequired - 1
                      },
                      data: data.splice(0, take)
                    }
                  }]);
                }
              }
            }
          }
        }

        _this2._sending = false;
        requestAnimationFrame(function () {
          return _this2._nextSend();
        });
      });
    }
  }]);

  return Bridge;
}(events["EventEmitter"]);



/***/ }),

/***/ "6a99":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("d3f4");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "6abf":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("e6f3");
var hiddenKeys = __webpack_require__("1691").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "6b4c":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "6b54":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__("3846");
var anObject = __webpack_require__("cb7c");
var $flags = __webpack_require__("0bfb");
var DESCRIPTORS = __webpack_require__("9e1e");
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__("2aba")(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__("79e5")(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),

/***/ "6c1c":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("c367");
var global = __webpack_require__("e53d");
var hide = __webpack_require__("35e8");
var Iterators = __webpack_require__("481b");
var TO_STRING_TAG = __webpack_require__("5168")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "6c7b":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__("5ca1");

$export($export.P, 'Array', { fill: __webpack_require__("36bd") });

__webpack_require__("9c6c")('fill');


/***/ }),

/***/ "71c1":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("3a38");
var defined = __webpack_require__("25eb");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "7333":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__("0d58");
var gOPS = __webpack_require__("2621");
var pIE = __webpack_require__("52a7");
var toObject = __webpack_require__("4bf8");
var IObject = __webpack_require__("626a");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("79e5")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),

/***/ "7514":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__("5ca1");
var $find = __webpack_require__("0a49")(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__("9c6c")(KEY);


/***/ }),

/***/ "765d":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("6718")('observable');


/***/ }),

/***/ "7726":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "774e":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("d2d5");

/***/ }),

/***/ "77f1":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("4588");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "794b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("8e60") && !__webpack_require__("294c")(function () {
  return Object.defineProperty(__webpack_require__("1ec9")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "79aa":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "79e5":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "7a56":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("7726");
var dP = __webpack_require__("86cc");
var DESCRIPTORS = __webpack_require__("9e1e");
var SPECIES = __webpack_require__("2b4c")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "7bbc":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("6821");
var gOPN = __webpack_require__("9093").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "7c64":
/***/ (function(module, exports, __webpack_require__) {

var _Array$isArray = __webpack_require__("a745");

var arrayLikeToArray = __webpack_require__("1e85");

function _arrayWithoutHoles(arr) {
  if (_Array$isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "7cd6":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("40c3");
var ITERATOR = __webpack_require__("5168")('iterator');
var Iterators = __webpack_require__("481b");
module.exports = __webpack_require__("584a").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "7e90":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("d9f6");
var anObject = __webpack_require__("e4ae");
var getKeys = __webpack_require__("c3a1");

module.exports = __webpack_require__("8e60") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "7f20":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("86cc").f;
var has = __webpack_require__("69a8");
var TAG = __webpack_require__("2b4c")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "7f7f":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("86cc").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__("9e1e") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "8079":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var macrotask = __webpack_require__("1991").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__("2d95")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "8378":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "8436":
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "8449":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__("386b")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),

/***/ "84f2":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "85f2":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("454f");

/***/ }),

/***/ "86cc":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("cb7c");
var IE8_DOM_DEFINE = __webpack_require__("c69a");
var toPrimitive = __webpack_require__("6a99");
var dP = Object.defineProperty;

exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "8993":
/***/ (function(module, exports, __webpack_require__) {

var _Symbol$iterator = __webpack_require__("5d58");

var _Symbol = __webpack_require__("67bb");

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof _Symbol === "function" && typeof _Symbol$iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof _Symbol === "function" && obj.constructor === _Symbol && obj !== _Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "8a81":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__("7726");
var has = __webpack_require__("69a8");
var DESCRIPTORS = __webpack_require__("9e1e");
var $export = __webpack_require__("5ca1");
var redefine = __webpack_require__("2aba");
var META = __webpack_require__("67ab").KEY;
var $fails = __webpack_require__("79e5");
var shared = __webpack_require__("5537");
var setToStringTag = __webpack_require__("7f20");
var uid = __webpack_require__("ca5a");
var wks = __webpack_require__("2b4c");
var wksExt = __webpack_require__("37c8");
var wksDefine = __webpack_require__("3a72");
var enumKeys = __webpack_require__("d4c0");
var isArray = __webpack_require__("1169");
var anObject = __webpack_require__("cb7c");
var isObject = __webpack_require__("d3f4");
var toIObject = __webpack_require__("6821");
var toPrimitive = __webpack_require__("6a99");
var createDesc = __webpack_require__("4630");
var _create = __webpack_require__("2aeb");
var gOPNExt = __webpack_require__("7bbc");
var $GOPD = __webpack_require__("11e9");
var $DP = __webpack_require__("86cc");
var $keys = __webpack_require__("0d58");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("9093").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("52a7").f = $propertyIsEnumerable;
  __webpack_require__("2621").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("2d00")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("32e9")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "8b97":
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__("d3f4");
var anObject = __webpack_require__("cb7c");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__("9b43")(Function.call, __webpack_require__("11e9").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "8e60":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("294c")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "8e6e":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__("5ca1");
var ownKeys = __webpack_require__("990b");
var toIObject = __webpack_require__("6821");
var gOPD = __webpack_require__("11e9");
var createProperty = __webpack_require__("f1ae");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),

/***/ "8f60":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("a159");
var descriptor = __webpack_require__("aebd");
var setToStringTag = __webpack_require__("45f2");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("35e8")(IteratorPrototype, __webpack_require__("5168")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "9003":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("6b4c");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "9093":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("ce10");
var hiddenKeys = __webpack_require__("e11e").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "9138":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("35e8");


/***/ }),

/***/ "9427":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("63b6");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__("a159") });


/***/ }),

/***/ "95d5":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("40c3");
var ITERATOR = __webpack_require__("5168")('iterator');
var Iterators = __webpack_require__("481b");
module.exports = __webpack_require__("584a").isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),

/***/ "990b":
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__("9093");
var gOPS = __webpack_require__("2621");
var anObject = __webpack_require__("cb7c");
var Reflect = __webpack_require__("7726").Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),

/***/ "9aa9":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "9b43":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("d8e8");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "9c6c":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__("2b4c")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "9c80":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "9def":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("4588");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "9e1e":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("79e5")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "a159":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("e4ae");
var dPs = __webpack_require__("7e90");
var enumBugKeys = __webpack_require__("1691");
var IE_PROTO = __webpack_require__("5559")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("1ec9")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("32fc").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "a25f":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "a481":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__("cb7c");
var toObject = __webpack_require__("4bf8");
var toLength = __webpack_require__("9def");
var toInteger = __webpack_require__("4588");
var advanceStringIndex = __webpack_require__("0390");
var regExpExec = __webpack_require__("5f1b");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "a5b8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__("d8e8");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "a745":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("f410");

/***/ }),

/***/ "aa77":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("5ca1");
var defined = __webpack_require__("be13");
var fails = __webpack_require__("79e5");
var spaces = __webpack_require__("fdef");
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),

/***/ "aae3":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__("d3f4");
var cof = __webpack_require__("2d95");
var MATCH = __webpack_require__("2b4c")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "ac6a":
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__("cadf");
var getKeys = __webpack_require__("0d58");
var redefine = __webpack_require__("2aba");
var global = __webpack_require__("7726");
var hide = __webpack_require__("32e9");
var Iterators = __webpack_require__("84f2");
var wks = __webpack_require__("2b4c");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "aebd":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "aef6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__("5ca1");
var toLength = __webpack_require__("9def");
var context = __webpack_require__("d2c8");
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__("5147")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),

/***/ "b0c5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpExec = __webpack_require__("520a");
__webpack_require__("5ca1")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "b0dc":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("e4ae");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "b39a":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "b447":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("3a38");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "b54a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__("386b")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),

/***/ "b8e3":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "ba92":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__("4bf8");
var toAbsoluteIndex = __webpack_require__("77f1");
var toLength = __webpack_require__("9def");

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "bcaa":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("cb7c");
var isObject = __webpack_require__("d3f4");
var newPromiseCapability = __webpack_require__("a5b8");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "be13":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "be37":
/***/ (function(module, exports, __webpack_require__) {

var _Object$setPrototypeOf = __webpack_require__("4d16");

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = _Object$setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "bf0b":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("355d");
var createDesc = __webpack_require__("aebd");
var toIObject = __webpack_require__("36c3");
var toPrimitive = __webpack_require__("1bc3");
var has = __webpack_require__("07e3");
var IE8_DOM_DEFINE = __webpack_require__("794b");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__("8e60") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "c207":
/***/ (function(module, exports) {



/***/ }),

/***/ "c26b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__("86cc").f;
var create = __webpack_require__("2aeb");
var redefineAll = __webpack_require__("dcbc");
var ctx = __webpack_require__("9b43");
var anInstance = __webpack_require__("f605");
var forOf = __webpack_require__("4a59");
var $iterDefine = __webpack_require__("01f9");
var step = __webpack_require__("d53b");
var setSpecies = __webpack_require__("7a56");
var DESCRIPTORS = __webpack_require__("9e1e");
var fastKey = __webpack_require__("67ab").fastKey;
var validate = __webpack_require__("b39a");
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ "c366":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("6821");
var toLength = __webpack_require__("9def");
var toAbsoluteIndex = __webpack_require__("77f1");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "c367":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("8436");
var step = __webpack_require__("50ed");
var Iterators = __webpack_require__("481b");
var toIObject = __webpack_require__("36c3");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("30f1")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "c3a1":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("e6f3");
var enumBugKeys = __webpack_require__("1691");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "c47a":
/***/ (function(module, exports, __webpack_require__) {

var _Object$defineProperty = __webpack_require__("85f2");

function _defineProperty(obj, key, value) {
  if (key in obj) {
    _Object$defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "c5f6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("7726");
var has = __webpack_require__("69a8");
var cof = __webpack_require__("2d95");
var inheritIfRequired = __webpack_require__("5dbc");
var toPrimitive = __webpack_require__("6a99");
var fails = __webpack_require__("79e5");
var gOPN = __webpack_require__("9093").f;
var gOPD = __webpack_require__("11e9").f;
var dP = __webpack_require__("86cc").f;
var $trim = __webpack_require__("aa77").trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__("2aeb")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__("9e1e") ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__("2aba")(global, NUMBER, $Number);
}


/***/ }),

/***/ "c69a":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function () {
  return Object.defineProperty(__webpack_require__("230e")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c8bb":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("54a1");

/***/ }),

/***/ "ca5a":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "cadf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("9c6c");
var step = __webpack_require__("d53b");
var Iterators = __webpack_require__("84f2");
var toIObject = __webpack_require__("6821");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("01f9")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "cb7c":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "ccb9":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("5168");


/***/ }),

/***/ "cd1c":
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__("e853");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "ce10":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("69a8");
var toIObject = __webpack_require__("6821");
var arrayIndexOf = __webpack_require__("c366")(false);
var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "ce7e":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("63b6");
var core = __webpack_require__("584a");
var fails = __webpack_require__("294c");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "d263":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__("386b")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),

/***/ "d2c8":
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__("aae3");
var defined = __webpack_require__("be13");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "d2d5":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("1654");
__webpack_require__("549b");
module.exports = __webpack_require__("584a").Array.from;


/***/ }),

/***/ "d3f4":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "d4c0":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("0d58");
var gOPS = __webpack_require__("2621");
var pIE = __webpack_require__("52a7");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "d53b":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "d864":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("79aa");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "d892":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return listenForWindowEvents; });
/**
 * THIS FILE IS GENERATED AUTOMATICALLY.
 * DO NOT EDIT.
 **/

/**
 * Helper function to add a generic windows event listener to the page
 * which acts as a bridge between the web page and the content script bridge.
 * @param bridge
 * @param type
 */
var listenForWindowEvents = function listenForWindowEvents(bridge, type) {
  // Listen for any events from the web page and transmit to the BEX bridge.
  window.addEventListener('message', function (payload) {
    // We only accept messages from this window to itself [i.e. not from any iframes]
    if (payload.source != window) {
      return;
    }

    if (payload.data.from !== void 0 && payload.data.from === type) {
      var eventData = payload.data[0],
          bridgeEvents = bridge.getEvents();

      for (var event in bridgeEvents) {
        if (event === eventData.event) {
          bridgeEvents[event](eventData.payload);
        }
      }
    }
  }, false);
};

/***/ }),

/***/ "d8d6":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("1654");
__webpack_require__("6c1c");
module.exports = __webpack_require__("ccb9").f('iterator');


/***/ }),

/***/ "d8e8":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "d8f0":
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "d9f6":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("e4ae");
var IE8_DOM_DEFINE = __webpack_require__("794b");
var toPrimitive = __webpack_require__("1bc3");
var dP = Object.defineProperty;

exports.f = __webpack_require__("8e60") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "dbdb":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("584a");
var global = __webpack_require__("e53d");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("b8e3") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "dc62":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("9427");
var $Object = __webpack_require__("584a").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),

/***/ "dcbc":
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__("2aba");
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),

/***/ "e0b8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("7726");
var $export = __webpack_require__("5ca1");
var redefine = __webpack_require__("2aba");
var redefineAll = __webpack_require__("dcbc");
var meta = __webpack_require__("67ab");
var forOf = __webpack_require__("4a59");
var anInstance = __webpack_require__("f605");
var isObject = __webpack_require__("d3f4");
var fails = __webpack_require__("79e5");
var $iterDetect = __webpack_require__("5cc5");
var setToStringTag = __webpack_require__("7f20");
var inheritIfRequired = __webpack_require__("5dbc");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "e11e":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "e4ae":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("f772");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "e53d":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "e6f3":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("07e3");
var toIObject = __webpack_require__("36c3");
var arrayIndexOf = __webpack_require__("5b4e")(false);
var IE_PROTO = __webpack_require__("5559")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "e853":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
var isArray = __webpack_require__("1169");
var SPECIES = __webpack_require__("2b4c")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "ead6":
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__("f772");
var anObject = __webpack_require__("e4ae");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__("d864")(Function.call, __webpack_require__("bf0b").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "ebd6":
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__("cb7c");
var aFunction = __webpack_require__("d8e8");
var SPECIES = __webpack_require__("2b4c")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "ebfd":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("62a0")('meta');
var isObject = __webpack_require__("f772");
var has = __webpack_require__("07e3");
var setDesc = __webpack_require__("d9f6").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("294c")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "ec30":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__("9e1e")) {
  var LIBRARY = __webpack_require__("2d00");
  var global = __webpack_require__("7726");
  var fails = __webpack_require__("79e5");
  var $export = __webpack_require__("5ca1");
  var $typed = __webpack_require__("0f88");
  var $buffer = __webpack_require__("ed0b");
  var ctx = __webpack_require__("9b43");
  var anInstance = __webpack_require__("f605");
  var propertyDesc = __webpack_require__("4630");
  var hide = __webpack_require__("32e9");
  var redefineAll = __webpack_require__("dcbc");
  var toInteger = __webpack_require__("4588");
  var toLength = __webpack_require__("9def");
  var toIndex = __webpack_require__("09fa");
  var toAbsoluteIndex = __webpack_require__("77f1");
  var toPrimitive = __webpack_require__("6a99");
  var has = __webpack_require__("69a8");
  var classof = __webpack_require__("23c6");
  var isObject = __webpack_require__("d3f4");
  var toObject = __webpack_require__("4bf8");
  var isArrayIter = __webpack_require__("33a4");
  var create = __webpack_require__("2aeb");
  var getPrototypeOf = __webpack_require__("38fd");
  var gOPN = __webpack_require__("9093").f;
  var getIterFn = __webpack_require__("27ee");
  var uid = __webpack_require__("ca5a");
  var wks = __webpack_require__("2b4c");
  var createArrayMethod = __webpack_require__("0a49");
  var createArrayIncludes = __webpack_require__("c366");
  var speciesConstructor = __webpack_require__("ebd6");
  var ArrayIterators = __webpack_require__("cadf");
  var Iterators = __webpack_require__("84f2");
  var $iterDetect = __webpack_require__("5cc5");
  var setSpecies = __webpack_require__("7a56");
  var arrayFill = __webpack_require__("36bd");
  var arrayCopyWithin = __webpack_require__("ba92");
  var $DP = __webpack_require__("86cc");
  var $GOPD = __webpack_require__("11e9");
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "ecfa":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __webpack_require__("8e6e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__("8a81");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("ac6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __webpack_require__("cadf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__("06db");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __webpack_require__("456d");

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/helpers/defineProperty.js
var defineProperty = __webpack_require__("c47a");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./.quasar/bex/bridge.js + 1 modules
var bridge = __webpack_require__("69e5");

// CONCATENATED MODULE: ./src-bex/js/content-hooks.js
// Hooks added here have a bridge allowing communication between the BEX Content Script and the Quasar Application.
// More info: https://quasar.dev/quasar-cli/developing-browser-extensions/content-hooks
function attachContentHooks()
/* bridge */
{// Hook into the bridge to listen for events sent from the client BEX.

  /*
  bridge.on('some.event', event => {
    if (event.data.yourProp) {
      // Access a DOM element from here.
      // Document in this instance is the underlying website the contentScript runs on
      const el = document.getElementById('some-id')
      if (el) {
        el.value = 'Quasar Rocks!'
      }
    }
  })
  */
}
// EXTERNAL MODULE: ./.quasar/bex/content/window-event-listener.js
var window_event_listener = __webpack_require__("d892");

// CONCATENATED MODULE: ./.quasar/bex/content/content-script.js








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * THIS FILE IS GENERATED AUTOMATICALLY.
 * DO NOT EDIT.
 *
 * You are probably looking into adding hooks in your code. This should be done by means of
 * src-bex/js/content-hooks.js which has access to the browser instance and communication bridge
 **/

/* global chrome */



var port = chrome.runtime.connect({
  name: 'contentScript'
});
var disconnected = false;
port.onDisconnect.addListener(function () {
  disconnected = true;
});
var content_script_bridge = new bridge["a" /* default */]({
  listen: function listen(fn) {
    port.onMessage.addListener(fn);
  },
  send: function send(data) {
    if (!disconnected) {
      port.postMessage(data);
      window.postMessage(_objectSpread(_objectSpread({}, data), {}, {
        from: 'bex-content-script'
      }), '*');
    }
  }
}); // Inject our dom script for communications.

function injectScript(url) {
  var script = document.createElement('script');
  script.src = url;

  script.onload = function () {
    this.remove();
  };

  (document.head || document.documentElement).appendChild(script);
}

if (document instanceof HTMLDocument) {
  injectScript(chrome.extension.getURL( false ? undefined : 'www/js/bex-dom.js'));
} // Listen for event from the web page


Object(window_event_listener["a" /* listenForWindowEvents */])(content_script_bridge, 'bex-dom');
attachContentHooks(content_script_bridge);

/***/ }),

/***/ "ed0b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("7726");
var DESCRIPTORS = __webpack_require__("9e1e");
var LIBRARY = __webpack_require__("2d00");
var $typed = __webpack_require__("0f88");
var hide = __webpack_require__("32e9");
var redefineAll = __webpack_require__("dcbc");
var fails = __webpack_require__("79e5");
var anInstance = __webpack_require__("f605");
var toInteger = __webpack_require__("4588");
var toLength = __webpack_require__("9def");
var toIndex = __webpack_require__("09fa");
var gOPN = __webpack_require__("9093").f;
var dP = __webpack_require__("86cc").f;
var arrayFill = __webpack_require__("36bd");
var setToStringTag = __webpack_require__("7f20");
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "f0c1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("d8e8");
var isObject = __webpack_require__("d3f4");
var invoke = __webpack_require__("31f4");
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),

/***/ "f1ae":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__("86cc");
var createDesc = __webpack_require__("4630");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "f28c":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "f400":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__("c26b");
var validate = __webpack_require__("b39a");
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__("e0b8")(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ "f410":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("1af6");
module.exports = __webpack_require__("584a").Array.isArray;


/***/ }),

/***/ "f559":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__("5ca1");
var toLength = __webpack_require__("9def");
var context = __webpack_require__("d2c8");
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__("5147")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "f605":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "f751":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("5ca1");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("7333") });


/***/ }),

/***/ "f772":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "f921":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("014b");
__webpack_require__("c207");
__webpack_require__("69d3");
__webpack_require__("765d");
module.exports = __webpack_require__("584a").Symbol;


/***/ }),

/***/ "fa5b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("5537")('native-function-to-string', Function.toString);


/***/ }),

/***/ "fa99":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("0293");
module.exports = __webpack_require__("584a").Object.getPrototypeOf;


/***/ }),

/***/ "faa1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "fab2":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("7726").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "fc74":
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "fdef":
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "ffe3":
/***/ (function(module, exports, __webpack_require__) {

var _Object$getPrototypeOf = __webpack_require__("061b");

var _Object$setPrototypeOf = __webpack_require__("4d16");

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = _Object$setPrototypeOf ? _Object$getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || _Object$getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ })

/******/ });